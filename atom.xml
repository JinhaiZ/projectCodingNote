<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Coding Note</title>
  
  <subtitle>积土为山，积水为海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://codingnote.com/"/>
  <updated>2021-01-18T22:09:14.675Z</updated>
  <id>http://codingnote.com/</id>
  
  <author>
    <name>水 &amp; 海</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解JSON Web Token系列1：JWT的历史</title>
    <link href="http://codingnote.com/2021/01/18/jwt-intro-1/"/>
    <id>http://codingnote.com/2021/01/18/jwt-intro-1/</id>
    <published>2021-01-18T22:31:55.000Z</published>
    <updated>2021-01-18T22:09:14.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img data-src="/2021/01/18/jwt-intro-1/jwt-intro-1-cover.png" class><a id="more"></a><p><strong>文章目录</strong></p><!-- toc --><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">什么是身份验证</a></li><li><a href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">如何避免重复身份验证？</a><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions">服务端Sessions</a><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions%E7%9A%84%E7%BC%BA%E9%99%B7">服务端Sessions的缺陷</a></li></ul></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions%E6%96%B9%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B">服务端Sessions方法的改进</a><ul><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions%E7%9A%84%E6%94%B9%E8%BF%9B%E7%B2%98%E6%80%A7%E4%BC%9A%E8%AF%9D">服务端Sessions的改进：粘性会话</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions%E7%9A%84%E6%94%B9%E8%BF%9B%E5%86%85%E5%AD%98%E5%90%8C%E6%AD%A5">服务端Sessions的改进：内存同步</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsessions%E7%9A%84%E6%94%B9%E8%BF%9B%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93">服务端Sessions的改进：内存数据库</a></li></ul></li></ul></li><li><a href="#%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81-saml%E5%8D%8F%E8%AE%AE">基于令牌的身份验证 SAML协议</a><ul><li><a href="#%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E7%9A%84%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%94%A8%E6%88%B7%E9%87%8D%E5%A4%8D%E7%99%BB%E9%99%86%E9%97%AE%E9%A2%98%E7%9A%84">基于令牌的身份验证是怎么解决用户重复登陆问题的？</a></li></ul></li><li><a href="#saml%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85oidc">SAML的继任者OIDC</a><ul><li><a href="#saml%E7%9A%84%E7%BC%BA%E9%99%B7">SAML的缺陷</a><ul><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88xml%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BB%A4%E7%89%8C%E4%B8%8D%E6%98%93%E4%BC%A0%E8%BE%93">为什么XML格式的令牌不易传输</a></li><li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88xml%E6%A0%BC%E5%BC%8F%E7%9A%84%E4%BB%A4%E7%89%8C%E4%B8%8D%E6%98%93%E4%BD%BF%E7%94%A8">为什么XML格式的令牌不易使用</a></li></ul></li></ul></li><li><a href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB">拓展阅读</a><ul><li><a href="#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81-authentication%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95">身份验证 (Authentication)的三种方法</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFsession%E5%AE%A2%E6%88%B7%E7%AB%AFsession%E7%9A%84%E6%AF%94%E8%BE%83">服务端Session，客户端Session的比较</a></li><li><a href="#saml%E5%8D%8F%E8%AE%AEoauth2%E5%8D%8F%E8%AE%AE%E5%92%8Coicd%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%AF%94%E8%BE%83">SAML协议，OAuth2协议和OICD协议的比较</a></li><li><a href="#jwt%E5%92%8Cxaml-assertion%E7%9A%84%E6%AF%94%E8%BE%83">JWT和XAML Assertion的比较</a></li><li><a href="#jwt%E5%92%8Cswt%E7%9A%84%E6%AF%94%E8%BE%83">JWT和SWT的比较</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li></ul><!-- tocstop --><p>移动互联网时代，OIDC变得越来越流行，如果你在使用Android，AWS，Microsoft Azure，Salesforce或Google，那么你很可能已经在使用OIDC协议和JWT令牌。本文是深入理解JSON Web Token系列第一部分，追本溯源，JWT是移动互联网时代手机app在<strong>身份验证 (Authentication)<strong>和</strong>授权 (Authorization)</strong> 中使用最广泛的令牌规范，而在JWT被发明前，SAML Assertion令牌曾一度风靡Web浏览器主导的时代。为了解JWT的历史，本文以身份验证中，如何避免对用户重复进行验证为线索，依次介绍了服务端Session，服务端Session的改进方法，SAML协议以及现在使用最广泛的的OIDC协议。其中OIDC协议使用了本文的主角JWT。</p><h1><span id="什么是身份验证"> 什么是身份验证</span></h1><p>在日常生活中，有许多需要<strong>身份验证</strong>的场景。比如进入公司的大楼时，需要携带工牌；打卡上班时，需要指纹识别；打开工作电脑时，需要输入密码。</p><p><strong>身份验证(Authentication)<strong>的目的是确认当前所声称为某种身份的用户，确实是所声称的用户。在计算机、通信等领域，我们一般有三种方法来</strong>确认用户的身份(Authenticate)</strong>，基于用户知道的东西，基于用户拥有的东西，以及基于用户的生物特征的方法</p><ol><li>基于用户知道的东西：比如密码，安全问题等</li><li>基于用户拥有的东西：比如身份证，安全令牌（手机软件令牌或者物理令牌），体内植入装置等</li><li>基于用户的生物特征：比如指纹，视网膜，声纹，面部信息，签名等</li></ol><p>Web服务一般通过前两种方式来验证用户的身份。最常见的就是通过用户名和密码来确认用户的身份，确认过身份的用户称为为<strong>授权用户(Authenticated user)</strong>。</p><p>比如下图所示的例子，Web服务器通过HTTP协议向<strong>授权用户</strong>提供对于资源A的访问。Web服务器是向用户提供Web服务的机器。在这里，你可以想象下图中的Web服务器是一个视频网站的后端，资源A可以是注册用户才能观看的视频，客户端可以是手机app或者是浏览器。</p><p>在这里，用户通过客户端向Web服务器提供用户名和密码，Web服务器则在身份验证数据库中检查用户的真实性(authenticity)。<em>这里对Web服务器的逻辑有很多省略，比如，用户注册后，身份验证数据库就保存了用户的用户名和密码，所以，验证用户名和密码就是在身份验证数据库中找到该用户，并且检查用户提供的密码是否与数据库中的密码匹配。</em></p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-2.png" class><p>如果同一个用户想要访问资源B，那么就如同访问资源A一样。用户需要通过客户端再次向Web服务器提供用户名和密码。你可能也发现了，这里的用户体验是很不好的，因为用户每访问一个资源，就需要再次输入用户名和密码。没有一个现代Web服务会要求用户这么做。</p><h1><span id="如何避免重复身份验证"> 如何避免重复身份验证？</span></h1><h2><span id="服务端sessions"> 服务端Sessions</span></h2><p>早期的Web服务器会通过保存用户<strong>Sessions (会话信息)</strong> <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>的方式避免用户重复输入用户名密码。在用户第一次向Web服务器请求资源时，Web服务器在身份验证数据库中检查用户的真实性，如果用户身份验证成功，Web服务器则生成一个<strong>键值对(Key-Value Pair)<strong>保存在Web服务器的内存中。其中</strong>键</strong>为<strong>Session ID(会话ID)</strong>，<strong>值</strong>为与身份验证有关的信息，比如用户名，身份有效期等。接下来，Web服务器把资源A和Session ID一并返回给客户端，客户端会替用户保存Session ID。</p><p>当用户想要访问资源B时，客户端会把Session ID直接发送给Web服务器，不需要用户再次输入用户名和密码。Web服务器收到请求后，在它的内存中验证与Session ID对应的Session，如果验证成功，则返回资源B。<em>为了安全起见，Session ID一般都存在有效期，在有效期内，用户访问Web服务器上的资源都不需要再次输入用户名和密。</em></p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-3.png" class><h4><span id="服务端sessions的缺陷"> 服务端Sessions的缺陷</span></h4><p>服务端Sessions曾一度是避免重复身份验证的方法，直到使用Web服务的用户越来越多，多到一个Web服务器已经无法满足用户请求了。为了满足日益增长的用户请求，一个常见的作法是对Web服务的架构进行<strong>水平拓展 (Horizontal Scaling)</strong> <sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。然而在水平拓展后，服务端Sessions避免重复身份验证的方法就失效了。</p><p>Web服务的架构进行水平拓展后，客户端不再直接与Web服务器进行交流。取而代之是负载均衡服务器 (Load Balancer) <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，负载均衡服务器就像是包工头，它把来自客户端的请求路由给不同的Web服务器。如下图所示，客户端通过负载均衡服务器访问Web服务器X上的资源，服务器X保存了用户的Session。当客户再次访问服务器X上的资源时，服由于服务器X保存了用户的Session，用户的身份验证成功。如果客户端访问了服务器Y，由于服务器Y没有保存用户的Session，用户的身份验证失败。所以服务端Sessions的方法在服务器水平拓展的情况下是有缺陷的。</p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-4.png" class><h2><span id="服务端sessions方法的改进"> 服务端Sessions方法的改进</span></h2><p>服务端Sessions方法在水平拓展的架构下是有缺陷的，有没有什么办法可以改进该方法，使其在水平拓展的架构下能够继续适用呢？方法是有的，下面便依次介绍三种方法，需要注意的是，下面三种方法也有各自的缺陷。</p><ol><li>粘性会话 (load balancer sticky session)</li><li>内存同步 (memory replication)</li><li>内存数据库 (in-memory database)</li></ol><h3><span id="服务端sessions的改进粘性会话"> 服务端Sessions的改进：粘性会话</span></h3><p>负载均衡服务器一般不会保证同一用户的请求会被路由到同一个服务器，这是造成服务端Sessions方法失效的直接原因。如果对负载均衡服务器加以改造，让同一用户的请求路由到同一个服务器，那么服务端Sessions方法就可以继续使用下去了。一般负载均衡服务器可以通过客户端Cookie，或者客户端IP来标识和追踪每位用户，为不同用户分配标识ID。根据标识ID，负载均衡服务器可以把某用户的所有请求路由到特定服务器上。这种方法叫做<strong>粘性会话 (Sticky Session)</strong>，形象地说就是会话粘到了特定的服务器上。</p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-6.png" class><p>负载均衡服务器的主要目的是均衡不同服务器上的负载，所以当新的请求到来时，一般要把新请求路由到负载最轻的服务器上，以便让不同的服务器有差不多负载。而采用了粘性会话的负载均衡服务器，由于要保证来自相同的用户的请求被路由到特定的服务器，会导致不同服务器上的负载不均衡。造成有些Web服务器负载过重，而有些Web服务器负载过轻的问题。</p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-7.png" class><h3><span id="服务端sessions的改进内存同步"> 服务端Sessions的改进：内存同步</span></h3><p>之前的方法需要把特定的用户的Session保存在特定的服务器上，这样用户需要访问特定服务器才能取得之前的Session。有没有什么方法能放宽这种限制，让用户不需要访问特定的服务器呢？</p><p>一种按照这种思路解决问题的方法是内存同步 (Memory Replication)，当Web服务器X生成用户Session时，不仅在自己的内存中保存一份，同时也向服务器Y发送请求，让服务器Y也保存一份用户的Session。这样不论用户访问哪个服务器，都可以通过Session ID取得相应的Session。</p><p>然而在不同的服务器上进行内存同步不是一件简单的事情，这里会涉及到分布式系统中的许多问题。比如，用户在服务器Y还没来的及保存Session时就访问了服务器Y，那么服务器Y会要求用户输入用户名和密码，生成该用户的Session并请求服务器X也保存该信息，那么服务器X上的Session还没来及使用就已经作废了。</p><h3><span id="服务端sessions的改进内存数据库"> 服务端Sessions的改进：内存数据库</span></h3><p>不在特定Web服务器上保存Session，这样用户就不需要访问特定的Web服务器来获取上面存放的Session了。另外一种按照这种思路解决问题的方法是使用数据库，这时Web服务器不在自己的内存中保存Session，而是在一个所有服务器都可以存取的数据库中保存Session。通常，为了减少时延，会采用下图所示的内存数据库 (In-memory database)。因为，内存数据库的数据完全存放在内存中，相比传统数据库有更高的存取速度。</p><p>如下图所示，不论用户的请求是被负载均衡服务器路由到了哪个Web服务器，用户的Session都可以在内存数据库中根据Session ID找到。</p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-5.png" class><p>内存数据库虽然可以解决内存同步的问题，但是额外的数据库会带来架构复杂性的提升：内存数据库一旦失效，整个系统的会话就没法运作，这是典型的单点故障 (Single ponit of failure) <sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，会严重影响Web服务的<strong>可用性 (Availability)</strong> <sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。为了去除单点故障，我们可以把内存数据库放到另外一个负载均衡服务器后面，并增加一个内存数据库的热备份，但是，这样的架构太复杂了。此外，额外的数据库会带来额外的时间开销。即便内存数据库的存取速度很快，但是因为有额外的网络时延，内存数据库还是要慢上许多。</p><h1><span id="基于令牌的身份验证-saml协议"> 基于令牌的身份验证 SAML协议</span></h1><p>服务端Session的弊端让人们思考避免重复身份验证的其他方法。大约在2001年，为了解决网页浏览器SSO (单点登录) <sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup> 的需求，SAML (安全主张标记语言) <sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup> 被发明出来。SSO是一个比较常见的需求，比如手机登陆微信账号后，访问CSDN，图灵教育，InfoQ等网站时可以选择微信免密码登陆，这就是一种SSO。</p><p>SAML规范定义了三个角色：委托人(通常为一名用户)、身份提供者(IdP)，服务提供者(SP)。</p><p>如下图，在用SAML解决的使用案例中，身份验证流程如下</p><ol><li>用户从服务提供者那里请求一项服务，比如登陆CSDN网站。</li><li>CSDN网站返回一个SAMLrequest。</li><li>浏览器收到SAMLrequest，把用户跳转到IdP的身份验证网页，比如微信登陆页面。这时用户可以输入用户名和密码登陆，或者扫码登陆。</li><li>IdP验证用户身份后返回SAML response (其中包括SAML Assertion)。</li><li>浏览器收到SAML response (其中包括SAML Assertion)后，把SAMLresponse发送给SP，SP检查SAMLresponse，验证成功后，用户便可以获得SP的服务，比如登陆CSDN网站。</li></ol><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-8.png" class><p>SAML是一种**基于令牌的身份验证 (Token based Authentication)<strong>和</strong>授权 (Token based Authorization)**的协议。其协议背后的一般概念可以总结如下。 用户向IdP输入他们的用户名和密码，以获得一个令牌，该令牌允许他们获取特定资源时无需使用用户名和密码。 一旦获得了令牌，用户就可以向SP提供令牌并在一段时间内可以访问特定资源。</p><h2><span id="基于令牌的身份验证是怎么解决用户重复登陆问题的"> 基于令牌的身份验证是怎么解决用户重复登陆问题的？</span></h2><p>虽然SAML是为了解决SSO需求而发明的，但是它连带着解决了用户身份重复验证的问题。作为对比，服务端Session方法需要在服务端保存用户的身份信息，也就是说，服务器需要保存用户的状态。在有多个服务器的情况下，服务器之间需要同步用户的状态，实现起来不简单而且易出错；而基于令牌的方法不需要在服务端保存用户的身份信息，也就是说，服务器只需要验证令牌的有效性就可以了。验证令牌涉及到对称以及非对称加密算法，在单个或者多个服务器的情况下，验证令牌的算法没有区别。</p><h1><span id="saml的继任者oidc"> SAML的继任者OIDC</span></h1><p>SAML被发明的时代Web浏览器占据主导地位，SOAP <sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>和XML分别是Web协议和Web数据交换格式的代表。所以SAML协议与SOAP和XML有着紧密地联系。SAML通过SOAP在用户，IdP和SP间使用XML传输信息，并且SAML定义的令牌，SAML Assertion，就使用了XML格式。</p><h2><span id="saml的缺陷"> SAML的缺陷</span></h2><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-10.png" class><p><em>屏幕截图中的网站是 <span class="exturl" data-url="aHR0cHM6Ly9zYW1sdG9vbC5pby8=">https://samltool.io/<i class="fa fa-external-link-alt"></i></span>，展示了SAML定义的令牌 SAML Assertion</em></p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-11.png" class><p><em>屏幕截图中的网站是 <span class="exturl" data-url="aHR0cHM6Ly9qd3QuaW8v">https://jwt.io/<i class="fa fa-external-link-alt"></i></span>，展示了具有JSON格式的令牌JWT</em></p><p>然而随着移动互联网时代到来，SOAP和XML分别被REST <sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>和JSON代替，这时与SOAP和XML紧密联系的SAML协议的弊端也逐渐显现。其中最重要是基于XML格式的令牌体积巨大，定义复杂，不易在移动互联网中传输和使用。因为这些缺点，SAML定义的令牌，SAML Assertion近年来又被JSON的令牌 JWT (JSON Web Token) <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTk=">RFC-7519<i class="fa fa-external-link-alt"></i></span> 所代替的趋势。</p><h3><span id="为什么xml格式的令牌不易传输"> 为什么XML格式的令牌不易传输</span></h3><p>XML格式的令牌不易传输是相较于JSON格式的令牌而言的。首先XML格式冗长，不仅包含数据，而且包含数据定义，虽然具有自解释性，但是相比于只包含数据的JSON格式，XML格式保存令牌的体积比JSON大。</p><h3><span id="为什么xml格式的令牌不易使用"> 为什么XML格式的令牌不易使用</span></h3><p>XML格式的令牌不易使用是相较于JSON格式的令牌而言的。JSON是JavaScript编程语言的一等公民，JavaScript可以直接操作JSON格式的数据。所以JavaScript应用之间几乎都是用JSON进行数据交换，比如REST，JSON-和GraphQL。虽然JavaScript也可以使用XML，但是相比JSON，使用XML的过程更复杂，比如需要解析和序列化的工具。</p><p>因为SAML Assertion的缺陷，不仅是SAML Assertion，SAML本身也岌岌可危。诞生于2014年的<strong>OIDC (Open ID Connnect)</strong> 协议在设计时主要考虑了移动互联网和手机app的需求。所以OIDC设计的主要原则是易于传输和使用。OIDC的用户授权 (Auhorization) 基于OAuth2，并在OAuth2的基础上提供了用户验证 (Authentication) ，成为集用户验证和用户授权于一体的协议，就和SAML一样。于SAML不同的是，OIDC在令牌上，不仅支持 SAML Assertion，更是支持具有JSON格式的JWT。有了JWT加持，OIDC协议比SAML更易于传输和使用。</p><p>由于OIDC协议支持REST和JSON之类的现代技术，移动互联网时代的Web应用以及手机app可以更方便的实现OIDC协议。OIDC协议非常适合与SPA (Single-Page Application) 和手机app和一起使用，而在这些应用程序中，使用SAML会很困难。所以在移动互联网时代，OIDC变得越来越流行，如果你在使用Android，AWS，Microsoft Azure，Salesforce或Google，那么你很可能已经在使用OIDC协议和JWT令牌 <sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>。</p><p>SAML为解决了企业SSO的需求而诞生，虽然仍然被广泛地应用于企业身份验证中 <sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，但是由于其协议过于学术化(复杂)，而且支持它library太少了。所以现在也有被OICD协议的替代的趋势。</p><p>因为JWT的体积很小，可以在HTTP协议中作为URL的一部分被传输，如下图所示</p><img data-src="/2021/01/18/jwt-intro-1/jwt-Page-9.png" class><h1><span id="拓展阅读"> 拓展阅读</span></h1><h2><span id="身份验证-authentication的三种方法"> 身份验证 (Authentication)的三种方法</span></h2><p>身份验证的目的是确认用户的<strong>真实性</strong> (Authenticity)，<strong>验证用户</strong> (Authenticate) 的方法可以大致归为以下三种，基于用户知道的东西，基于用户拥有的东西，基于用户的生物特征</p><ol><li>基于用户知道的东西：比如密码，安全问题</li><li>基于用户拥有的东西：比如身份证，安全令牌（手机软件令牌或者物理令牌），体内植入装置</li><li>基于用户的生物特征：比如指纹，视网膜，声纹，面部信息，签名</li></ol><h2><span id="服务端session客户端session的比较"> 服务端Session，客户端Session的比较</span></h2><p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjkyMjE0NS93aGF0LWlzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tc2VydmVyLXNpZGUtY29va2llLWFuZC1jbGllbnQtc2lkZS1jb29raWU=">https://stackoverflow.com/questions/6922145/what-is-the-difference-between-server-side-cookie-and-client-side-cookie<i class="fa fa-external-link-alt"></i></span></p><p>客户端Seesion <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9Db29raWVz">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies<i class="fa fa-external-link-alt"></i></span></p><h2><span id="saml协议oauth2协议和oicd协议的比较"> SAML协议，OAuth2协议和OICD协议的比较</span></h2><p>以下内容节选自 <span class="exturl" data-url="aHR0cHM6Ly9zZWN1cml0eS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODI1ODcvd2hhdC1hcmUtdGhlLWRpZmZlcmVuY2VzLWJldHdlZW4tanNvbi13ZWItdG9rZW5zLXNhbWwtYW5kLW9hdXRoLTI=">https://security.stackexchange.com/questions/82587/what-are-the-differences-between-json-web-tokens-saml-and-oauth-2<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----------+----------------+-------------------------------+</span><br><span class="line">| Protocol | Token          | Technologies | Design Pattern |</span><br><span class="line">+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+</span><br><span class="line">| SAML     | SAML Assertion | SOAP, XML    | Facade         |</span><br><span class="line">+----------+----------------+--------------+----------------+</span><br><span class="line">| OAuth 2  | Access Token   |              | Proxy          |</span><br><span class="line">+----------+----------------+--------------+----------------+</span><br><span class="line">| OIDC     | Access Token,  | REST, JSON   | Decorator      |</span><br><span class="line">|          | ID Token (JWT) |              |                |</span><br><span class="line">+----------+----------------+--------------+----------------+</span><br></pre></td></tr></table></figure><h2><span id="jwt和xaml-assertion的比较"> JWT和XAML Assertion的比较</span></h2><p>以下内容节选自 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjYXBwZW5kaXgtQg==">https://tools.ietf.org/html/rfc7519#appendix-B<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Appendix B.  Relationship of JWTs to SAML Assertions  </span><br><span class="line"></span><br><span class="line">  Security Assertion Markup Language (SAML) 2.0</span><br><span class="line">  [OASIS.saml-core-2.0-os] provides a standard for creating security</span><br><span class="line">  tokens with greater expressivity and more security options than</span><br><span class="line">  supported by JWTs.  However, the cost of this flexibility and</span><br><span class="line">  expressiveness is both size and complexity.  SAML&#39;s use of XML</span><br><span class="line">  [W3C.CR-xml11-20060816] and XML Digital Signature (DSIG) [RFC3275]</span><br><span class="line">  contributes to the size of SAML Assertions; its use of XML and</span><br><span class="line">  especially XML Canonicalization [W3C.REC-xml-c14n-20010315]</span><br><span class="line">  contributes to their complexity.</span><br><span class="line"></span><br><span class="line">  JWTs are intended to provide a simple security token format that is</span><br><span class="line">  small enough to fit into HTTP headers and query arguments in URIs.</span><br><span class="line">  It does this by supporting a much simpler token model than SAML and</span><br><span class="line">  using the JSON [RFC7159] object encoding syntax.  It also supports</span><br><span class="line">  securing tokens using Message Authentication Codes (MACs) and digital</span><br><span class="line">  signatures using a smaller (and less flexible) format than XML DSIG.</span><br><span class="line"></span><br><span class="line">  Therefore, while JWTs can do some of the things SAML Assertions do,</span><br><span class="line">  JWTs are not intended as a full replacement for SAML Assertions, but</span><br><span class="line">  rather as a token format to be used when ease of implementation or</span><br><span class="line">  compactness are considerations.</span><br><span class="line"></span><br><span class="line">  SAML Assertions are always statements made by an entity about a</span><br><span class="line">  subject.  JWTs are often used in the same manner, with the entity</span><br><span class="line">  making the statements being represented by the &quot;iss&quot; (issuer) claim,</span><br><span class="line">  and the subject being represented by the &quot;sub&quot; (subject) claim.</span><br><span class="line">  However, with these claims being optional, other uses of the JWT</span><br><span class="line">  format are also permitted.</span><br></pre></td></tr></table></figure><h2><span id="jwt和swt的比较"> JWT和SWT的比较</span></h2><p>以下内容节选自 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjYXBwZW5kaXgtQw==">https://tools.ietf.org/html/rfc7519#appendix-C<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Appendix C.  Relationship of JWTs to Simple Web Tokens (SWTs)</span><br><span class="line">  </span><br><span class="line">  Both JWTs and SWTs [SWT], at their core, enable sets of claims to be</span><br><span class="line">  communicated between applications.  For SWTs, both the claim names</span><br><span class="line">  and claim values are strings.  For JWTs, while claim names are</span><br><span class="line">  strings, claim values can be any JSON type.  Both token types offer</span><br><span class="line">  cryptographic protection of their content: SWTs with HMAC SHA-256 and</span><br><span class="line">  JWTs with a choice of algorithms, including signature, MAC, and</span><br><span class="line">  encryption algorithms.</span><br></pre></td></tr></table></figure><h1><span id="参考"> 参考</span></h1><ol><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXV0aGVudGljYXRpb24=">https://en.wikipedia.org/wiki/Authentication<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hdXRoMC5jb20vYmxvZy9ob3ctc2FtbC1hdXRoZW50aWNhdGlvbi13b3Jrcy8=">https://auth0.com/blog/how-saml-authentication-works/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnLzIwMDEvc3cvRXVyb3BlL2V2ZW50cy9mb2FmLWdhbHdheS9wYXBlcnMvZnAvdG9rZW5fYmFzZWRfYXV0aGVudGljYXRpb24v">https://www.w3.org/2001/sw/Europe/events/foaf-galway/papers/fp/token_based_authentication/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hdXRoMC5jb20vZG9jcy90b2tlbnMvYWNjZXNzLXRva2Vucw==">https://auth0.com/docs/tokens/access-tokens<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5mb3JtYXRpb253ZWVrLmNvbS9zb2Z0d2FyZS9pbmZvcm1hdGlvbi1tYW5hZ2VtZW50L3NhbWwtdGhlLXNlY3JldC10by1jZW50cmFsaXplZC1pZGVudGl0eS1tYW5hZ2VtZW50L2QvZC1pZC8xMDI4NjU2">https://www.informationweek.com/software/information-management/saml-the-secret-to-centralized-identity-management/d/d-id/1028656<i class="fa fa-external-link-alt"></i></span>?</li><li><span class="exturl" data-url="aHR0cHM6Ly9hdXRoMC5jb20vaW50cm8tdG8taWFtL3NhbWwtdnMtb3BlbmlkLWNvbm5lY3Qtb2lkYy8=">https://auth0.com/intro-to-iam/saml-vs-openid-connect-oidc/<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTk=">https://tools.ietf.org/html/rfc7519<i class="fa fa-external-link-alt"></i></span></li></ol><h1><span id="脚注"> 脚注</span></h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>Sessions, 也被称为服务器端Cookie (Server side cookies)。Sessions被保存在服务器上，客户端，也即浏览器仅Session ID。Session ID是Session的唯一标识 ，服务器用Session ID把客户端的请求与存储在服务器上的Sessions进行匹配。Sessions一般与用户的身份验证有关，有时也会包含用户偏好设置有关的信息，比如用户的语言偏好。于服务器端Cookie相对的是客户端Cookie，客户端Cookie也成为HTTP Cookie。服务端Cookie于客户端Cookie’的对比请参看 <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjkyMjE0NS93aGF0LWlzLXRoZS1kaWZmZXJlbmNlLWJldHdlZW4tc2VydmVyLXNpZGUtY29va2llLWFuZC1jbGllbnQtc2lkZS1jb29raWU=">https://stackoverflow.com/questions/6922145/what-is-the-difference-between-server-side-cookie-and-client-side-cookie<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>水平拓展，通过增加廉价服务器的方式增加Web服务器能够承担的负载，使其能够服务更多的用户，比如在1个Web服务器不能满足用户需求时，用2个Web服务器一起满足用户的需求。与之相对的是垂直拓展 (Vertical Scaling)，通过增加已有服务器的配置来Web服务器能够承担的负载，比如在1个Web服务器不能满足用户需求时，用一个配置更高的Web服务器，比如CPU更快，内存更大的Web服务器替代原来的服务器。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>负载均衡服务器，简称负载均衡器。是一种特殊的服务器，主要功能是负载分配给服务器。负载均衡器的类型很多，有的工作在OSI网络模型的传输层，具有很高的吞吐量。有的工作在应用层，可以根据HTTP的请求更智能的分配请求，比如把某个用户的请求总是分配给一个特定的服务器。 <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>单点故障，是指系统中一旦失效，就会让整个系统无法运作的部件。<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2luZ2xlX3BvaW50X29mX2ZhaWx1cmU=">https://en.wikipedia.org/wiki/Single_point_of_failure<i class="fa fa-external-link-alt"></i></span> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>可用性：Availability。简单的说，可用性就是一个系统处在可工作状态的时间的比例。例如，服务A在一年时间里（8760小时）有8751小时可用。其可用性则为8751/8760 = 0.999，或以百分比表示99.9%。详情参见 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXZhaWxhYmlsaXR5">https://en.wikipedia.org/wiki/Availability<i class="fa fa-external-link-alt"></i></span> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>SSO，Single sign-on的缩写。又译为单一签入，一种对于许多相互关连，但是又是各自独立的软件系统，提供访问控制的属性。当拥有这项属性时，当用户登录时，就可以获取所有系统的访问权限，不用对每个单一系统都逐一登录。SSO的需求最先出现在对企业内网中不同服务的访问，这种功能通常是以轻型目录访问协议（LDAP）来实现，在服务器上会将用户信息存储到LDAP数据库中。后来这种需求广拓展到了对互联网上不同服务的访问，主要目的是让用户只需一个账号即可访问所有互相信任的应用系统。详情参见 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2luZ2xlX3NpZ24tb24=">https://en.wikipedia.org/wiki/Single_sign-on<i class="fa fa-external-link-alt"></i></span> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>SAML，Security Assertion Markup Language的缩写。是一个基于XML的开源标准数据格式，它在当事方之间交换**身份验证 (Authentication)<strong>和</strong>授权 (Auhorization)**数据，尤其是在身份提供者 (IdP) 和服务提供者 (SP)之间交换。SAML是OASIS安全服务技术委员会的一个产品，始于2001年。详情参见 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU2VjdXJpdHlfQXNzZXJ0aW9uX01hcmt1cF9MYW5ndWFnZQ==">https://en.wikipedia.org/wiki/Security_Assertion_Markup_Language<i class="fa fa-external-link-alt"></i></span> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>SOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构的信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。详情参见 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU3JUFFJTgwJUU1JThEJTk1JUU1JUFGJUI5JUU4JUIxJUExJUU4JUFFJUJGJUU5JTk3JUFFJUU1JThEJThGJUU4JUFFJUFF">https://zh.wikipedia.org/wiki/简单对象访问协议<i class="fa fa-external-link-alt"></i></span> <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>表现层状态转换（英语：Representational State Transfer，缩写：REST）是Roy Thomas Fielding博士于2000年在他的博士论文[1]中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。表现层状态转换是根基于超文本传输协议（HTTP）之上而确定的一组约束和属性，是一种设计提供万维网络服务的软件构建风格。详情参见 <span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU4JUExJUE4JUU3JThFJUIwJUU1JUIxJTgyJUU3JThBJUI2JUU2JTgwJTgxJUU4JUJEJUFDJUU2JThEJUEy">https://zh.wikipedia.org/wiki/表现层状态转换<i class="fa fa-external-link-alt"></i></span> <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p>这句话翻译自&quot;If you use Android, AWS, Microsoft Azure, Salesforce, or Google then chances are that you are already using JWT.&quot;，来源是 <span class="exturl" data-url="aHR0cHM6Ly9hdXRoMC5jb20vYmxvZy9qd3QtanNvbi13ZWJ0b2tlbi1sb2dvLw==">https://auth0.com/blog/jwt-json-webtoken-logo/<i class="fa fa-external-link-alt"></i></span> <a href="#fnref10" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p>这一段话的来源参见 Application and Use Cases of OIDC and SAML <span class="exturl" data-url="aHR0cHM6Ly9hdXRoMC5jb20vaW50cm8tdG8taWFtL3NhbWwtdnMtb3BlbmlkLWNvbm5lY3Qtb2lkYy8=">https://auth0.com/intro-to-iam/saml-vs-openid-connect-oidc/<i class="fa fa-external-link-alt"></i></span> <a href="#fnref11" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;img data-src=&quot;/2021/01/18/jwt-intro-1/jwt-intro-1-cover.png&quot; class=&quot;&quot;&gt;
    
    </summary>
    
      <category term="JSON Web Token" scheme="http://codingnote.com/categories/JSON-Web-Token/"/>
    
      <category term="Web Security" scheme="http://codingnote.com/categories/JSON-Web-Token/Web-Security/"/>
    
      <category term="Web Technology" scheme="http://codingnote.com/categories/JSON-Web-Token/Web-Security/Web-Technology/"/>
    
    
      <category term="JSON Web Token" scheme="http://codingnote.com/tags/JSON-Web-Token/"/>
    
      <category term="SAML" scheme="http://codingnote.com/tags/SAML/"/>
    
      <category term="Server-side Sessions" scheme="http://codingnote.com/tags/Server-side-Sessions/"/>
    
      <category term="Authentication" scheme="http://codingnote.com/tags/Authentication/"/>
    
      <category term="Authorization" scheme="http://codingnote.com/tags/Authorization/"/>
    
  </entry>
  
  <entry>
    <title>Correction of Error (COE)</title>
    <link href="http://codingnote.com/2020/12/29/coe/"/>
    <id>http://codingnote.com/2020/12/29/coe/</id>
    <published>2020-12-29T17:13:43.000Z</published>
    <updated>2020-12-31T17:05:41.739Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img data-src="/2020/12/29/coe/coe_title.png" class title="COE"><a id="more"></a><p><strong>文章目录</strong></p><!-- toc --><ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a><ul><li><a href="#%E6%9C%AC%E6%96%87%E5%86%99%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%9B%A0">本文写作的原因</a></li><li><a href="#%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85">目标读者</a></li><li><a href="#%E8%AF%BB%E5%AE%8C%E6%9C%AC%E6%96%87%E4%BD%A0%E5%B0%86%E8%8E%B7%E5%BE%97%E4%BB%80%E4%B9%88">读完本文你将获得什么？</a></li></ul></li><li><a href="#%E6%AD%A3%E6%96%87">正文</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFcoe">什么是COE？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81coe">什么时候需要COE？</a></li><li><a href="#coe%E7%9A%84%E5%A5%BD%E5%A4%84">COE的好处</a><ul><li><a href="#%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90">举个例子</a></li></ul></li><li><a href="#%E8%B0%81%E6%9D%A5%E5%86%99coe">谁来写COE？</a></li></ul></li><li><a href="#%E6%9D%82%E8%B0%88">杂谈</a><ul><li><a href="#coe%E6%98%AF%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%A3%80%E8%AE%A8%E4%B9%A6%E5%90%97">COE是软件开发工程师的&quot;检讨书&quot;吗？</a></li><li><a href="#%E8%B5%B7%E8%8D%89coe%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%BC%9A%E6%84%9F%E5%88%B0%E5%86%85%E7%96%9A%E5%90%97">起草COE的软件开发工程师会感到内疚吗？</a></li></ul></li><li><a href="#%E9%99%84%E5%BD%95">附录</a><ul><li><a href="#coe%E6%A8%A1%E6%9D%BF">COE模板</a><ul><li><a href="#%E9%94%99%E8%AF%AF%E7%AE%80%E8%BF%B0">错误简述</a></li><li><a href="#%E9%94%99%E8%AF%AF%E5%BD%B1%E5%93%8D">错误影响</a></li><li><a href="#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90">根本原因分析</a></li><li><a href="#%E5%8F%8D%E7%9C%81%E7%BB%8F%E9%AA%8C">反省经验</a></li><li><a href="#%E7%BA%A0%E6%AD%A3%E6%8E%AA%E6%96%BD">纠正措施</a></li></ul></li><li><a href="#coe%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93">COE流程总结</a></li><li><a href="#%E5%AF%B9%E5%A4%96%E5%85%AC%E5%BC%80%E7%9A%84coe">对外公开的COE</a></li><li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE">参考文献</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li></ul></li></ul><!-- tocstop --><h1><span id="前言"> 前言</span></h1><h2><span id="本文写作的原因"> 本文写作的原因</span></h2><p>亚马逊作为一家科技公司，在软件工程上有许多值得借鉴学习的地方。其中COE作为质量管理的重要一环，十分独特。本文浅略介绍COE的实践方法，所有参考文献均来自互联网公开资料。</p><h2><span id="目标读者"> 目标读者</span></h2><p>COE属于软件工程领域中，质量管理流程中的错误管理。所以本文的目标读者是具有一定软件工程背景的软件开发工程师，软件工程管理人员，项目管理人员以及信息技术行业的从业者。</p><h2><span id="读完本文你将获得什么"> 读完本文你将获得什么？</span></h2><p>读完本文你将对COE流程有个大致的了解，理解为什么需要它，什么时候使用它，以及使用COE流程的好处。</p><h1><span id="正文"> 正文</span></h1><h2><span id="什么是coe"> 什么是COE？</span></h2><p>COE<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>是一种通过记录和处理问题来提升软件工程质量的流程<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。所谓记录问题就是通过标准化的文档来记录造成问题的根本原因，这一部分也叫根本原因分析<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>；所谓处理问题，就是通过标准化的流程来逐一消除造成问题的根本原因，顺藤摸瓜，釜底抽薪，从根本上解决问题。</p><p>需要指出的是，COE即是一种流程，也是一种文档的类型。在没有特指的情况下，需要根据上下文来判断其具体含义。</p><h2><span id="什么时候需要coe"> 什么时候需要COE？</span></h2><p>COE一般用来对错误进行书面分析，然后留档保存。对于公司业务影响较小的问题，根本原因分析起来一般来说比较简单，不需要书面分析。即便根本原因分析起来复杂，因为对业务影响小，分析也没什么价值。而对公司业务影响较大的问题，则需要书面分析。书面分析至少有以下两个好处：</p><ol><li>对公司业务影响较大的问题，通常造成问题的因果关系复杂，书面记录有助于当事人顺藤摸瓜，分析问题。</li><li>好记性不如烂笔头，书面记录不仅令当事人印象深刻，更重要的是，书面记录便于留档保存，可以供他人查阅和学习。</li></ol><details class="note info"><summary><p>如何定义业务影响的大小？</p></summary><p>业务影响的定义对于不同行业的公司，对于不同大小的公司都是不同的。比如对于一家提供视频网站的公司，如果有10%的用户无法观看视频的插片广告，那么这是一个对业务影响较大的问题。如果有1个用户无法观看视频的插片广告，那么这是一个对业务影响较小的问题。此时可以根据公司的体量，设计双重指标，如果有超过x%的用户，或者超过y个用户无法观看视频的插片广告，那么这就是一个对对业务影响较大的问题。</p></details><h2><span id="coe的好处"> COE的好处</span></h2><p>COE不仅对根本原因分析进行书面记录，同时以规范的格式进行书面记录。规范的格式也有至少有以下两个好处：</p><ol><li><p>便于阅读，和提取关键信息：想象一下，如果你的直属领导要求你从100篇错误分析文档中找出一共有多少文档是部门A发布的，一种情况是100篇文档格式不尽相同，发布部门信息散落各数，另一种情况是格式一致，发布部门信息都在前言里。必然是格式一致的文档能方便你提取你需要的关键信息。</p></li><li><p>便于自动化提取关键指标：文档规范化后，可以交由软件自动读取，分析出关键指标。比如从1000篇COE中发现123篇的根本原因都是X，那么管理层可以得知解决X的重要性，并且可以用这些指标来进行科学决策。</p></li></ol><h3><span id="举个例子"> 举个例子</span></h3><p>其实根本原因分析普遍存在于软件工程的生产实践中，根据问题的影响范围，软件工程师会采用合适的方法来分析问题，以在电商工作的张三为例</p><table><thead><tr><th>No</th><th>问题类型</th><th>问题造成的后果</th><th>问题的影响范围</th><th>问题对公司造成的损失</th><th>如何应对问题</th></tr></thead><tbody><tr><td>1</td><td>张三电脑系统出现问题，没法开机</td><td>张三工作进度收到影响</td><td>张三一个人</td><td>微小</td><td>当天找IT部门修复电脑</td></tr><tr><td>2</td><td>张三的公司内部聊天系统出现问题，员工没办法新增好友</td><td>使用该内部聊天软件的员工没法加新的好友</td><td>公司内部员工</td><td>有一定影响</td><td>在几天的时间内紧急修复问题，或者回滚造成错误的代码</td></tr><tr><td>3</td><td>张三的公司网站用户购物车出现问题，没法把商品放入购物车</td><td>用户没法购物</td><td>100%的用户</td><td>重大影响，生意没法做了</td><td>在几分钟的时间内紧急修复问题，或者回滚造成错误的代码</td></tr></tbody></table><p>对于第一个例子，问题的影响的范围小，解决问题的方法也直截了当。根本原因分析心算即可完成，此时没有必要进行书面的根本原因分析。</p><p>对于第二个例子，问题有一定的影响范围，而且不注意的话，错误有可能再次发生，为了避免类似的错误，应该进行书面的根本原因分析，记录问题的根本原因，并且在紧急修复问题后，应该提出避免类似错误的措施，并且和相关团队讨论，审核，施行该措施。</p><p>对于第三个例子，问题的影响范围重大，不但要进行书面的根本原因分析。错误分析还要印发给各个部门，组织全公司的各个团队从错误中学习经验。</p><p>对于第二个和第三个例子，COE可以标准化根本原因分析的流程，帮助张三快速，准确地分析出问题的根本原因。不仅如此，COE作为标准化的文档，可以帮助相关团队高效的审核，也可以帮助其他团队快速的提取出关键信息来学习。此外，由于文档使标准化的，张三的公司可以通过统计方法得到丰富的指标，比如有多少错误的根本原因是由于“证书过期”引起的，还有张三坐在部门一年的COE数量相比去年的变化，是多了还是少了。有了这些指标，项目经理和领导层可以根据数据来做出决策。</p><h2><span id="谁来写coe"> 谁来写COE？</span></h2><p>在软件系统错误发生时，一般由当事人起草COE。当事人可以是导致错误发生的软件开发工程师，可以是在代码审核过程中遗漏该错误的工程师，也可以是该软件系统的负责人。选择他们是因为他们对出错误的系统最为熟悉。在亚马逊的企业文化里，由某一个人导致的软件系统错误也会同样发生在其他任何人上，所以要改善流程而不是批评指责某个具体的人。</p><p>COE编写完后，相关团队会一起开诚布公的审核COE文档，不仅审核根本问题分析，而且要审核为了消除根本问题所制定的纠正措施<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>。有些纠正措施致力解决眼前的问题，比如紧急修复一个错误。有些纠正措施则目标长远，目的是改善相关流程。解决短期和长期的纠正措施所需要的时间不同，所以纠正措施的预计交付日期也不尽相同，审核也包括评估纠正措施的预计交付日期。比如预计的交付日期是否合理。</p><h1><span id="杂谈"> 杂谈</span></h1><h2><span id="coe是软件开发工程师的quot检讨书quot吗"> COE是软件开发工程师的&quot;检讨书&quot;吗？</span></h2><p>COE的终极目标是避免重蹈覆辙，而不是把错误归咎于某个人，因此对造成错误的软件开发工程师不会，也不应该有任何的责罚。COE不是软件开发工程师的&quot;检讨书&quot;，而是软件开发工程师对抗来自项目经理不合理要求的“武器”，同时也是保护软件工程师的“防弹衣”。</p><p>在COE审核结束后，COE里的纠正措施通常比实现软件的某个新功能有更高的优先级，如果此时有项目经理提出与COE相悖的优先级排期，比如得把COE的纠正措施搁置一旁去实现某个新功能。此时软件开发工程师可以援引COE的纠正措施来质疑不合理的要求。</p><p>如果领导介入，得把COE的纠正措施搁置一旁。那么领导就需要承担COE中错误再次发生的后果。</p><h2><span id="起草coe的软件开发工程师会感到内疚吗"> 起草COE的软件开发工程师会感到内疚吗？</span></h2><p>一般来说，起草COE的作者是对出错误的系统最为熟悉的工程师，并不一定是直接导致问题发生的工程师。就算是直接导致问题的工程师，他或许会对造成问题心存内疚，但是写COE却不会。不仅如此，写COE也是工程师的某种“荣誉”。软件系统不可能不出错，世界上最稳定的服务也无法达到100%的可用性<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>。但是一篇一篇的COE，是亚马逊工程师们学习的源泉，成年累月地从错误中汲取经验，使得亚马逊服务的稳定性能向99.9%的小数点后再增加一位。</p><h1><span id="附录"> 附录</span></h1><h2><span id="coe模板"> COE模板</span></h2><p>以下模板所有内容纯属杜撰，如有雷同，请勿对号入座。</p><h3><span id="错误简述"> 错误简述</span></h3><blockquote><p>简述错误，并配以时间线</p></blockquote><p>2007年1月1日，时间下午14:00，公司A电商网站预计举行抽奖活动B。当日下午13：00。负责为抽奖活动提供技术支持的团队C的某软件工程师（注意不要出现姓名）发现一个会妨碍抽奖活动的bug，在巨大的时间压力下，修复该bug的代码未经测试便直接上线。导致公司网站的购物车功能从14：00瘫痪，直到14：30，该问题才由运营技术团队D发现并紧急回滚包含错误的代码。</p><ul><li>2007-1-1 13:00:00 (CST) 团队C的某软件工程师发现了一个会妨碍抽奖活动的bug。</li><li>2007-1-1 13:15:00 (CST) 该软件工程师把码未经测试修复代码直接部署到生产环境中。</li><li>2007-1-1 14:00:00 (CST) 电商网站的购物车功能开始瘫痪，用户无法把商品放入购物车中。</li><li>2007-1-1 14:30:00 (CST) 运营技术团队D，通过每秒放入购物车物品件数指标的断崖式下跌发现购物车异常问题。</li><li>2007-1-1 14:45:00 (CST) 运营技术团队D通过紧急回滚包含错误的代码恢复了购物车功能，网站购物车功能自此正常工作。</li></ul><h3><span id="错误影响"> 错误影响</span></h3><blockquote><p>错误对于用户，业务造成的影响，最好列举相关的指标</p></blockquote><p>该错误导致抽奖活动B取消，此外，由于购物车功能收到影响，45分钟内，网站的所有用户均无法把商品放入购物车中。根据历史数据，此时用户数量为X，活动B预计增加Q%的客流量，购物车转化率为Y%，平均每单收入为W元人民币。这次事故对于公司A的收益影响是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X*(1+Q&#x2F;100)*Y*W 元</span><br></pre></td></tr></table></figure><h3><span id="根本原因分析"> 根本原因分析</span></h3><blockquote><p>刨根问底，顺藤摸瓜，造成错误的最根本原因是什么</p></blockquote><ol><li>为什么公司A购物车功能瘫痪了？<br>因为团队C的工程师把码未经测试修复代码直接部署到生产环境中</li><li>为什么团队C的工程师把码未经测试修复代码直接部署到生产环境中？<br>为了紧急修复会妨碍抽奖活动的bug</li><li>为什么修复妨碍抽奖活动的bug会影响网站A购物车功能？<br>因为抽奖活动代码和购物车功能代码过于耦合</li><li>为什么抽奖活动B代码和购物车功能代码过于耦合？<br>因为负责购物车功能的团队E没有提供相应的API，抽奖活动B的功能代码直接在购物车功能中实现了。</li><li>为什么要购物车功能中实现抽奖活动B的功能，为何不先重构购物车功能并且先实现API？<br>因为抽奖活动B过于紧急，需要在2007-1-1上线。</li></ol><h3><span id="反省经验"> 反省经验</span></h3><blockquote><p>吃一堑长一智，从错误中学习到的宝贵经验</p></blockquote><ol><li>要进行合理的项目排期，不能因小失大。技术团队要及时向上级反映情况，不能因为满足眼前的功能而放弃项目的长期规划。</li><li>各个技术团队负责的产品要通过API定义的合同进行沟通，不能瞎耦合代码。</li><li>紧急修复也要有相关流程，至少要通过同行代码评审和自动化测试。</li></ol><h3><span id="纠正措施"> 纠正措施</span></h3><blockquote><p>为了避免重蹈覆辙，都有那些短期或者长期的纠正措施</p></blockquote><ol><li>短期措施: 修复妨碍抽奖活动B的bug，对于抽奖活动重新排期。预计新的抽奖活动B时间：2007-1-7</li><li>短期措施: 出台紧急修复流程，紧急修复至少需要通过同行代码评审和自动化测试。</li><li>中期措施: 对购物车功能进行重构，向抽奖活动B的技术团队提供API，通过API解耦。预计完成时间：2007-2-1</li><li>长期措施: 团队B和团队E负责审核他们项目中的所有代码，通过API逐步解耦其他地方的不合理耦合。预计完成时间：2008-1-1</li></ol><h2><span id="coe流程总结"> COE流程总结</span></h2><img data-src="/2020/12/29/coe/coe_process.png" class title="COE流程总结"><h2><span id="对外公开的coe"> 对外公开的COE</span></h2><blockquote><p>对外公开的COE其格式有所变化，其侧重点在于错误分析，但是也可以看到具体的纠正措施</p></blockquote><ol><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9tZXNzYWdlLzExMjAxLw==">2020年11月25日，最近一次，发生于US-EAST-1地区的Amazon Kinesis Event事故总结<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9tZXNzYWdlLzQxOTI2Lw==">2017年2月28日，使Quora，Trello等网站停运数小时的著名的Amazon S3事故总结<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9tZXNzYWdlLzY4MDU4Ny8=">2012年12月24日，发生于圣诞节前夜，把Netflix也拉下水的Amazon ELB事故总结<i class="fa fa-external-link-alt"></i></span></li></ol><h2><span id="参考文献"> 参考文献</span></h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly93YS5hd3MuYW1hem9uLmNvbS93YXQuY29uY2VwdC5jb2UuZW4uaHRtbA==">AWS Well-Architected Framework &gt; Concepts&gt; Correction of Error<i class="fa fa-external-link-alt"></i></span></li></ol><h2><span id="脚注"> 脚注</span></h2><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>COE：Correction Of Error，也即纠正错误。 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>流程：软件工程流程的简称。流程，就是为了完成某一目标而进行的一系列，有序的步骤。就如同生活中，为了做菜这个目标，流程可以是就是先买菜，然后洗菜，最后炒菜。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>根本原因分析：Root Cause Analysis。顾名思义，沿着因果关系组成的链条，找到问题的根本原因。来源自管理学概念，详情参见<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUm9vdF9jYXVzZV9hbmFseXNpcw==">https://en.wikipedia.org/wiki/Root_cause_analysis<i class="fa fa-external-link-alt"></i></span> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>纠正措施： Corrective Action的直译。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>可用性：Availability。简单的说，可用性就是一个系统处在可工作状态的时间的比例。例如，服务A在一年时间里（8760小时）有8751小时可用。其可用性则为8751/8760 = 0.999，或以百分比表示99.9%。详情参见<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQXZhaWxhYmlsaXR5">https://en.wikipedia.org/wiki/Availability<i class="fa fa-external-link-alt"></i></span> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;img data-src=&quot;/2020/12/29/coe/coe_title.png&quot; class=&quot;&quot; title=&quot;COE&quot;&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="质量管理" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
      <category term="错误分析" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/%E9%94%99%E8%AF%AF%E5%88%86%E6%9E%90/"/>
    
    
      <category term="COE" scheme="http://codingnote.com/tags/COE/"/>
    
      <category term="亚马逊" scheme="http://codingnote.com/tags/%E4%BA%9A%E9%A9%AC%E9%80%8A/"/>
    
      <category term="软件工程" scheme="http://codingnote.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="流程管理" scheme="http://codingnote.com/tags/%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    
      <category term="质量管理" scheme="http://codingnote.com/tags/%E8%B4%A8%E9%87%8F%E7%AE%A1%E7%90%86/"/>
    
      <category term="RCA" scheme="http://codingnote.com/tags/RCA/"/>
    
  </entry>
  
  <entry>
    <title>《Java实践指南》读书笔记</title>
    <link href="http://codingnote.com/2020/03/15/java-for-the-real-word-notes/"/>
    <id>http://codingnote.com/2020/03/15/java-for-the-real-word-notes/</id>
    <published>2020-03-15T16:13:11.000Z</published>
    <updated>2020-12-31T15:14:27.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img data-src="/2020/03/15/java-for-the-real-word-notes/java_for_the_real_world_title.png" class title="COE"><a id="more"></a><p><strong>目录</strong></p><!-- toc --><ul><li><a href="#java%E8%99%9A%E6%8B%9F%E6%9C%BA">Java虚拟机</a></li><li><a href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB">拓展阅读</a></li><li><a href="#%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7">构建工具</a></li></ul><!-- tocstop --><h2><span id="java虚拟机"> Java虚拟机</span></h2><p>JVM(Java Virtual Machine) 既可以指Java虚拟机规范，也可以指具体的某个实现。当JVM指Java虚拟机规范时，我们要注意虚拟机规范的版本。比如是JVM 1.8 还是 JVM 1.9。Java有很好的向后兼容性，使用高版本的Java编译器也可以顺利编译针对低版本JVM开发的代码。也正是由于Java的向后兼容，很多过时的语言规范成了新的语言规范的包袱，很多过时的标准类库依然遗留在新版本的JDK中。</p><ul><li><p>过时的java.util.Date包</p><p>在很大程度上，java.time.*已经取代java.util.Date包。</p></li><li><p>类型擦除</p><p>泛型只在编译时存在，运行时泛型信息会被清除。Java的向后兼容性允许我们初始化类似<code>ArrayList</code>的原始类型（Raw type），但是通常不建议这么做。</p></li><li><p>const和goto两个关键字被保留</p><p>但并未实现。</p></li><li><p>基本类型的封装类</p></li></ul><p>比如int和java.lang.Integer，boolean和java.lang.Boolean，等等。</p><ul><li><p>过时的集合实现</p><p>例如Hashtable和Vector诞生于Java 2 plateform时代（Java 1.2）之前，所以Hashtable都没有实现Map接口，Vector也没有实现List接口。在Java 1.2发布时，这些老旧集合都被改进以适应新的集合接口规范。但是使用它们的场景也跟着改变了。如果不需要线程安全，建议使用HashMap和ArrayList，如果需要高并发，建议从ava.util.concurrent包中找到合适的实现。</p></li></ul><p>当JVM指某个实现时，可不要被它的名字欺骗（Java Virtual Machine）。它并不是指能够运行Java代码的虚拟机，而是指可以运行Java字节码（Java bytecode）的虚拟机。在Java编程语言设计之初，其设计者就考虑到了跨平台特性。所以Java语言不直接编译为在具体操作系统上运行的机器码，而是编译为Java字节码，从而与具体的操作系统解耦。Java字节码则可以在不同操作系统上被某个JVM实现解释运行。</p><p>由于Java语言相比于其他语言，比如C语言多了JVM这一层抽象。Java语言编译器的实现不需要依赖于特定操作系统。这就好比是<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvT1NJJUU2JUE4JUExJUU1JTlFJThC">OSI模型<i class="fa fa-external-link-alt"></i></span> 的7层网络协议一样，抽象能帮助我们专注于真正重要的事情。比如网站的开发者不需要考虑用户的家里的的网卡，路由是什么规格的。甚至在一定程度上都不要关系用户使用的是什么操作系统或是浏览器。</p><p>Java语言的这种设计，使其在早期就可以在各种操作系统上运行。这也是为什么Java语言在早期有<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvV3JpdGVfb25jZSxfcnVuX2FueXdoZXJl">“一次编写，到处运行”（Write once, run everywhere）<i class="fa fa-external-link-alt"></i></span>的口号。由于JVM的规范是免费且公开的，任何人也都可以根据JVM的规范来自己实现自己的语言。只要能编译成Java字节码，这种语言也能依赖JVM到处运行。实际上，这些语言还不少，比如可作为脚本语言的Groovy，整合面向对象和函数式编程的Scala，甚至IDE开发商Jetbrains也推出了Kotlin语言来推动IntelliJ IDEA的销售（当然由于Kotlin本身的优秀也使其获得了Google的大力支持）。</p><p>如果你平时在电脑上运行过Java应用程序（Java Application），那么你需要安装一个叫JRE的东西而不是JVM。JRE（Java Runtime Environment）是一个可以让电脑运行Java应用程序的软件。它的内部包括一个JVM的实现，一些标准的类别函数库（Bootstrap classes和Extension Classes）以及一些配置文件（Property Files）。</p><p>如果要开发Java应用程序，JRE是不够的。需要JDK（Java Development Kit），其中包括JRE和一些开发工具。最有名的JDK莫过于Oracle公司的Oracle JDK和开源的<span class="exturl" data-url="aHR0cHM6Ly9vcGVuamRrLmphdmEubmV0Lw==">Open JDK<i class="fa fa-external-link-alt"></i></span>。</p><p>Open JDK是Sun公司于2006年开始开发，2007年5月发布的。市面上的各种JVM实现几乎都是从Open JDK中的JVM演化而来，其中也包括Oracle JDK。因为Oracle公司在Open JDK发布后的两年，也就是2007年收购了Sun公司。所以现在Open JDK和Oracle JDK的开发实际上都是由Oracle公司主导的（当然，Open JDK作为开源项目，Red Hat，Azul Systems，IBM，Apple和SAP以及Java社区也都参与了开发）。</p><p>虽然JVM的实现很多，但是这些不同的JVM实现在功能上区别不大（几乎都是基于Open JDK的JVM实现）但是有些JVM可以对特定平台进行优化，以实现在特定平台上性能优化。此外，这些JVM实现的许可限制可能有所不同。比如Oracle 从Oracle JDK11开始，使用它的LTS（Long time support，长期支持版本）需要商业许可。这也是为什么一些企业为了避免高昂的Oracle税，自己开发实现JVM，比如Amazon的Java Corretto。</p><h2><span id="拓展阅读"> 拓展阅读</span></h2><ol start="2"><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmFlbGR1bmcuY29tL2p2bS12cy1qcmUtdnMtamRr">Difference Between JVM, JRE, and JDK, Baeldung<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIzNTgwNzEvZGlmZmVyZW5jZXMtYmV0d2Vlbi1vcmFjbGUtamRrLWFuZC1vcGVuamRr">Differences between Oracle JDK and Openjdk, Wikipedia<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3BlbkpESw==">OpenJDK, Wikipedia<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3VuX01pY3Jvc3lzdGVtcw==">Sun Microsystems, Wikipedia<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9KYXZhX3ZpcnR1YWxfbWFjaGluZXMjUHJvcHJpZXRhcnlfaW1wbGVtZW50YXRpb25z">List of Java virtual machines, Wikipedia<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9mci9jb3JyZXR0by8=">Amazon Corretto, AWS<i class="fa fa-external-link-alt"></i></span></li></ol><h2><span id="构建工具"> 构建工具</span></h2><p>理解构建工具需要理解什么是构建周期，一般认为软件的构建周期由以下部分组成</p><table><thead><tr><th style="text-align:left">#</th><th style="text-align:left">阶段</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">获取依赖</td><td style="text-align:left">现代软件开发一般都不会从零开始写代码，所以通常软件开发中都会由很多依赖，在软件开始编译前，取得所有依赖包</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">编译代码</td><td style="text-align:left">编译源代码，链接依赖，将计算机源代码编译成二进制码</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">测试</td><td style="text-align:left">运行自动化测试，通常是单元测试</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">打包</td><td style="text-align:left">将源代码按照可发布的格式打包（发布包），例如jar，war或者ear文件</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">安装</td><td style="text-align:left">安装本地仓库可用的发布包，可作为本地其他软件项目的依赖</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">部署文件</td><td style="text-align:left">将发布包上传到远端仓库（公司内部仓库或是Maven Central一样的公有仓库），可作为他人软件项目的依赖</td></tr></tbody></table><span class="github-emoji" alias="point_right" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8">&#x1f449;</span> 什么是仓库（repositories）<p>现实世界的仓库是用来存放商品的，软件开发领域里的仓库是存放代码的。代码被整齐的归置在一个个软件包（Package）里。使用仓库里的软件包，让我们专注于业务逻辑，避免重复造轮子。在软件开发领域有很多仓库，比如有针对不同软件开发语言的</p><ul><li>针对Java软件开发，我们有Maven Central公有软件仓库。我们可以通过Maven下载使用仓库里的软件包</li><li>针对Python软件开发，我们有<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy8=">PyPi（The Python Package Index）<i class="fa fa-external-link-alt"></i></span>公有软件仓库。通过<span class="exturl" data-url="aHR0cHM6Ly9weXBpLm9yZy9wcm9qZWN0L3BpcC8=">pip<i class="fa fa-external-link-alt"></i></span>下载使用仓库里的软件包</li></ul><p>也有针对不同操作系统的</p><ul><li>针对Ubuntu用户，我们有Canonical软件仓库（也叫软件源）。我们可以通过apt（ Advanced Packaging Tool ）下载使用仓库里的软件包</li><li>针对Mac用户，我们有homebrew/core软件仓库（第三方软件仓库叫Taps）。我们可以通过<span class="exturl" data-url="aHR0cHM6Ly9icmV3LnNoLw==">brew<i class="fa fa-external-link-alt"></i></span>下载使用仓库里的软件包</li></ul><p>构建工具横向对比</p><table><thead><tr><th style="text-align:left">构建工具</th><th style="text-align:left">构建文件</th><th style="text-align:left">插件</th><th style="text-align:left">依赖管理</th><th style="text-align:left">构建速度</th></tr></thead><tbody><tr><td style="text-align:left">Ant</td><td style="text-align:left">build.xml 强制标准不多，不依赖特定项目目录结构</td><td style="text-align:left">不支持</td><td style="text-align:left">不支持，需要第三方工具，比如Apache Ivy</td><td style="text-align:left">慢</td></tr><tr><td style="text-align:left">Maven</td><td style="text-align:left">pom.xml， 标准严格，依赖特定项目目录结构</td><td style="text-align:left">原生支持</td><td style="text-align:left">原生支持</td><td style="text-align:left">慢</td></tr><tr><td style="text-align:left">Gradle</td><td style="text-align:left">build.gradle， Gradle DSL基于Groovy编程语言，有无限可能</td><td style="text-align:left">原生支持</td><td style="text-align:left">依靠现有的Maven和Ivy依赖体系</td><td style="text-align:left">快</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;img data-src=&quot;/2020/03/15/java-for-the-real-word-notes/java_for_the_real_world_title.png&quot; class=&quot;&quot; title=&quot;COE&quot;&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://codingnote.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《Java实践指南》" scheme="http://codingnote.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AJava%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97%E3%80%8B/"/>
    
    
      <category term="Java" scheme="http://codingnote.com/tags/Java/"/>
    
      <category term="读书笔记" scheme="http://codingnote.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2020年 再看开闭原则</title>
    <link href="http://codingnote.com/2020/03/10/revisit-open-closed-principle/"/>
    <id>http://codingnote.com/2020/03/10/revisit-open-closed-principle/</id>
    <published>2020-03-10T21:59:13.000Z</published>
    <updated>2020-12-31T17:05:29.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><img data-src="/2020/03/10/revisit-open-closed-principle/revisit_open_close_principal.png" class title="revisit open close principal"><a id="more"></a><p><strong>文章目录</strong></p><!-- toc --><ul><li><a href="#%E5%8D%88%E9%A4%90%E6%97%B6%E7%9A%84%E4%BA%89%E5%90%B5">午餐时的争吵</a></li><li><a href="#%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99%E4%B8%8E%E6%83%AF%E4%BE%8B">经验法则与惯例</a></li><li><a href="#%E9%87%8D%E6%B8%A9%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99">重温开闭原则</a></li><li><a href="#%E6%8B%93%E5%B1%95%E9%98%85%E8%AF%BB">拓展阅读</a></li><li><a href="#%E8%84%9A%E6%B3%A8">脚注</a></li></ul><!-- tocstop --><h1><span id="午餐时的争吵"> 午餐时的争吵</span></h1><p>今天中午我偶然路过公司二楼的厨房，听到同事们边吃午饭边争论着什么。我好奇的前去观摩，他们原来是在代码评审上有了分歧。</p><p>第一个同事说这个代码虽然能满足现在的需求，但是却不易于向某个他描述的方向拓展，他言之凿凿，认为我们的软件不久就会有他描述的需求。相比于被动等待，不如主动出击，现在就考虑将来的需求，多花些时间设计这个模块，使其变得易于拓展以适应将来的需求。</p><p>而另一位同事则不为所动，觉得YAGNI<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。就算我们真的要满足第一个同事所描述的需求，但是根据他的判断那也是很长时间（至少一年）之后的事了。如果现在就把模块变得易于拓展，那么无疑会增加代码的抽象层次，本来一个类<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>就可以实现的功能，现在要使用好几个类。</p><p>第三位同事也加入了讨论。把软件设计的灵活以适应将来的变化是一件好事，但是这么做也是有代价的。灵活意味着这个模块需要更高的抽象层次，在新的需求到来前，这个模块都需要保持它本不需要的抽象层次。况且现在我们假设对于将来需求的预测是正确的，如果我们预测错了，那么现在的努力不就白费了吗？</p><p>第一位同事似乎没有被说服，另外两位同事也各执已见。午饭结束，大家各自回到工位上继续搬砖了。</p><p>虽然这次争论还没有结果，也还不知道谁对谁错。那么我们在实现某个模块时，究竟是只实现现有需求还是要考虑到将来的需求而将模块实现的灵活一点呢？</p><h1><span id="经验法则与惯例"> 经验法则与惯例</span></h1><p>如果我们从1970年的Smalltalk语言开始算起，面向对象程序设计至今已至少经存在了50年了（如果从1960年的Simula 67语言开始算起，那么时间会更长）。我们现在遇到的各种问题，前人几乎都遇到过了。这也是为什么面向对象程序设计会有总结出如此多的模式（Pattern），甚至是名言警句（Maxim）。</p><p>“们在实现某个模块时，究竟是只实现现有需求还是要考虑到将来的需求而将模块实现的灵活一点呢？”</p><p>对于这个问题，如果问一位极限编程<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>的专家，他会说：</p><blockquote><p>YAGNI，一个程序员不应该为软件增加不必要的功能。</p></blockquote><p>对于这个问题，如果问一位SOLID主义者<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，他会说：</p><blockquote><p>我们应该遵守开闭原则<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。</p></blockquote><p>对于这个问题，其实不久前Java大师Bruce Eckel恰巧在他的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJ1Y2VlY2tlbC5jb20vYmxvZy8yMDE5LTEyLTI0LXVuc3Bva2VuLWFzc3VtcHRpb25zLXVuZGVybHlpbmctb28tZGVzaWduLW1heGltcy8jZGlzcXVzX3RocmVhZA==">博客<i class="fa fa-external-link-alt"></i></span>中写道</p><blockquote><p>质疑抽象的合理性，在不使用教条的情况下如果不能解释抽象的合理性，就不要抽象<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p></blockquote><p>但是不论是YAGNI还是SOLID，这些经验法则都是有适用条件的。在不同情况下，教条地套用这些法则还不如对这些法则一无所知。在1988年Bertrand Meyer提出开闭法则32年后的今天，我们真的了解什么是开闭原则吗？</p><h1><span id="重温开闭原则"> 重温开闭原则</span></h1><blockquote><p>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。</p><footer><strong>Bertrand Meyer</strong><cite>Object-Oriented Software Construction. Prentice Hall. 1988</cite></footer></blockquote><p>开闭原则说了两件事</p><ul><li><p>软件中的对象对于扩展应该是开放的</p><p>对象的行为可以被拓展，也就是说新的需求来临时，我们可以改变对象的行为以满足新的需求</p></li><li><p>软件中的对象对于修改应该是封闭的</p><p>实现原有需求的的源代码不应该被修改</p></li></ul><p>难道这两句话不矛盾吗？如果我们不修改源代码怎么拓展对象原有的行为？难道有不写代码就满足需求的魔法吗？当然，不修改代码是不可能的。但是不修改原先的代码，而只在软件的某一处增加代码来拓展对象的行为确实有可能的。</p><blockquote><p>抽象是解决问题的关键</p><footer><strong>Robert C. Martin</strong><cite>The Open-Close Principal</cite></footer></blockquote><p>Robert C. Martin 拿了C++写了一个关于在GUI打印形状的例子。比如我们现在有在GUI上打印方块和圆的需求，熟悉过程式编程人会实现类似于下面的程序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosedPrincipal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        Point center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> side;</span><br><span class="line">        Point topLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawCircle</span><span class="params">(<span class="keyword">final</span> Circle circle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现略去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawSquare</span><span class="params">(<span class="keyword">final</span> Square square)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现略去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawAllShapes</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Object shape : shapes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">                DrawCircle((Circle) shape);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Square) &#123;</span><br><span class="line">                DrawSquare((Square) shape);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我拿了Java重写了Robert C. Martin 当年拿C++语言写的例子。所以上面有很多地方看起来都很奇怪，但是暴露的问题是一样的。假如不久之后我们有了新的需求，需要打印菱形，那么我们不可避免的需要修改<code>DrawAllShapes</code>方法。但是假如我们利用接口进行抽象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosedPrincipal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        Point center;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 实现略去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> side;</span><br><span class="line">        Point topLeft;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 实现略去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawAllShapes</span><span class="params">(<span class="keyword">final</span> List&lt;Shape&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里抽象出<code>Shape</code>接口并定义<code>draw()</code>方法，让不同的具体类去实现<code>draw()</code>方法。这样当打印新的形状的需求出现时我们就不需要修改 <code>DrawAllShapes</code>方法了。这样就符合了开闭原则</p><ul><li>若需要打印新的形状只需要实现新的类，新的类的实现与原先的各种实现是解耦的，并不需要修改原先的实现</li><li><code>drawAllShapes()</code> 没有改变</li></ul><p>但是就好像老鼠团大会，谁去给猫挂铃铛的故事一样。开闭法则听起来诱人，可是又有谁知道一个软件里哪个模块，类应该关闭，哪个模块，类应该开放呢？假如新的需求不是打印新的形状而是先打印圆形再打印方形呢？那么上面的例子就不再试用了。可能会有人说，那么我在实现 <code>drawAllShapes()</code>就考虑到打印顺序的需求，再去要求每个形状实现 <code>Comparable&lt;Shape&gt;</code>接口就好了。哈哈，，今天有打印顺序的需求，明天又你想象不到的需求呢？只可惜软件开发工程师并不是预言家，要是软件开放工程师能准确地预测客户的需求，那么现在软件工程领域也不会有那么多问题了。</p><p>这就是开闭原则的陷阱，它要求使用者对特定领域的知识有非比寻常的见解。但是没有个十年软件开放经验，又怎么能获得非比寻常的见解呢？</p><h1><span id="拓展阅读"> 拓展阅读</span></h1><ol><li><span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2JsaWtpL1lhZ25pLmh0bWw=">Yagni, Martin Fowler<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTUwOTA1MDgxMTA1L2h0dHA6Ly93d3cub2JqZWN0bWVudG9yLmNvbS9yZXNvdXJjZXMvYXJ0aWNsZXMvb2NwLnBkZg==">The Open-Closed Principle, Robert C. Martin<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJ1Y2VlY2tlbC5jb20vYmxvZy8yMDE5LTEyLTI0LXVuc3Bva2VuLWFzc3VtcHRpb25zLXVuZGVybHlpbmctb28tZGVzaWduLW1heGltcy8jZGlzcXVzX3RocmVhZA==">Unspoken Assumptions Underlying OO Design Maxims<i class="fa fa-external-link-alt"></i></span></li></ol><h1><span id="脚注"> 脚注</span></h1><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>YAGANI：You aren’t gonna need it的缩写，直译为你不会需要它。详情参见马丁·福勒的博客<span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2JsaWtpL1lhZ25pLmh0bWw=">https://martinfowler.com/bliki/Yagni.html<i class="fa fa-external-link-alt"></i></span> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>类：class，此处特指面向对象编程语言中的类。 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>极限编程：Extreme Programming，简称XP。它是一种软件工程方法学，是敏捷软件开发的一种方式。如同其他敏捷方法学，极限编程和传统方法学的本质不同在于它更强调可适应性而不是可预测性。详情参见<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXh0cmVtZV9wcm9ncmFtbWluZw==">https://en.wikipedia.org/wiki/Extreme_programming<i class="fa fa-external-link-alt"></i></span> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>SOLID主义者：那些把所谓软件工程中设计模式的六大原则奉为圭臬的人。 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>开闭原则：The Open-Closed Principle，软件工程中设计模式的六大原则之一。 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>质疑抽象的合理性，在不使用教条的情况下如果不能解释抽象的合理性，就不要抽象。原文是Question your abstractions. If you can’t justify it (without quoting a maxim), take it out. 详情参见<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJ1Y2VlY2tlbC5jb20vYmxvZy8yMDE5LTEyLTI0LXVuc3Bva2VuLWFzc3VtcHRpb25zLXVuZGVybHlpbmctb28tZGVzaWduLW1heGltcw==">https://www.bruceeckel.com/blog/2019-12-24-unspoken-assumptions-underlying-oo-design-maxims<i class="fa fa-external-link-alt"></i></span> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;img data-src=&quot;/2020/03/10/revisit-open-closed-principle/revisit_open_close_principal.png&quot; class=&quot;&quot; title=&quot;revisit open close principal&quot;&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="开闭原则" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计模式" scheme="http://codingnote.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="经验法则" scheme="http://codingnote.com/tags/%E7%BB%8F%E9%AA%8C%E6%B3%95%E5%88%99/"/>
    
      <category term="开闭原则" scheme="http://codingnote.com/tags/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java的协变，逆变与不变</title>
    <link href="http://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/"/>
    <id>http://codingnote.com/2020/03/08/java-covariant-contravariant-invariant/</id>
    <published>2020-03-08T11:35:01.000Z</published>
    <updated>2020-12-30T16:02:41.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%98%E7%9A%84%E5%AE%9A%E4%B9%89">协变，逆变与不变的定义</a></li><li><a href="#java%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8D%8F%E5%8F%98">Java上限通配符实现协变</a></li><li><a href="#java%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AE%9E%E7%8E%B0%E9%80%86%E5%8F%98">Java下限通配符实现逆变</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><!-- tocstop --><p>在Java里，如果我们创建了<code>Integer</code>类和<code>Number</code>类，并且<code>Integer</code>是<code>Number</code>的子类。那么<code>List&lt;Integer&gt;</code>类也是<code>List&lt;Number&gt;</code>类的子类吗？</p><p>我们可以写一段代码来找到这个问题的答案。现在我们有一个求<code>List&lt;Number&gt;</code>类最大值的方法，它的输入是<code>List&lt;Number&gt;</code>类的实例。若<code>List&lt;Integer&gt;</code>类也是<code>List&lt;Number&gt;</code>类的子类，那么下面的代码应该是合法的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvariantExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(List&lt;Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Number max = max(integerList); <span class="comment">// 编译错误 incompatible types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是编译器告诉我们<code>incompatible types</code>错误，这里<code>max</code>方法期待一个<code>List&lt;Number&gt;</code>类作为输入，但是实际上获得的是<code>List&lt;Integer&gt;</code>类。这就告诉我们，即便<code>Integer</code>是<code>Number</code>的子类，编译器也认为<code>List&lt;Integer&gt;</code>类和<code>List&lt;Number&gt;</code>类是没有关系的。</p><p><strong>结论</strong>：<em>对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>，不论它们之间具有什么关系，<code>List&lt;Type1&gt;</code> 和 <code>List&lt;Type2&gt;</code>都是没有关系的。</em></p><p>如果我们把上述结论推广，可以得到更一般性的结论</p><p><em>对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>，不论它们之间具有什么关系，给定泛型类 <code>G&lt;T&gt;</code>， <code>G&lt;Type1&gt;</code> 和 <code>G&lt;Type2&gt;</code>都是没有关系的。</em></p><p>上面的结论可以用一句话概括：</p><blockquote><p>Java的泛型是<strong>不可变的（Invariant）</strong></p></blockquote><h1><span id="协变逆变与不变的定义"> 协变，逆变与不变的定义</span></h1><p>在一门程序设计语言的类型系统中，给定</p><ul><li><code>&lt;=</code> 和<code>&gt;=</code>， 表示<strong>类型排序关系</strong><ul><li><code>Type1&lt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的子类型</li><li><code>Type1&gt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的超类型</li></ul></li><li><code>f()</code> 表示一个<strong>类型的构造函数</strong><ul><li>注意它可以是一元函数（接受一个参数），如<code>NewType = f(Type)</code></li><li>也可以是多元函数（接受多个参数），如<code>NewType = f(Type1, Type2)</code></li></ul></li></ul><p>那么，对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>, 这个类型的构造函数<code>f()</code>可以是</p><table><thead><tr><th style="text-align:left">变型（Variance）</th><th style="text-align:left">定义</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">协变的（covariant）</td><td style="text-align:left">当且仅当它保持了类型排序关系</td><td style="text-align:left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&lt;=f(Type2)</code></td></tr><tr><td style="text-align:left">逆变的（contravariant）</td><td style="text-align:left">当且仅当它逆转了类型排序关系</td><td style="text-align:left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&gt;=f(Type2)</code></td></tr><tr><td style="text-align:left">不变的（invariant or nonvariant）</td><td style="text-align:left">既不保持也不逆转类型排序关系</td><td style="text-align:left">不论<code>Type1</code> 和 <code>Type2</code>的关系，<code>f(Type1)</code> 和<code>f(Type2)</code> 没有关系</td></tr></tbody></table><p><em>以上定义来自 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ292YXJpYW5jZV9hbmRfY29udHJhdmFyaWFuY2VfKGNvbXB1dGVyX3NjaWVuY2Up">Covariance and contravariance, Wikipedia<i class="fa fa-external-link-alt"></i></span>，其中还有双变的（bivariant），但是不在本文的讨论范围，顾略去</em></p><p><em>在 C#中，子类型也称为派生类（Derived class），超类型也称为基类（Base class）</em></p><p>不同的程序设计语言，需要在类型推断的安全性和语法的易用性上做出权衡，对不同的类型构造函数进行规约，以使其符合某一种<strong>变型（Variance）</strong>。<br>不同的程序设计语言，在支持变型时，也有不同的处理方式。例如C#只允许在接口类型上标记变型,，而Java则在通过<a href="./2020/03/03/java-generics/#%E6%9C%89%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a>来支持变型。</p><h1><span id="java上限通配符实现协变"> Java上限通配符实现协变</span></h1><p>继续最初的例子，<code>Integer</code>是<code>Number</code>的子类，怎么样才能让<code>Number max(List&lt;Number&gt; list)max</code>方法也接受<code>List&lt;Integer&gt;</code>呢？（这里<code>List&lt;T&gt;</code>是类型构造函数，<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 两个新的类型）虽然在Java中，泛型是不可变的（<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code>没有关系），但是Java可以通过使用<a href="./2020/03/03/java-generics/#%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">上限通配符</a>来实现协变。</p><p>修改后的<code>max</code>方法签名如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(List&lt;? extends Number&gt; list)</span></span></span><br></pre></td></tr></table></figure><p><code>? extends Number</code> 表示接受<code>Number</code>类型和<code>Number</code>类型的子类型。这样<code>max</code>方法能够接受比原始指定的类型（这里是<code>Number</code>类型）更具体的类型。</p><h1><span id="java下限通配符实现逆变"> Java下限通配符实现逆变</span></h1><p>思考下面的例子，<code>Integer</code>是<code>Number</code>的子类，方法<code>generateIntegers</code>生成<code>List&lt;Integer&gt;</code> 并放入到输入参数<code>output</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContravariantExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; output)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 省略实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Number&gt; numberList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        generateIntegers(numberList); <span class="comment">// 编译错误 incompatible types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于Java泛型的不可变性，<code>generateIntegers()</code> 生成的<code>List&lt;Integer&gt;</code>不能放到输入参数<code>output</code>指定的<code>List&lt;Number&gt;</code>中。那么有没有办法把 <code>List&lt;Integer&gt;</code> 放到<code>List&lt;Number&gt;</code>中呢？</p><p>这里使用<a href="./2020/03/03/java-generics/#%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">下限通配符</a>来实现逆变。</p><p>修改后的<code>generateIntegers</code>函数签名如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; output)</span></span></span><br></pre></td></tr></table></figure><p><code>&lt;? super Integer</code> 表示接受<code>Integer</code>类型和<code>Integer</code>类型的超类型。这样<code>generateIntegers</code>方法就能接受比原始指定类型（这里是<code>Integer</code>类型）更泛化（更不具体）的类型。</p><h1><span id="总结"> 总结</span></h1><p>如果<code>Integer</code>类是<code>Number</code>类的子类型</p><table><thead><tr><th style="text-align:left">变型（Variance）</th><th style="text-align:left">通配符</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">协变的（covariant）</td><td style="text-align:left">上限通配符 <code>? extends T</code></td><td style="text-align:left"><code>List&lt;? extends Number&gt;</code> 接受比原始指定类型<code>Number</code>更具体的类型</td></tr><tr><td style="text-align:left">逆变的（contravariant）</td><td style="text-align:left">下限通配符 <code>? super T</code></td><td style="text-align:left"><code>List&lt;? super Integer&gt;</code> 接受比原始指定类型<code>Integer</code>更泛化的类型</td></tr><tr><td style="text-align:left">不变的（invariant or nonvariant）</td><td style="text-align:left">泛型默认不可变</td><td style="text-align:left"><code>List&lt;Integer&gt;</code> 和<code>List&lt;Number&gt;</code> 没关系</td></tr></tbody></table><ol><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ292YXJpYW5jZV9hbmRfY29udHJhdmFyaWFuY2VfKGNvbXB1dGVyX3NjaWVuY2Up">Covariance and contravariance, Wikipedia<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vZG90bmV0L3N0YW5kYXJkL2dlbmVyaWNzL2NvdmFyaWFuY2UtYW5kLWNvbnRyYXZhcmlhbmNl">泛型中的协变和逆变, Microsoft .NET指南<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9FZmZlY3RpdmUtSmF2YS1Kb3NodWEtQmxvY2gvZHAvMDEzNDY4NTk5Nw==">Effective Java 3rd Edition，Joshua Bloch<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98%E4%B8%8E%E4%B8%8D%E5%8F%98%E7%9A%84%E5%AE%9A%E4%B9%89&quot;&gt;协变，逆变与不变的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AE%9E%E7%8E%B0%E5%8D%8F%E5%8F%98&quot;&gt;Java上限通配符实现协变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#java%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6%E5%AE%9E%E7%8E%B0%E9%80%86%E5%8F%98&quot;&gt;Java下限通配符实现逆变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;在Java里，如果我们创建了&lt;code&gt;Integer&lt;/code&gt;类和&lt;code&gt;Number&lt;/code&gt;类，并且&lt;code&gt;Integer&lt;/code&gt;是&lt;code&gt;Number&lt;/code&gt;的子类。那么&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;类也是&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;类的子类吗？&lt;/p&gt;
&lt;p&gt;我们可以写一段代码来找到这个问题的答案。现在我们有一个求&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;类最大值的方法，它的输入是&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;类的实例。若&lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt;类也是&lt;code&gt;List&amp;lt;Number&amp;gt;&lt;/code&gt;类的子类，那么下面的代码应该是合法的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 泛型" scheme="http://codingnote.com/categories/Java-%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="Java" scheme="http://codingnote.com/categories/Java-%E6%B3%9B%E5%9E%8B/Java/"/>
    
    
      <category term="Java" scheme="http://codingnote.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型</title>
    <link href="http://codingnote.com/2020/03/03/java-generics/"/>
    <id>http://codingnote.com/2020/03/03/java-generics/</id>
    <published>2020-03-02T23:28:00.000Z</published>
    <updated>2020-03-15T10:32:38.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#java-%E6%B3%9B%E5%9E%8B">Java 泛型</a><ul><li><a href="#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B">我们为什么需要泛型</a></li></ul></li><li><a href="#%E6%9C%89%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">有限通配符</a><ul><li><a href="#%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">下限通配符</a></li><li><a href="#%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">上限通配符</a></li></ul></li><li><a href="#%E6%97%A0%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6">无限通配符</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- tocstop --><h1><span id="java-泛型"> Java 泛型</span></h1><h2><span id="我们为什么需要泛型"> 我们为什么需要泛型</span></h2><p>自从Java SE 1.5引入<strong>泛型（Generics）</strong> 之前，Java程序员想要写出通用的代码有点难度。比如想要得到Java某个集合（<code>Collection</code>）的最大值，在没有泛型的情况下，我们需要针对每个特定类型去写特定的求最大值方法。</p><p>比如针对<code>Number</code>集合我们需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(NumberCollection coll, NumberComparator comp)</span></span></span><br></pre></td></tr></table></figure><p>针对<code>Integer</code>集合我们需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">max</span><span class="params">(IntegerCollection coll, IntegerComparator comp)</span></span></span><br></pre></td></tr></table></figure><p>显而易见，这样实现起来是非常没有效率的。我们需要为每个不同的类型实现重复的逻辑，重复在编程中是非常罪恶的。当然，为了减少重复，我们也可以有这样的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">max</span><span class="params">(ObjectCollection coll, ObjectComparator comp)</span></span></span><br></pre></td></tr></table></figure><p>因为Java所有的类都是<code>Object</code>的子类。当然这样实现的坏处就是需要做<strong>对象转型(Casting)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer maxInterger = (Integer) max(coll, comp)</span><br></pre></td></tr></table></figure><p>然而对象转型也是非常罪恶的，因为一旦错误地使用了对象转型，代码只有到<strong>运行阶段（runtime）</strong> 才会报错。所以我们要尽可能的避免对象转型。</p><p>而有了泛型以后，我们只需要实现</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;T&gt; comp)</span></span></span><br></pre></td></tr></table></figure><p>其中<code>T</code>叫做<strong>类型参数（Type paramter）</strong>，如果一个<strong>类（Class）</strong>，一个<strong>接口（Interface）</strong> 或者一个<strong>方法（Method）</strong> 在<strong>定义时（declaration）<strong>有一个或者多个类型参数，那么我们就叫他们</strong>泛型类（Generic class）</strong>，<strong>泛型接口（Generic interface）</strong> 和<strong>泛型方法（Generic method）</strong>。而泛型类，泛型接口和泛型方法就被统称为<strong>泛型（Generic types， Generics）</strong>。</p><p>定义时，泛型是由类，接口和方法名跟着一个由尖括号包围的<strong>参数化类型（Parameterized types）</strong> 组成的。例如</p><ul><li><code>ArrayList&lt;E&gt;</code> ArrayList类有一个类型参数，E，它表示元素类型。读作元素E的ArrayList。</li><li><code>Map&lt;K, V&gt;</code> Map接口有两个类型参数，K，V，分别表示键和值的类型，读作K到V的映射。</li><li><code>T max(Collection&lt;T&gt; coll)</code> max方法有一个类型参数，T，表示对象类型，这个不太好读。</li></ul><p>使用时，我们用<strong>实际类型参数（Actual type paramter）</strong> 替换类型参数，比如<code>ArrayList&lt;String&gt;</code> 就代表一个元素为<code>String</code>的<code>ArrayList</code>。其中类型参数<code>E</code>被实际类型参数<code>String</code>替代了。</p><p><em>在英语里Generic有通用的含义，这也揭示了Java泛型的本质：<strong>让类，接口和方法变得更加通用</strong></em></p><h1><span id="有限通配符"> 有限通配符</span></h1><p><strong>有限通配符（Bounded Wildcards）</strong> 是Java<strong>泛型（Java Generics）</strong> 里的概念，这里的有限不是和无限对应的，而是有上限和下限的意思。所以有限通配符又分为<code>下限通配符</code>和<code>上限通配符</code>。在一些翻译中，Bounded Wildcards也被翻译为有界通配符，相应的，有界通配符又分为<code>下界通配符</code>和<code>上界通配符</code>。</p><h2><span id="下限通配符"> 下限通配符</span></h2><p>上面说到有了泛型以后，我们只需要实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;T&gt; comp)</span></span></span><br></pre></td></tr></table></figure><p>便可以对任意类型的数据求最大值，但是上面的<strong>方法签名（method signature）</strong> 也有一些限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Integer&gt; intergerColl = ...;</span><br><span class="line">Comparator&lt;Number&gt; numberComp = ...;</span><br><span class="line">Collections.max(intergerColl, numberComp); <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure><p>我们知道<code>Number</code>是<code>Integer</code>是的<strong>超类（Super type）</strong>，每一个<code>Intger</code>类也是<code>Number</code>类，所以<code>Number</code>类的比较器应该可以用于比较<code>Integer</code>类。</p><p>然而上面的代码会在<strong>编译阶段（Compile time）出错</strong>，这是因为类型参数<code>T</code>限制了我们只能使用<code>Integer</code>类的比较器。在这里，限制比较器的类型和集合类型完全一样是没有必要的。其实我们可以放宽限制，只要比较器类型是集合类型T的超类型就可以了。这样，我们可以让求最大值方法变得更通用。修改后的函数签名如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span></span><br></pre></td></tr></table></figure><p>这里<code>?</code>就是通配符（Wildcard），<code>? super T</code>就是<strong>下限通配符（Lower Bounded Wildcards）</strong>。它表示某个类<code>?</code>是<code>T</code>的超类。</p><p>这样我们在这里使用Number类的比较器来比较Integer集合了。</p><p>下限通配符<code>? super T</code>中，<code>T</code>是表示下限类型，它既可以是一个类型参数，也可以是一个实际类型参数。</p><ul><li><code>Comparator&lt;? super T&gt;</code> 类型参数</li><li><code>Comparator&lt;? super Integer&gt;</code> 实际类型参数</li></ul><p>至于为什么叫做下限，我们可以这么类比。族谱里爸爸在上面，儿子在下面。下限通配符以某个类型的子类型为下限，它匹配包括这个子类型的所有超类型。</p><h2><span id="上限通配符"> 上限通配符</span></h2><p>通过上限通配符，我们把求最大值方法变得通用了。试想限制我们想要实现一个Number集合累加，可以有如下的函数签名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">sum</span><span class="params">(Collection&lt;Number&gt; inputs)</span></span></span><br></pre></td></tr></table></figure><p>但是它只能用于累加Number，如果我们也想累加Number的子类Double，Integer呢，可以使用具有实际类型的上限通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">sum</span><span class="params">(Collection&lt;? extends Number&gt; inputs)</span></span></span><br></pre></td></tr></table></figure><p>这样我们就可以累加Double，Intger类型的集合了。</p><p>这里<code>? extends T</code>就是<strong>上限通配符（Upper Bounded Wildcards）</strong>。它表示某个类<code>?</code>是<code>T</code>的子类。</p><h1><span id="无限通配符"> 无限通配符</span></h1><p>无限通配符（Unbounded Wildcards）里的无限不是和有限对应的无限，而没有上下限的意思。有时，无限通配符（Unbounded Wildcards）也会被翻译为无界通配符。他们指代的都是同一个概念。</p><p>无限通配符记作<code>?</code>, 表示<strong>未知类型（unknown type）</strong>。 比如<code>List&lt;?&gt;</code>, 表示类型未知的List。</p><p>试想我们实现了如下在List中交换元素的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于使用了泛型，上面的方法可以应用于不同类型的List。但是我们也可以看到，在实现这个方法的过程中，我们没有使用基于类型参数E的任何信息。在这种情况下，我们可以用无限通配符代替类型参数E</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以总结出这样的经验法则，如何类型参数只在方法声明中出现，我们就可以用通配符来代替。</p><h1><span id="总结"> 总结</span></h1><p>Java通过让类，接口和方法在定义时有一个类型参数的形式让代码变得更加通用（泛化），这个就叫做泛型。由于Java泛型也有一些限制，这里没有阐明技术原因（技术原因请参考<a href="./2020/03/08/java-covariant-contravariant-invariant/">Java的协变，逆变与不变</a>），仅从几个把代码变得更通用得需求出发，引入通配符<code>?</code>的概念。</p><p>通配符在Java里三种形式，分别是</p><ul><li>下限通配符，<code>&lt;? super LowerBoundedClass&gt;</code>，通配<code>LowerBoundedClass</code>和它的超类。也可以用类型参数代替实际类型，<code>&lt;? super T&gt;</code></li><li>上限通配符， <code>&lt;? extends UpperBoundedClass&gt;</code> 统配<code>UpperBoundedClass</code>和它的子类。也可以用类型参数代替实际类型，<code>&lt;? extends T&gt;</code></li><li>无限通配符， <code>?</code> 通配任意类型</li></ul><p>关于通配符上下限的说法，来自于<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvZ2VuZXJpY3MvaW5kZXguaHRtbA==">ORACLE关于泛型的官方文档<i class="fa fa-external-link-alt"></i></span>，以及<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2V4dHJhL2dlbmVyaWNzL2luZGV4Lmh0bWw=">Gilad Bracha关于泛型的教程<i class="fa fa-external-link-alt"></i></span>。如果觉得难以理解，可以参考在<span class="exturl" data-url="aHR0cDovL3d3dy5PbkphdmE4LmNvbQ==">《On Java 8》<i class="fa fa-external-link-alt"></i></span>里，Bruce Eckel的<code>超类通配符</code>和<code>子类通配符</code>的说法。</p><ul><li>超类通配符，<code>&lt;? super LowerBoundedClass&gt;</code>，通配<code>LowerBoundedClass</code>和它的超类。也可以用类型参数代替实际类型，<code>&lt;? super T&gt;</code></li><li>子类通配符 <code>&lt;? extends UpperBoundedClass&gt;</code> 统配<code>UpperBoundedClass</code>和它的子类。也可以用类型参数代替实际类型，<code>&lt;? extends T&gt;</code></li></ul><h1><span id="参考"> 参考</span></h1><ol><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvZ2VuZXJpY3MvaW5kZXguaHRtbA==">Java泛型官方文档， ORACLE<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2V4dHJhL2dlbmVyaWNzL2luZGV4Lmh0bWw=">Java泛型教程， Gilad Bracha<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9FZmZlY3RpdmUtSmF2YS1Kb3NodWEtQmxvY2gvZHAvMDEzNDY4NTk5Nw==">Effective Java 3rd Edition，Joshua Bloch<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5PbkphdmE4LmNvbQ==">On Java 8，Bruce Eckel<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#java-%E6%B3%9B%E5%9E%8B&quot;&gt;Java 泛型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B3%9B%E5%9E%8B&quot;&gt;我们为什么需要泛型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%89%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6&quot;&gt;有限通配符&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8B%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6&quot;&gt;下限通配符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8A%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6&quot;&gt;上限通配符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%A0%E9%99%90%E9%80%9A%E9%85%8D%E7%AC%A6&quot;&gt;无限通配符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E8%80%83&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h1 id=&quot;java-泛型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#java-泛型&quot;&gt;&lt;/a&gt; Java 泛型&lt;/h1&gt;
&lt;h2 id=&quot;我们为什么需要泛型&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#我们为什么需要泛型&quot;&gt;&lt;/a&gt; 我们为什么需要泛型&lt;/h2&gt;
&lt;p&gt;自从Java SE 1.5引入&lt;strong&gt;泛型（Generics）&lt;/strong&gt; 之前，Java程序员想要写出通用的代码有点难度。比如想要得到Java某个集合（&lt;code&gt;Collection&lt;/code&gt;）的最大值，在没有泛型的情况下，我们需要针对每个特定类型去写特定的求最大值方法。&lt;/p&gt;
&lt;p&gt;比如针对&lt;code&gt;Number&lt;/code&gt;集合我们需要实现&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Number &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(NumberCollection coll, NumberComparator comp)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;针对&lt;code&gt;Integer&lt;/code&gt;集合我们需要实现&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Integer &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(IntegerCollection coll, IntegerComparator comp)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;显而易见，这样实现起来是非常没有效率的。我们需要为每个不同的类型实现重复的逻辑，重复在编程中是非常罪恶的。当然，为了减少重复，我们也可以有这样的实现&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ObjectCollection coll, ObjectComparator comp)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;因为Java所有的类都是&lt;code&gt;Object&lt;/code&gt;的子类。当然这样实现的坏处就是需要做&lt;strong&gt;对象转型(Casting)&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer maxInterger = (Integer) max(coll, comp)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而对象转型也是非常罪恶的，因为一旦错误地使用了对象转型，代码只有到&lt;strong&gt;运行阶段（runtime）&lt;/strong&gt; 才会报错。所以我们要尽可能的避免对象转型。&lt;/p&gt;
&lt;p&gt;而有了泛型以后，我们只需要实现&lt;/p&gt;
    
    </summary>
    
      <category term="Java 通配符" scheme="http://codingnote.com/categories/Java-%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    
      <category term="Java 泛型" scheme="http://codingnote.com/categories/Java-%E9%80%9A%E9%85%8D%E7%AC%A6/Java-%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="Java" scheme="http://codingnote.com/categories/Java-%E9%80%9A%E9%85%8D%E7%AC%A6/Java-%E6%B3%9B%E5%9E%8B/Java/"/>
    
    
      <category term="Java" scheme="http://codingnote.com/tags/Java/"/>
    
      <category term="Java 通配符" scheme="http://codingnote.com/tags/Java-%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    
      <category term="Java 泛型" scheme="http://codingnote.com/tags/Java-%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Design review 设计评审</title>
    <link href="http://codingnote.com/2020/02/23/design-review/"/>
    <id>http://codingnote.com/2020/02/23/design-review/</id>
    <published>2020-02-23T19:44:37.000Z</published>
    <updated>2020-12-30T21:36:13.559Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>文章目录</strong></p><!-- toc --><ul><li><a href="#%E8%83%8C%E6%99%AF">背景</a></li><li><a href="#%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3">设计文档</a></li><li><a href="#%E8%AF%84%E5%AE%A1">评审</a></li></ul><!-- tocstop --><h1><span id="背景"> 背景</span></h1><p>几年前在实习时，我完全没有接触过设计评审。当时的团队采用Scrum开发过程。开发团队采取一个架构师（Architect）和三到四个开发者（Developers）的配置。为了保证开发速度，冲刺订单（Spring backlog）里的大多数任务（Ticket）都有架构师写的详细开发步骤。架构师在团队里负责了大多数的软件设计任务，开发者则专注于将架构师的想法实现。</p><p>参加工作后，由于开发领域，开发过程，甚至是公司文化都与我实习过的公司有很多不同。在此期间，我也接触到了相当多的设计文档和设计评审。</p><p>2019年，我在开发团队里承担的设计任务也越来越多，写过的设计文档有二三十个。参加的设计评审则是更多。一年下来，我对设计评审，这个软件开发中的一个流程，有了自己的一些看法，下面则是我对设计评审的一个小总结。</p><a id="more"></a><h1><span id="设计文档"> 设计文档</span></h1><p>设计评审，需要首先有设计。这里说的设计就是设计文档（全称软件开发设计文档）。这是在软件开发之前，一种把软件设计思路结构化记录下来的资料。我第一次接触设计文档是在大学的软件工程课上。当时我也在课程项目中写过设计文档，但是却对为什么需要设计文档体会不深。毕竟当时的项目都很小，难度也不大。写设计文档无非是根据模板填充文字的游戏罢了。</p><p>但是当项目参与人员众多，开发难度大时，软件设计，作为软件开发的一个流程，被重视起来。我们在实践过程中，尤其是在一些重要的工作上 （比如时间跨度长，需要几个Sprint周期才能完成的工作，或者涉及多个团队，需要跨团队分工协作时），需要先把思路写下来，通过设计评审分享出来，得到相关人员的批准或者承诺后，再进行实现。</p><p>也许短期看，写设计文档，走完设计评审流程比直接蒙头实现软件要慢的多。但是一个好的设计可以在长期为产品的开发节省大量的时间。试想一下在有其他团队对你的软件库（Library）或者Web Service产生依赖时你才发现你的代码需要重新设计的情况，这时不仅是自己负责的项目会受到影响，使用你的代码的其他团队的项目也都会受到影响。</p><p>设计评审是软件开发的一个重要环节，写好设计文档则是让设计评审成功的第一步。在我看来，一个好的设计文档应至少包括如下几项：</p><ul><li>Problem statement。陈述待解决的问题，以及为什么要解决这个问题，或者说，不解决这个问题的后果是什么。</li><li>Recommended proposal。详细阐明推荐的解决方案，以及Pros/Cons的比较。</li><li>Alternatives。其他可行的解决方案，一般来说解决方案不止一种，也需要有Pros/Cons 对比。能让评审人知道trade-off是什么。</li></ul><p>更加详细的设计文档除了上面几项外还会有：</p><ul><li>Background。交代问题的背景，比如总项目的进程，该问题所属项目与总项目之间的关系。</li><li>Term。术语表。通常在抽象度高的讨论中，会用到很多术语以及缩略语。它们应该在术语表里进行定义，以避免歧义。</li><li>Plan。项目的计划。实现过程复杂时，需要分解实现过程，定义每个阶段的需要交付的模块。或者是每个阶段性成果Milestone是什么。</li></ul><h1><span id="评审"> 评审</span></h1><p>一个成功的设计评审需要以下要素。</p><ul><li>精简的评审团。只让必要的人参与进来。比如项目负责人，项目的主要贡献者或者受到最大影响的人。他们对设计思路的方向最有发言权，能提出有建设性的意见，而且能最后拍板。邀请不必要的人，会增加讨论中的噪音，以致评审流程变慢。</li><li>提前制定好的议案。有效率的讨论需要高质量的议案。设计评审的发起人需要准备好评审大会的议案流程，先讨论重要的点，比如一旦敲定就可以让部分项目先开展实现的点。这样接下来的点可以在不阻塞项目进展的情况下讨论。</li><li>Meeting Minutes。及时分享会议记录，其中包括参与的人，何时做出了什么决定或者得到了什么共识。当评审大会需要分几次召开时，会议记录作为之前会议的备忘能让我们避免重复讨论。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;文章目录&lt;/strong&gt;&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3&quot;&gt;设计文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%AF%84%E5%AE%A1&quot;&gt;评审&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#背景&quot;&gt;&lt;/a&gt; 背景&lt;/h1&gt;
&lt;p&gt;几年前在实习时，我完全没有接触过设计评审。当时的团队采用Scrum开发过程。开发团队采取一个架构师（Architect）和三到四个开发者（Developers）的配置。为了保证开发速度，冲刺订单（Spring backlog）里的大多数任务（Ticket）都有架构师写的详细开发步骤。架构师在团队里负责了大多数的软件设计任务，开发者则专注于将架构师的想法实现。&lt;/p&gt;
&lt;p&gt;参加工作后，由于开发领域，开发过程，甚至是公司文化都与我实习过的公司有很多不同。在此期间，我也接触到了相当多的设计文档和设计评审。&lt;/p&gt;
&lt;p&gt;2019年，我在开发团队里承担的设计任务也越来越多，写过的设计文档有二三十个。参加的设计评审则是更多。一年下来，我对设计评审，这个软件开发中的一个流程，有了自己的一些看法，下面则是我对设计评审的一个小总结。&lt;/p&gt;
    
    </summary>
    
      <category term="软件开发实践" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="设计评审" scheme="http://codingnote.com/categories/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1/"/>
    
    
      <category term="软件设计" scheme="http://codingnote.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="文档" scheme="http://codingnote.com/tags/%E6%96%87%E6%A1%A3/"/>
    
      <category term="设计评审" scheme="http://codingnote.com/tags/%E8%AE%BE%E8%AE%A1%E8%AF%84%E5%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git request-pull　和 Github pull request</title>
    <link href="http://codingnote.com/2018/01/04/git-request-pull/"/>
    <id>http://codingnote.com/2018/01/04/git-request-pull/</id>
    <published>2018-01-04T14:26:05.000Z</published>
    <updated>2020-03-15T10:36:37.750Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D">简短的介绍</a></li><li><a href="#git-request-pull">Git request-pull</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84">使用目的</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">使用方法</a></li><li><a href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">一个例子</a></li></ul></li><li><a href="#github-pull-request">Github Pull Request</a><ul><li><a href="#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84-1">使用目的</a></li><li><a href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1">使用方法</a><ul><li><a href="#%E4%BD%BF%E7%94%A8github-web%E7%95%8C%E9%9D%A2">使用Github web界面</a></li><li><a href="#%E4%BD%BF%E7%94%A8command-line">使用Command line</a></li></ul></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><!-- tocstop --><h2><span id="简短的介绍"> 简短的介绍</span></h2><p><code>request-pull</code> 和 <code>Pull Request</code>的名称如此相似，但是他们的功能是完全不同的。</p><p><code>request-pull</code>是git的命令，它用于生成发送到邮件列表的待处理的更改的摘要。默认情况下，GitHub没有集成这个功能。</p><p><code>Pull Request</code>是GitHub特有的一项功能(简称PR)。它用于向Github托管的某一项目中的某一分支提出合并请求。项目管理者则可以在github的web界面上合并来自不同分支的代码，解决合并冲突，做代码审查或对代码进行评论。</p><h2><span id="git-request-pull"> Git request-pull</span></h2><h3><span id="使用目的"> 使用目的</span></h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXF1ZXN0LXB1bGw=">Generates a summary of pending changes<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>生成待处理的更改的摘要</p><a id="more"></a><h3><span id="使用方法"> 使用方法</span></h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git request-pull [-p] &lt;start&gt; &lt;url&gt; [&lt;end&gt;]</span><br></pre></td></tr></table></figure><h3><span id="一个例子"> 一个例子</span></h3><p>新增修改是基于从远端<code>pull</code>下来的<code>master</code>分支上的，为此建立了一个分支叫<code>add-android-cours</code>, 首先把自己的分支<code>push</code>到自己的仓库里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push https:&#x2F;&#x2F;github.com&#x2F;JinhaiZ&#x2F;TB-F2B-205.git</span><br></pre></td></tr></table></figure><p>运行<code>git request-pull</code>命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git request-pull master https://github.com/JinhaiZ/TB-F2B-205.git add-android-cours</span><br></pre></td></tr></table></figure><p>它会根据远端master分支和刚刚push到仓库里的<code>add-android-cours</code>分支的不同做一个摘要。你可以选择把这份摘要email给远端仓库的管理者，这样，管理者可以从这份摘要中快速看出你想对master分支做出什么更改</p><p>生成摘要如下所示</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">The following changes since commit 5a992617e38665e73ca5ec5e5c10b78373c88938:</span><br><span class="line"></span><br><span class="line">  deleted TD andorid (2017-12-10 22:31:55 +0100)</span><br><span class="line"></span><br><span class="line">are available <span class="keyword">in</span> the git repository at:</span><br><span class="line"></span><br><span class="line">  https://github.com/JinhaiZ/TB-F2B-205.git add-android-cours</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> you to fetch changes up to 658e472da4b7f08378a5452b72c244039c621dac:</span><br><span class="line"></span><br><span class="line">  add andorid cours (2018-01-04 11:36:15 +0100)</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">JinhaiZ (1):</span><br><span class="line">      add andorid cours</span><br><span class="line"></span><br><span class="line"> android/cours.md | 13 +++++++++++++</span><br><span class="line"> 1 file changed, 13 insertions(+)</span><br><span class="line"> create mode 100644 android/cours.md</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2><span id="github-pull-request"> Github Pull Request</span></h2><h3><span id="使用目的"> 使用目的</span></h3><blockquote><p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvcHVsbF9yZXF1ZXN0Lmh0bWw=">“Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。”<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3><span id="使用方法"> 使用方法</span></h3><h4><span id="使用github-web界面"> 使用Github web界面</span></h4><p>以下借用阮一峰老师的讲解</p><ol><li>第一步，你需要把别人在Github上的项目，fork到你自己的仓库</li><li>第二步，在你仓库的修改后的分支上，按下&quot;New pull request&quot;按钮。<br>这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。</li><li>第三步，填写说明，帮助别人理解你的提交，然后按下&quot;create pull request&quot;按钮即可。PR 创建后，管理者就要决定是否接受该 PR。</li></ol><h4><span id="使用command-line"> 使用Command line</span></h4><p>首先安装<span class="exturl" data-url="aHR0cHM6Ly9odWIuZ2l0aHViLmNvbS8=">Hub<i class="fa fa-external-link-alt"></i></span>，以下步骤参考<span class="exturl" data-url="aHR0cHM6Ly9odWIuZ2l0aHViLmNvbS8=">Hub官方指南<i class="fa fa-external-link-alt"></i></span></p><ol><li><p>第一步，把别人在Github上的项目克隆到本地</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hub <span class="built_in">clone</span> https://github.com/SOME_ONE/xxx.git` </span><br></pre></td></tr></table></figure></li><li><p>第二步，创建分支，并在分支上进行修改</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b my-feature-branch</span><br><span class="line">git commit -m <span class="string">&quot;add new feature X&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>第三步，把本地项目fork到Github上</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hub fork</span><br><span class="line">→ (forking repo on GitHub...)</span><br><span class="line">→ git remote add YOUR_USER git://github.com/YOUR_USER/xxx.git</span><br></pre></td></tr></table></figure></li><li><p>第四步，把分支<code>push</code>到新远端(自己fork的远端)</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push YOUR_USER feature</span><br></pre></td></tr></table></figure></li><li><p>第五步，为自己的分支创建一个PR</p> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git pull-request</span><br><span class="line">→ (opens a text editor <span class="keyword">for</span> your pull request message)</span><br></pre></td></tr></table></figure></li></ol><h2><span id="参考"> 参考</span></h2><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXF1ZXN0LXB1bGw=">git docs: git-request-pull<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvcHVsbF9yZXF1ZXN0Lmh0bWw=">Pull Request 的命令行管理<i class="fa fa-external-link-alt"></i></span></li><li><a href="https://stackoverflow.com/questions/34945947/git-request-pull-how-to-create-a-github-pull-request-on-the-command-line">git request-pull: how to create a (github) pull request on the command line?<br></a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E7%9F%AD%E7%9A%84%E4%BB%8B%E7%BB%8D&quot;&gt;简短的介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#git-request-pull&quot;&gt;Git request-pull&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84&quot;&gt;使用目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95&quot;&gt;使用方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90&quot;&gt;一个例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#github-pull-request&quot;&gt;Github Pull Request&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E7%9B%AE%E7%9A%84-1&quot;&gt;使用目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-1&quot;&gt;使用方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8github-web%E7%95%8C%E9%9D%A2&quot;&gt;使用Github web界面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BD%BF%E7%94%A8command-line&quot;&gt;使用Command line&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%82%E8%80%83&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h2 id=&quot;简短的介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#简短的介绍&quot;&gt;&lt;/a&gt; 简短的介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;request-pull&lt;/code&gt; 和 &lt;code&gt;Pull Request&lt;/code&gt;的名称如此相似，但是他们的功能是完全不同的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;request-pull&lt;/code&gt;是git的命令，它用于生成发送到邮件列表的待处理的更改的摘要。默认情况下，GitHub没有集成这个功能。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pull Request&lt;/code&gt;是GitHub特有的一项功能(简称PR)。它用于向Github托管的某一项目中的某一分支提出合并请求。项目管理者则可以在github的web界面上合并来自不同分支的代码，解决合并冲突，做代码审查或对代码进行评论。&lt;/p&gt;
&lt;h2 id=&quot;git-request-pull&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git-request-pull&quot;&gt;&lt;/a&gt; Git request-pull&lt;/h2&gt;
&lt;h3 id=&quot;使用目的&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#使用目的&quot;&gt;&lt;/a&gt; 使用目的&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXF1ZXN0LXB1bGw=&quot;&gt;Generates a summary of pending changes&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;生成待处理的更改的摘要&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://codingnote.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://codingnote.com/tags/Git/"/>
    
      <category term="Github" scheme="http://codingnote.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>每个程序员都应该知道的延迟时间表</title>
    <link href="http://codingnote.com/2017/10/30/Latency-Numbers-Every-Programmer-Should-Know/"/>
    <id>http://codingnote.com/2017/10/30/Latency-Numbers-Every-Programmer-Should-Know/</id>
    <published>2017-10-30T21:01:05.000Z</published>
    <updated>2020-03-15T10:37:04.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><!-- tocstop --><p>翻译自:<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamJvbmVyLzI4NDE4MzI=">Latency Numbers Every Programmer Should Know<i class="fa fa-external-link-alt"></i></span></p><hr><table><thead><tr><th>操作</th><th>延迟(纳秒)</th><th>延迟(微秒)</th><th>延迟(毫秒)</th><th>参考</th></tr></thead><tbody><tr><td>CPU L1 级缓存访问</td><td>0.5   ns</td><td></td><td></td><td></td></tr><tr><td>分支预测错误*</td><td>5   ns</td><td></td><td></td><td></td></tr><tr><td>CPU L2 级缓存访问</td><td>7   ns</td><td></td><td></td><td>14x L1 cache</td></tr><tr><td>互斥体Mutex 加锁/解锁</td><td>25   ns</td><td></td><td></td><td></td></tr><tr><td>内存访问</td><td>100   ns</td><td></td><td></td><td>20x L2 cache, 200x L1 cache</td></tr><tr><td>用Zippy压缩1K字节</td><td>3,000   ns</td><td>3 us</td><td></td><td></td></tr><tr><td>在1 Gbps速率的网络上发送1K字节 over</td><td>10,000   ns</td><td>10 us</td><td></td><td></td></tr><tr><td>从SSD读取4K长度的随机数据</td><td>150,000   ns</td><td>150 us</td><td></td><td>~1GB/sec SSD</td></tr><tr><td>从内存读取连续的1 MB长度数据</td><td>250,000   ns</td><td>250 us</td><td></td><td></td></tr><tr><td>在同一数据中心内的来回通讯延迟*</td><td>500,000   ns</td><td>500 us</td><td></td><td></td></tr><tr><td>从SSD读取连续的1 MB长度数据</td><td>1,000,000   ns</td><td>1,000 us</td><td>1 ms</td><td>~1GB/sec SSD, 4X memory</td></tr><tr><td>磁盘寻址</td><td>10,000,000   ns</td><td>10,000 us</td><td>10 ms</td><td>20x datacenter roundtrip</td></tr><tr><td>从磁盘读取连续的1 MB长度数据</td><td>20,000,000   ns</td><td>20,000 us</td><td>20 ms</td><td>80x memory, 20X SSD</td></tr><tr><td>发送数据包 California-&gt;Netherlands-&gt;California</td><td>150,000,000   ns</td><td>150,000 us</td><td>150 ms</td><td></td></tr></tbody></table><a id="more"></a><blockquote><p>分支预测错误(Branch misprediction): 在包含了分支指令（if-then-else)的程序的执行过程中，其执行流程根据判定条件的真/假的不同，有可能会产生跳转，而这会打断流水线中指令的处理，因为CPU无法确定该指令的下一条指令，直到分支指令执行完毕。流水线越长，CPU等待的时间便越长，因为它必须等待分支指令处理完毕，才能确定下一条进入流水线的指令。为了解决这一问题，分支预测器（Branch predictor）在分支指令执行结束之前猜测哪一路分支将会被运行，以提高处理器的指令流水线的性能在分支执行完毕前先进行分支预测，分支预测器有很多种实现。其中最简单的是静态分支预测，方法是任选一条分支进入流水线，但是有50%的概率会预测错误，这时候就会出现分支预测错误</p></blockquote><blockquote><p>来回通讯延迟（Round-trip delay time），在通讯（Communication）、电脑网络（Computer network）领域中，意指：在双方通讯中，发讯方的讯号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传讯息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将讯号传播到收讯方的时间一样久）</p></blockquote><p>最后附上一张形象的图片<br><img data-src="http://i.imgur.com/k0t1e.png" alt="Latency Numbers Every Programmer Should Know "><br>Credit: <span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vazB0MWU=">https://imgur.com/k0t1e<i class="fa fa-external-link-alt"></i></span></p><p>参考：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamJvbmVyLzI4NDE4MzI=">Latency Numbers Every Programmer Should Know<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuL0NQVSVFNyVCQyU5MyVFNSVBRCU5OA==">CPU缓存<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSU4OCU4NiVFNiU5NCVBRiVFOSVBMCU5MCVFNiVCOCVBQyVFNSU5OSVBOA==">分支预测器<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJhbmNoX21pc3ByZWRpY3Rpb24=">Branch misprediction<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNCVCRSU4NiVFNSU5QiU5RSVFOSU4MCU5QSVFOCVBOCU4QSVFNSVCQiVCNiVFOSU4MSVCMg==">来回通讯延迟<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;翻译自:&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamJvbmVyLzI4NDE4MzI=&quot;&gt;Latency Numbers Every Programmer Should Know&lt;i class=&quot;fa fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;延迟(纳秒)&lt;/th&gt;
&lt;th&gt;延迟(微秒)&lt;/th&gt;
&lt;th&gt;延迟(毫秒)&lt;/th&gt;
&lt;th&gt;参考&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CPU L1 级缓存访问&lt;/td&gt;
&lt;td&gt;0.5   ns&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;分支预测错误*&lt;/td&gt;
&lt;td&gt;5   ns&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU L2 级缓存访问&lt;/td&gt;
&lt;td&gt;7   ns&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;14x L1 cache&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;互斥体Mutex 加锁/解锁&lt;/td&gt;
&lt;td&gt;25   ns&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;内存访问&lt;/td&gt;
&lt;td&gt;100   ns&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;20x L2 cache, 200x L1 cache&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;用Zippy压缩1K字节&lt;/td&gt;
&lt;td&gt;3,000   ns&lt;/td&gt;
&lt;td&gt;3 us&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在1 Gbps速率的网络上发送1K字节 over&lt;/td&gt;
&lt;td&gt;10,000   ns&lt;/td&gt;
&lt;td&gt;10 us&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从SSD读取4K长度的随机数据&lt;/td&gt;
&lt;td&gt;150,000   ns&lt;/td&gt;
&lt;td&gt;150 us&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;~1GB/sec SSD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从内存读取连续的1 MB长度数据&lt;/td&gt;
&lt;td&gt;250,000   ns&lt;/td&gt;
&lt;td&gt;250 us&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;在同一数据中心内的来回通讯延迟*&lt;/td&gt;
&lt;td&gt;500,000   ns&lt;/td&gt;
&lt;td&gt;500 us&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从SSD读取连续的1 MB长度数据&lt;/td&gt;
&lt;td&gt;1,000,000   ns&lt;/td&gt;
&lt;td&gt;1,000 us&lt;/td&gt;
&lt;td&gt;1 ms&lt;/td&gt;
&lt;td&gt;~1GB/sec SSD, 4X memory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;磁盘寻址&lt;/td&gt;
&lt;td&gt;10,000,000   ns&lt;/td&gt;
&lt;td&gt;10,000 us&lt;/td&gt;
&lt;td&gt;10 ms&lt;/td&gt;
&lt;td&gt;20x datacenter roundtrip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;从磁盘读取连续的1 MB长度数据&lt;/td&gt;
&lt;td&gt;20,000,000   ns&lt;/td&gt;
&lt;td&gt;20,000 us&lt;/td&gt;
&lt;td&gt;20 ms&lt;/td&gt;
&lt;td&gt;80x memory, 20X SSD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;发送数据包 California-&amp;gt;Netherlands-&amp;gt;California&lt;/td&gt;
&lt;td&gt;150,000,000   ns&lt;/td&gt;
&lt;td&gt;150,000 us&lt;/td&gt;
&lt;td&gt;150 ms&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初试树莓派RaspberryPi</title>
    <link href="http://codingnote.com/2017/10/25/first-glance-at-RaspberryPi/"/>
    <id>http://codingnote.com/2017/10/25/first-glance-at-RaspberryPi/</id>
    <published>2017-10-24T23:05:00.000Z</published>
    <updated>2020-03-15T10:35:29.146Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1">第一印象</a></li><li><a href="#%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5">远程连接</a><ul><li><a href="#%E9%80%9A%E8%BF%87ssh">通过ssh</a></li><li><a href="#%E9%80%9A%E8%BF%87vnc-viewer">通过VNC Viewer</a></li></ul></li><li><a href="#%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E7%BC%BA%E7%82%B9">树莓派的缺点</a></li><li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul><!-- tocstop --><h2><span id="第一印象"> 第一印象</span></h2><p>大约在20天前，我在亚马逊上冲动的购买了这个东西</p><img data-src="/2017/10/25/first-glance-at-RaspberryPi/Raspberry-Pi-3-Official-Desktop-Starter-Kit.png" class title="Raspberry Pi 3 Official Desktop Starter Kit"><p>树莓派3的官方Desktop Starter Kit，其实也就是树莓派3开发板+16GB miroSD装机卡+壳子+充电器套装。不过这样一套买下来，上手把玩树莓派要方便许多，机子到手第一天我就按照说明书安装了树莓派定制Debian的发型版Raspbian系统。第一感觉还挺好用，通过HDMI连接上显示器，再用4个USB接口中的两个连接键盘和鼠标就可以当做桌面电脑使用了。如果要通过个人电脑远程连接树莓派的话，ssh和VNC Viewer都很好用。</p><h2><span id="远程连接"> 远程连接</span></h2><h3><span id="通过ssh"> 通过ssh</span></h3><p><em>注意，以下步骤均在个人电脑上完成，不是在树莓派上</em></p><a id="more"></a><p>首先通过Vim 修改本地hosts文件<code>vim /etc/hosts</code> 加入raspberrypi的ip地址，以后就可以通过<code>ssh pi@raspberrypi</code>的方式ssh到树莓派中，如果嫌每次连接都要输入密码麻烦，可以把公钥导入到树莓派中，具体方法如下</p><ol><li>生成公钥私钥对</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><ol start="2"><li>将公钥传输到raspberrypi上</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id pi@raspberrypi</span><br></pre></td></tr></table></figure><ol start="3"><li>测试一下，现在用<code>ssh pi@raspberrypi</code>远程登录树莓派就不需要输入密码了</li><li>(可选步骤)为了安全性考虑，关闭树莓派上远程ssh密码登录</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br></pre></td></tr></table></figure><p>找到<code>PermitRootLogin</code>这一行，并将它改成<code>PermitRootLogin without-password</code>，如果这一行是被注释的，记得取消注释以此覆盖默认配置。修改并保存，最后运行下面命令使修改生效</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure><h3><span id="通过vnc-viewer"> 通过VNC Viewer</span></h3><ol><li>首先，在树莓派上通过下列命令开启VNC Viewer</li></ol>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install realvnc-vnc-server realvnc-vnc-viewer</span><br></pre></td></tr></table></figure><ol start="2"><li>接着，在个人电脑上，或者手机上下载VNC Viewer客户端</li><li>最后，在远程连接设备端(个人电脑或者手机)输入树莓派的用户名，密码，ip地址即可远程连接树莓派了</li></ol><h2><span id="树莓派的缺点"> 树莓派的缺点</span></h2><p>在树莓派3上做全栈开发并不是很理想，因为部分软件对32bit ARM架构处理器的兼容性不是很好，查看树莓派3的CPU架构可以使用如下命令，结果如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:          armv7l</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    4</span><br><span class="line">Socket(s):             1</span><br><span class="line">Model:                 4</span><br><span class="line">Model name:            ARMv7 Processor rev 4 (v7l)</span><br><span class="line">CPU max MHz:           1200.0000</span><br><span class="line">CPU min MHz:           600.0000</span><br><span class="line">BogoMIPS:              38.40</span><br><span class="line">Flags:                 half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到树莓派3采用一块ARMv7架构的CPU，通过查阅维基百科，得知ARMv1到ARMv7架构都是32 bits寻址，直到ARMv8架构才出现64 bits寻址。</p><p>故事起源于我想在树莓派上安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dla2FuL3dla2Fu">wekan<i class="fa fa-external-link-alt"></i></span>，wekan是类似于<span class="exturl" data-url="aHR0cHM6Ly90cmVsbG8uY29tLw==">Trello<i class="fa fa-external-link-alt"></i></span>的Kanban类项目管理软件，奈何wekan是基于Meteor建立的，而Meteor对安装环境有x86_64的假设，即使修改源代码去掉该假设也不能顺利安装，参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ldGVvci9tZXRlb3IvaXNzdWVzLzQ0Mg==">meteor/issues/442<i class="fa fa-external-link-alt"></i></span>。好消息是2017年6月份，Meteor团队开始着手与增加Meteor对ARM架构CPU的支持，参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ldGVvci9tZXRlb3ItZmVhdHVyZS1yZXF1ZXN0cy9pc3N1ZXMvMTMw">meteor-feature-requests/issues/130<i class="fa fa-external-link-alt"></i></span>。</p><p>不能在树莓派上安装wekan，让我有点小小的伤心，但是接下来发生的事情就让我对在树莓派上搞全栈开发暂时失去了兴趣。故事是这样的，为了学习网爬虫，我做了一个每天计算出Stackoverflow最火热问题的项目来练手，该项目的的爬虫部分基于Scapy框架，数据库我选用了最新版本的MongoDB (v3.4.9)　来存储爬取的网页内容。开发完成后我利用crontab在自己的电脑上让它每天晚上10点5分定时在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ppbmhhaVovc3RhY2tvdmVyZmxvdy10cmVuZGluZw==">这里<i class="fa fa-external-link-alt"></i></span>update最火热问题排行。</p><p>问题是我的电脑并不是每天晚上10点5分都处于运行状态，有好几次因为我没有开机导致当天我写的程序没有update。于是乎我有了把MongoDB和网页爬取程序部署在树莓派上的想法。说干就干，在树莓派上陆续安装了相应的开发环境，主要是python的开发环境，比如安装Scapy框架可以通过下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># install Scrapy</span><br><span class="line">sudo apt-get install libffi-dev</span><br><span class="line">sudo apt-get install libxml2-dev</span><br><span class="line">sudo apt-get install libxslt1-dev</span><br><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo pip install scrapy</span><br></pre></td></tr></table></figure><p>然而在安装最新版的MongoDB时我遇到了无法解决的问题，实际上，通过下面命令可以安装MongoDB</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># install MongoDB</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mongodb-server</span><br></pre></td></tr></table></figure><p>但是版本号停留在了v2.4.14，经过查询得知v2.4.14版本后MongoDB就放弃了对32 bit ARM架构CPU的支持，导致树莓派3无法安装最新的MongoDB。奈何我的程序用了大量新版本的特性，比如<code>$slice</code>选择符等，最后在树莓派上部署爬虫的想法只好作罢。</p><h2><span id="总结"> 总结</span></h2><p>第一次接触&quot;单板电脑&quot;(SBC, Single Board Computer)还是很有新鲜感的，低廉的售价，和正常PC几乎一样的功能以及丰富的DIY选项让人很难拒绝。不过作为一个全栈开发人员，想要在树莓派上部署应用，不能安装最新的MongoDB意味着几年前比较流行的MEAN框架在树莓派上可能会行不通，部分框架，例如于ARM处理器有兼容问题的Meteor，会导致部分软件例如wekan在树莓派上无法应用，这些问题在购买前还是要考虑的。</p><p>参考</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1zZXQtdXAtc3NoLWtleXMtLTI=">How To Set Up SSH Keys<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkub3JnL2RvY3VtZW50YXRpb24vcmVtb3RlLWFjY2Vzcy92bmMv">VNC (VIRTUAL NETWORK COMPUTING)<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1&quot;&gt;第一印象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5&quot;&gt;远程连接&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%9A%E8%BF%87ssh&quot;&gt;通过ssh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%80%9A%E8%BF%87vnc-viewer&quot;&gt;通过VNC Viewer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E7%BC%BA%E7%82%B9&quot;&gt;树莓派的缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h2 id=&quot;第一印象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一印象&quot;&gt;&lt;/a&gt; 第一印象&lt;/h2&gt;
&lt;p&gt;大约在20天前，我在亚马逊上冲动的购买了这个东西&lt;/p&gt;
&lt;img data-src=&quot;/2017/10/25/first-glance-at-RaspberryPi/Raspberry-Pi-3-Official-Desktop-Starter-Kit.png&quot; class=&quot;&quot; title=&quot;Raspberry Pi 3 Official Desktop Starter Kit&quot;&gt;
&lt;p&gt;树莓派3的官方Desktop Starter Kit，其实也就是树莓派3开发板+16GB miroSD装机卡+壳子+充电器套装。不过这样一套买下来，上手把玩树莓派要方便许多，机子到手第一天我就按照说明书安装了树莓派定制Debian的发型版Raspbian系统。第一感觉还挺好用，通过HDMI连接上显示器，再用4个USB接口中的两个连接键盘和鼠标就可以当做桌面电脑使用了。如果要通过个人电脑远程连接树莓派的话，ssh和VNC Viewer都很好用。&lt;/p&gt;
&lt;h2 id=&quot;远程连接&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#远程连接&quot;&gt;&lt;/a&gt; 远程连接&lt;/h2&gt;
&lt;h3 id=&quot;通过ssh&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#通过ssh&quot;&gt;&lt;/a&gt; 通过ssh&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;注意，以下步骤均在个人电脑上完成，不是在树莓派上&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://codingnote.com/categories/Linux/"/>
    
      <category term="折腾" scheme="http://codingnote.com/categories/Linux/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="RaspberryPi" scheme="http://codingnote.com/tags/RaspberryPi/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning 学习笔记 1</title>
    <link href="http://codingnote.com/2017/10/19/machine-learning-review1/"/>
    <id>http://codingnote.com/2017/10/19/machine-learning-review1/</id>
    <published>2017-10-19T17:04:07.000Z</published>
    <updated>2020-12-30T16:02:34.355Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AC%94%E8%AE%B0">机器学习第一周笔记</a><ul><li><a href="#%E6%A6%82%E8%BF%B0">概述</a><ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0">什么是机器学习？</a></li><li><a href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB">机器学习的分类</a></li></ul></li><li><a href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">线性回归</a><ul><li><a href="#%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B">回归模型</a></li><li><a href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8Dgradient-descent">梯度下降(Gradient descent)</a></li></ul></li></ul></li></ul><!-- tocstop --><h1><span id="机器学习第一周笔记"> 机器学习第一周笔记</span></h1><h2><span id="概述"> 概述</span></h2><h3><span id="什么是机器学习"> 什么是机器学习？</span></h3><p>从字面上来说，机器学习就是让机器通过模仿人学习的过程学习。也就是说让机器有能力学习，而不是通过准确的程序而实现。我们生活中无处不在存在着机器学习的应用，例如垃圾邮件分类系统，通过图片识别物体等。</p><h3><span id="机器学习的分类"> 机器学习的分类</span></h3><p>机器学习分为两大类：</p><a id="more"></a><ul><li><p><strong>有监督学习(supervised learning)</strong>：给定输入数据和正确的输出结果，通过一系列“训练模型”使得输出结果和正确输出结果无限接近的过程。其中又可以分为两大类 <strong>回归(regression)</strong> 和 <strong>分类(classification)</strong> 问题。例如：给定某地区房屋的情况（房间个数，地理位置，周围环境…）及价格，来预测这个地区某个房子的价格。这就是一个回归问题。再比如通过一个人的照片来预测这个人的年龄。 而分类问题则是输出结果只有两种情况的问题。比如：预测一个病人的肿瘤是良性还是恶性；预测一封邮件是否是垃圾邮件等等。这种问题的结果只有两种情况。</p></li><li><p><strong>无监督学习(unsupervised learning)</strong>：没有给出正确的输出结果，让机器自己发现输入数据的结构。无监督学习最常见的应用就是分类。比如：给定用户数据，自动划分用户类比从而划分市场；给定一些文章报道，分类文章的类别，政治新闻，经济新闻，或文化新闻等等。</p></li></ul><h2><span id="线性回归"> 线性回归</span></h2><h3><span id="回归模型"> 回归模型</span></h3><p>通过训练数据集(training set)学习得到一个函数h(x)，使得输入数据X通过h函数映射的预测结果Y最接近正确值。线性回归的目标就是寻找到h函数使得其完美拟合输入X和输出Y的关系。</p><img data-src="/2017/10/19/machine-learning-review1/linear-regression-model.png" class title="learning regression model"><p>(Figure 1 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY291cnNlcmEub3JnL2xlYXJuL21hY2hpbmUtbGVhcm5pbmcvc3VwcGxlbWVudC9jUmEybS9tb2RlbC1yZXByZXNlbnRhdGlvbg==">https://www.coursera.org/learn/machine-learning/supplement/cRa2m/model-representation<i class="fa fa-external-link-alt"></i></span>)</p><p>既然已经有了这个模型我们下一个问题就是如何才能找到这样的一个h函数？<br>在线性回归里用来判断拟合函数h好坏的一个标准就是代价函数(Cost funtion)。这个函数的数学表示如下，其中用均方误差来表示预测结果与真实结果的误差。</p><img data-src="/2017/10/19/machine-learning-review1/cost-function.png" class title="Cost function"><p>这时，机器学习过程的目标就是要找到一个h函数使得误差J最小。</p><h3><span id="梯度下降gradient-descent"> 梯度下降(Gradient descent)</span></h3><p>求解最小代价函数的方法之一就是用梯度下降(Gradient descent)的方法。<br>数学上，<strong>梯度方向</strong>是<strong>函数值下降最为剧烈</strong>的方向。那么，沿着梯度方向走，我们就能接近其最小值，或者极小值，从而接近更高的预测精度。其数学表达如下：</p><img data-src="/2017/10/19/machine-learning-review1/gradient-descent.png" class title="Gradient descent"><p>其中<strong>学习率ɑ</strong>表示的是下降的速率，当这个值过大时会导致错过最小值（步子跨的太大）；当这个值过小时会导致下降的速度很慢（步子跨的太小）。<br>用梯度下降的方法就是不断的沿着梯度方向更新值，直到找到<strong>最小值</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AC%94%E8%AE%B0&quot;&gt;机器学习第一周笔记&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A6%82%E8%BF%B0&quot;&gt;概述&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0&quot;&gt;什么是机器学习？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%88%86%E7%B1%BB&quot;&gt;机器学习的分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92&quot;&gt;线性回归&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B&quot;&gt;回归模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8Dgradient-descent&quot;&gt;梯度下降(Gradient descent)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h1 id=&quot;机器学习第一周笔记&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#机器学习第一周笔记&quot;&gt;&lt;/a&gt; 机器学习第一周笔记&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#概述&quot;&gt;&lt;/a&gt; 概述&lt;/h2&gt;
&lt;h3 id=&quot;什么是机器学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#什么是机器学习&quot;&gt;&lt;/a&gt; 什么是机器学习？&lt;/h3&gt;
&lt;p&gt;从字面上来说，机器学习就是让机器通过模仿人学习的过程学习。也就是说让机器有能力学习，而不是通过准确的程序而实现。我们生活中无处不在存在着机器学习的应用，例如垃圾邮件分类系统，通过图片识别物体等。&lt;/p&gt;
&lt;h3 id=&quot;机器学习的分类&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#机器学习的分类&quot;&gt;&lt;/a&gt; 机器学习的分类&lt;/h3&gt;
&lt;p&gt;机器学习分为两大类：&lt;/p&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://codingnote.com/categories/Notes/"/>
    
      <category term="Machine Learning" scheme="http://codingnote.com/categories/Notes/Machine-Learning/"/>
    
    
      <category term="Machine Learning" scheme="http://codingnote.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>python中的反引号reverse quotes</title>
    <link href="http://codingnote.com/2017/09/25/backtick-in-python/"/>
    <id>http://codingnote.com/2017/09/25/backtick-in-python/</id>
    <published>2017-09-25T16:34:16.000Z</published>
    <updated>2020-03-15T10:34:36.253Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E5%8F%8D%E5%BC%95%E5%8F%B7">反引号`</a></li><li><a href="#repr%E5%87%BD%E6%95%B0">repr函数</a></li><li><a href="#%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E7%9A%84%E6%80%9D%E8%80%83">关于单例的思考</a></li></ul><!-- tocstop --><h3><span id="反引号"> 反引号`</span></h3><p>今天在看一本基于python2.2的Design Pattern书，其中有一段关于单例的代码我很不解，因为用到了反引号`，也就是reverse quotes。书中代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">__OnlyOne</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">      self.val = arg</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="keyword">return</span> `self` + self.val</span><br><span class="line">  instance = <span class="literal">None</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, arg</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> OnlyOne.instance:</span><br><span class="line">      OnlyOne.instance = OnlyOne.__OnlyOne(arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      OnlyOne.instance.val = arg</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getattr</span>(self.instance, name)</span><br><span class="line"></span><br><span class="line">x = OnlyOne(<span class="string">&#x27;sausage&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line">y = OnlyOne(<span class="string">&#x27;eggs&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line">z = OnlyOne(<span class="string">&#x27;spam&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> z</span><br><span class="line"><span class="built_in">print</span> x</span><br><span class="line"><span class="built_in">print</span> y</span><br><span class="line"><span class="built_in">print</span> `x`</span><br><span class="line"><span class="built_in">print</span> `y`</span><br><span class="line"><span class="built_in">print</span> `z`</span><br></pre></td></tr></table></figure><a id="more"></a><p>console输出结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;sausage</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;eggs</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b01b8&gt;</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b0290&gt;</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b02d8&gt;</span><br></pre></td></tr></table></figure><p>反引号`到底有什么用呢？经过查询,反引号在python2中是repr()函数的别名(alias)，但是反引号别名表示已经在pyhton3.0中取消了。至于为何取消，Guido van Rossum他本人的解释是反引号`和正常引号‘的相似性实在是太令人误解了，此外反引号在印刷字体以及输入方面都有不少问题。</p><h3><span id="repr函数"> repr函数</span></h3><p>知道了python中反引号`其实是repr()函数的别名，那么python中repr函数本身又是干什么的呢？</p><blockquote><p><strong>repr(object)</strong><br>Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse quotes). It is sometimes useful to be able to access this operation as an ordinary function. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a <strong>repr</strong>() method.</p></blockquote><p>根据上述节选自python官方文档的解释，可以知道repr函数主要功能是返回object的一种可打印字符串表示。一般来说，repr函数被设计成其输出可以被eval函数生成值相同的object，或者，被设计成返一个包含在尖头括号中的字符串，其中包含对象类型名称和一些附加信息。而附加信息通常包括这个对象的名字和物理地址。</p><p>在Desgin Patter作者给出的单例代码中，repr函数便输出了对象的名字和物理地址。</p><h3><span id="关于单例的思考"> 关于单例的思考</span></h3><p>一般讲Desgin Pattern的书几乎一开始都会讲单例，毕竟单例是最容易理解的Desgin Pattern。作者在实现单例时用了nested class方法，内部class是一个私有class，这样外部无法直接访问。那么print函数又是如何访问到私有class的<code>__str__</code>函数的呢？这就要靠wrapper class的<code>__getattr__</code>函数了，在这里作者巧妙实现了一个delegation。这也是为什么print OnlyOne class的instance时，console输出都是私有class的<code>__str__</code>函数定义的结果。</p><p>参考</p><ol><li><a href="https://stackoverflow.com/questions/1673071/what-do-backticks-mean-to-the-python-interpreter-num">What do backticks mean to the python interpreter: num<br></a></li><li><span class="exturl" data-url="aHR0cHM6Ly9tYWlsLnB5dGhvbi5vcmcvcGlwZXJtYWlsL3B5dGhvbi1pZGVhcy8yMDA3LUphbnVhcnkvMDAwMDU0Lmh0bWw=">[Python-ideas] new operators via backquoting<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JlcHI=">docs.python repr(object)<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5taW5kdmlldy5uZXQvQm9va3MvUHl0aG9uL1RoaW5raW5nSW5QeXRob24uaHRtbA==">Bruce Eckel Thinking in Python<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%8D%E5%BC%95%E5%8F%B7&quot;&gt;反引号`&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#repr%E5%87%BD%E6%95%B0&quot;&gt;repr函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E7%9A%84%E6%80%9D%E8%80%83&quot;&gt;关于单例的思考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h3 id=&quot;反引号&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#反引号&quot;&gt;&lt;/a&gt; 反引号`&lt;/h3&gt;
&lt;p&gt;今天在看一本基于python2.2的Design Pattern书，其中有一段关于单例的代码我很不解，因为用到了反引号`，也就是reverse quotes。书中代码如下&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OnlyOne&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__OnlyOne&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, arg&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      self.val = arg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__str__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; `self` + self.val&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  instance = &lt;span class=&quot;literal&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, arg&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; OnlyOne.instance:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      OnlyOne.instance = OnlyOne.__OnlyOne(arg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      OnlyOne.instance.val = arg&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__getattr__&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;self, name&lt;/span&gt;):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;getattr&lt;/span&gt;(self.instance, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = OnlyOne(&lt;span class=&quot;string&quot;&gt;&amp;#x27;sausage&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = OnlyOne(&lt;span class=&quot;string&quot;&gt;&amp;#x27;eggs&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;z = OnlyOne(&lt;span class=&quot;string&quot;&gt;&amp;#x27;spam&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; z&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; `x`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; `y`&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt; `z`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="http://codingnote.com/categories/python/"/>
    
    
      <category term="python" scheme="http://codingnote.com/tags/python/"/>
    
      <category term="reverse quotes" scheme="http://codingnote.com/tags/reverse-quotes/"/>
    
  </entry>
  
  <entry>
    <title>python中的生成器</title>
    <link href="http://codingnote.com/2017/09/25/generator-in-python/"/>
    <id>http://codingnote.com/2017/09/25/generator-in-python/</id>
    <published>2017-09-25T10:27:12.000Z</published>
    <updated>2020-03-15T10:35:43.389Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1">可迭代对象</a></li><li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li><li><a href="#%E7%94%9F%E6%88%90%E5%99%A8">生成器</a></li><li><a href="#%E5%85%B3%E9%94%AE%E8%AF%8Dyield">关键词Yield</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8">什么时候使用生成器</a></li><li><a href="#%E4%BB%8Edesign-pattern%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%94%9F%E6%88%90%E5%99%A8">从Design Pattern角度看生成器</a></li></ul><!-- tocstop --><h3><span id="可迭代对象"> 可迭代对象</span></h3><p>要想理解python中的生成器，得先从可迭代对象Iterable说起。什么是可迭代对象呢？</p><blockquote><p>定义了可以返回一个迭代器的__iter__方法的对象，或者定义了可以支持下标索引的__getitem__方法的对象，就是一个可迭代对象</p></blockquote><p>所以我们可以用如下方法来判断一个实例是否为可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="string">&#x27;__iter__&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hasattr</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">&#x27;__iter__&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hasattr</span>(&#123;&#125;, <span class="string">&#x27;__iter__&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">hasattr</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>) <span class="comment"># True</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>知道了可迭代对象的定义，那么可迭代对象又有什么用呢，如下列所示，我们经常在python中使用for…in循环，那么for…in循环能在所有对象上使用吗？</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">  print(i) </span><br><span class="line"><span class="comment"># 1 </span></span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>其实不然，只有在可迭代对象上，for…in循环才能使用，比如列表，元组，字典以及字符串。这就是可迭代对象的最大用途。然而问题有来了，这些可迭代对象虽然好用，但是它们却又一大弊端。可迭代对象在使用时，比如<code>my_list</code>，它会把列表<code>[1, 2, 3]</code>中所有元素都存贮在内存中，当列表长度非常可观时，python会遇到性能方面的问题(python2.7中range函数返回可迭代对象，xrange函数返回生成器，所以可以通过比较这两个函数的执行相同任务时间来直观的了解性能方面的问题，stackoverflow上便有回答来比较这两个函数的执行时间，问题链接<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ5MzUvd2hhdC1pcy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLXJhbmdlLWFuZC14cmFuZ2UtZnVuY3Rpb25zLWluLXB5dGhvbi0yLXg=">点此<i class="fa fa-external-link-alt"></i></span>)。</p><h3><span id="迭代器"> 迭代器</span></h3><p>对于上述列表对象遇到的性能问题，我们自然会问到有没有方法来解决这样的问题。比如，有没有一种类似列表的对象，但是它不会一下子把它所有的元素都放到内存里的对象？<br>有，它就是迭代器，还是先说迭代器Iterator的定义</p><blockquote><p>定义了返回迭代器对象本身__iter()__(Python2)方法的对象，或者定义了方法返回容器的下一个元素__next__方法的对象，就是一个迭代器。</p></blockquote><p>同时我们也说，实现了上述两个方法的对象是遵守了迭代器协议（iterator protocol）的对象。</p><p>判断一个对象我们除了可以检查它有没有<code>__iter()__</code>和<code>__next__</code>方法外，我们也可以用isinstance()方法。如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(&#123;&#125;, Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>这下我们发现，元组，列表，字典，字符串都是可迭代对象，但同时它们也都不是迭代器。谁是迭代器呢？从上面例子可看到<code>(x for x in [1,2,3])</code>是迭代器对象的实例。</p><p>首先，为什么元组，列表，字典，字符串都不是迭代器Iterator呢？</p><blockquote><p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p></blockquote><p>从以上摘自<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDMxNjA4OTU1NzI2NGE2YjM0ODk1OGY0NDk5NDlkZjQyYTZkM2EyZTU0MmMwMDAvMDAxNDMxNzgyNTQxOTM1ODlkZjljNjEyZDI0NDk2MThlYTQ2MGU3YTY3MmEzNjYwMDA=">廖雪峰<i class="fa fa-external-link-alt"></i></span>官网上的解答中我们可以看出，迭代器表示一个数据流，它不会把这个数据流中每一个元素都存贮在内存中，而列表则不同，它会把列表中所有元素都存贮在内存中。</p><p>对于第二个问题，为什么<code>(x for x in [1,2,3])</code>是迭代器对象的实例呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">iter</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(&#123;&#125;), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&#x27;abc&#x27;</span>), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure><p>从以上例子可以看出，虽然元组，列表，字典，字符串都不是迭代器，但是通过iter()函数，可以获得一个Iterator对象。</p><p>所以Python的for循环本质上可以看做先通过iter()函数，获得一个迭代器Iterator对象，再在这个迭代器对象上通过不断调用next()函数实现的。</p><h3><span id="生成器"> 生成器</span></h3><p>在了解了可迭代对象Iterable和迭代器Iterator的概念后，我们终于可以开始探讨生成器的概念了。</p><p>先放概念</p><blockquote><p>生成器是一种迭代器，但是只能对其迭代一次。因为它们并没有把所有的值存在内存中，而是在运行时生成值。生成器可通过遍历来使用它们，要么用一个“for”循环，要么将它传递给任意可以进行迭代的函数和结构。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_generator = (x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># nothing happens</span></span><br></pre></td></tr></table></figure><p>上面是生成器的一个简单的例子，这个例子有点像for…in循环输出<code>my_list</code>的例子，除了这里用了一个迭代器<code>(x for x in [1,2,3])</code>替换了可迭代对象<code>[1,2,3]</code>。它们有什么不同吗？仔细观察上例，当我们再次使用for…in循环输出my_generator时，什么都没有发生，这也就是定义中说的</p><blockquote><p>生成器是一种迭代器，但是只能对其迭代一次。</p></blockquote><p>因为生成器首先生成1，接着从内存中清空1，接下来生成2，接着从内存中清空2，最后生成3，接着从内存中清空3。</p><h3><span id="关键词yield"> 关键词Yield</span></h3><p>我们知道了一种由迭代器来获得生成器的方式，那么还有其他的方式来获得生成器吗？用Python关键词yield就可以。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span>():</span></span><br><span class="line">  my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">my_generator = createGenerator()</span><br><span class="line">print(my_generator) <span class="comment"># &lt;generator object createGenerator at 0x7ff6a5c785c8&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>虽然上面的例子没有人在实际中会使用，但是用它来了解yield的用法还是很通俗易懂的。关于yield的难点，首先我们可以看到，通过<code>createGenerator()</code>函数来获得生成器<code>my_generator</code>时，函数<code>createGenerator()</code>并没有被执行，它只是返回了一个位于内存中处于某个位置上的该生成器对象。直到我们用for…in循环作用于这个对象上时，函数<code>createGenerator()</code>才被真正的执行，我们可以把它当做是一种惰性求值。</p><p>那么生成器<code>my_generator</code>是如何求值的呢？当for…in循环第一次调用生成器时，<code>createGenerator()</code>被执行，直到被执行到yield关键词这里，返回循环的第一个值。余下的循环在调用生成器时，会继续上次的循环，再次遇到yield关键词时返回这一次循环的值，直到循环结束，再也遇不到yield关键词为止。</p><h3><span id="什么时候使用生成器"> 什么时候使用生成器</span></h3><p>生成器的一个典型应用场景是：你不想把同一时间将所有计算出来的大量结果贮存到内存中，因为这样做会消耗大量资源，所以使用生成器来进行惰性求值，只有在需要某个结果时，再计算该结果。</p><p>举一个生成斐波那契数列的例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  fib_list = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    fib_list.append(a)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line">  <span class="keyword">return</span> fib_list</span><br></pre></td></tr></table></figure><p>当输入参数很大时，内存资源会被严重消耗。</p><p>下面是该函数的生成器版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a, b = b, a + b</span><br></pre></td></tr></table></figure><p>由于惰性求值的缘故，即便参数很大时，我们也不用担心内存资源的消耗。</p><p>我们刚刚谈到了内存消耗情况，有什么工具能帮助我们直观的感受到内存的消耗呢？ python有个叫<code>memory_profiler</code>的工具可以来帮我们进行内存消耗情况的测试。为了对比上述两个方法的内存消耗，我们让这两个方法同时生100000个斐波那契数列，并观察内存消耗情况。</p><p>测试<code>listFibonacci()</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  fib_list = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    fib_list.append(a)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line">  <span class="keyword">return</span> fib_list</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testListFib</span>():</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> listFibonacci(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    testListFib()</span><br></pre></td></tr></table></figure><p>测试<code>genFibonacci()</code>代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFibonacci</span>(<span class="params">n</span>):</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testGenFib</span>():</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> genFibonacci(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  testGenFib()</span><br></pre></td></tr></table></figure><p>使用<code>listFibonacci()</code>测试结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filename: listFib.py</span><br><span class="line"></span><br><span class="line">Line #    Mem usage    Increment   Line Contents</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">    11     14.2 MiB      0.0 MiB   @profile</span><br><span class="line">    12                             def testListFib():</span><br><span class="line">    13    460.5 MiB    446.2 MiB     for i in listFibonacci(100000):</span><br><span class="line">    14    460.5 MiB      0.0 MiB       pass</span><br></pre></td></tr></table></figure><p>使用<code>genFibonacci()</code>测试结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Filename: genFib.py</span><br><span class="line"></span><br><span class="line">Line #    Mem usage    Increment   Line Contents</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">     9     14.4 MiB      0.0 MiB   @profile</span><br><span class="line">    10                             def testGenFib():</span><br><span class="line">    11     14.4 MiB      0.0 MiB     for i in genFibonacci(100000):</span><br><span class="line">    12     14.4 MiB      0.0 MiB       pass</span><br></pre></td></tr></table></figure><p>从上面的测试结果可以看出，在生成大于100000个斐波那契数列的任务中，<code>listFibonacci()</code>消耗了460.5 MiB内存，而<code>genFibonacci()</code>只消耗了14.4 MiB内存。其实，如果我们绘制一个内存消耗随生成斐波那契数列长度变化的折线图，我们可以发现，随着生成斐波那契数列长度的增加，<code>listFibonacci()</code>的内存消耗情况是指数递增的，而<code>genFibonacci()</code>的内存消耗情况则是不变的，总是维持在消耗14.4 MiB 左右。通过这个测试，我们可以直观的感受到，在计算大量不需要被保存结果且只需计算一次的任务下，我们为什么不用担心生成器对内存资源的消耗。</p><h3><span id="从design-pattern角度看生成器"> 从Design Pattern角度看生成器</span></h3><p>如果从Design Pattern的角度来看生成器，生成器就是一个无参数版本的工厂模式。通常工厂模式需要通过参数来确定生成什么对象以及如何生成该对象，但是生成器则不需要参数，它通过内部算法来确定生成什么对象以及如何生成该对象。</p><p>参考</p><ol><li><a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do/231855#231855">Stackoverflow, What does the “yield” keyword do?<br></a></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDMxNjA4OTU1NzI2NGE2YjM0ODk1OGY0NDk5NDlkZjQyYTZkM2EyZTU0MmMwMDAvMDAxNDMxNzgyNTQxOTM1ODlkZjljNjEyZDI0NDk2MThlYTQ2MGU3YTY3MmEzNjYwMDA=">廖雪峰的官方网站, 迭代器<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvZXhwbG9yZS1weXRob24vQWR2YW5jZWQtRmVhdHVyZXMvaXRlcmF0b3IuaHRtbA==">极客学院, 迭代器<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5taW5kdmlldy5uZXQvQm9va3MvUHl0aG9uL1RoaW5raW5nSW5QeXRob24uaHRtbA==">Bruce Eckel, Thinking in Python<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1&quot;&gt;可迭代对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%AD%E4%BB%A3%E5%99%A8&quot;&gt;迭代器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%B3%E9%94%AE%E8%AF%8Dyield&quot;&gt;关键词Yield&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;什么时候使用生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%8Edesign-pattern%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;从Design Pattern角度看生成器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h3 id=&quot;可迭代对象&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#可迭代对象&quot;&gt;&lt;/a&gt; 可迭代对象&lt;/h3&gt;
&lt;p&gt;要想理解python中的生成器，得先从可迭代对象Iterable说起。什么是可迭代对象呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义了可以返回一个迭代器的__iter__方法的对象，或者定义了可以支持下标索引的__getitem__方法的对象，就是一个可迭代对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们可以用如下方法来判断一个实例是否为可迭代对象&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;hasattr&lt;/span&gt;((&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;), &lt;span class=&quot;string&quot;&gt;&amp;#x27;__iter__&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;hasattr&lt;/span&gt;([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;], &lt;span class=&quot;string&quot;&gt;&amp;#x27;__iter__&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;hasattr&lt;/span&gt;(&amp;#123;&amp;#125;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;__iter__&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;hasattr&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;abc&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;#x27;__getitem__&amp;#x27;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;知道了可迭代对象的定义，那么可迭代对象又有什么用呢，如下列所示，我们经常在python中使用for…in循环，那么for…in循环能在所有对象上使用吗？&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://codingnote.com/categories/Design-Pattern/"/>
    
    
      <category term="python" scheme="http://codingnote.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用python来探讨多态</title>
    <link href="http://codingnote.com/2017/09/25/polymorphism-in-python/"/>
    <id>http://codingnote.com/2017/09/25/polymorphism-in-python/</id>
    <published>2017-09-25T10:27:12.000Z</published>
    <updated>2020-03-15T10:37:22.730Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- toc --><!-- tocstop --><p>最近在看一本基于pyhton的Design Pattern方面的书，其中涉及到了python的多态，也就是polymorphism。用python来解释，到底什么是多态(polymorphism)呢？StackOverflow上有一个很好的答案，下面便是答案中举的例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span>    <span class="comment"># Constructor of the class</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span>              <span class="comment"># Abstract method, defined by convention only</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Subclass must implement abstract method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Meow!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Woof! Woof!&#x27;</span></span><br><span class="line"></span><br><span class="line">animals = [Cat(<span class="string">&#x27;Missy&#x27;</span>),</span><br><span class="line">           Cat(<span class="string">&#x27;Mr. Mistoffelees&#x27;</span>),</span><br><span class="line">           Dog(<span class="string">&#x27;Lassie&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="built_in">print</span> animal.name + <span class="string">&#x27;: &#x27;</span> + animal.talk()</span><br></pre></td></tr></table></figure><p>从这个例子我们可以看出，不同的动物都可以“talk”，但它们“talk”的实现方式不同。 因此，“talk”行为是多态的，它根据动物的不同而有所不同。 我们可以看到，抽象的Animal类实际上并不能“talk”，而具体的动物类（如Dog和Cat）则分别实现了“talk”的动作。</p><p>类似地，加法操作符<code>+</code>在许多数学运算中有定义，在特定情况下，多态性允许我们根据具体规则定义加法操作符，比如在实数集下：<code>1 + 1 = 2</code>，但包含复数的情况下<code>(1 + 2i)+(2-9i)=(3-7i)</code>。</p><p>总结来说，多态允许我们在抽象类中指定常用方法，并在特定子类中实现它们。</p><p>参考</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9seW1vcnBoaXNtXyhjb21wdXRlcl9zY2llbmNlKQ==">Wikipedia Polymorphism<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzcyNDExMC9wcmFjdGljYWwtZXhhbXBsZS1vZi1wb2x5bW9ycGhpc20=">StackOverflow Polymorphism<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;!-- toc --&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;最近在看一本基于pyhton的Design Pattern方面的书，其中涉及到了python的多态，也就是polymorphism。用python来解释，到底什么是多态(polymorphism)呢？StackOverflow上有一个很好的答案，下面便是答案中举的例子&lt;/p&gt;
    
    </summary>
    
      <category term="Design Pattern" scheme="http://codingnote.com/categories/Design-Pattern/"/>
    
    
      <category term="python" scheme="http://codingnote.com/tags/python/"/>
    
      <category term="polymorphism" scheme="http://codingnote.com/tags/polymorphism/"/>
    
      <category term="多态" scheme="http://codingnote.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>在Alienware上安装Ubuntu</title>
    <link href="http://codingnote.com/2017/09/15/install-ubuntu-on-alienware/"/>
    <id>http://codingnote.com/2017/09/15/install-ubuntu-on-alienware/</id>
    <published>2017-09-15T11:20:28.000Z</published>
    <updated>2020-03-15T10:36:54.799Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录"> 目录</span></h2><!-- toc --><ul><li><a href="#%E5%88%B6%E4%BD%9Cubuntu%E5%90%AF%E5%8A%A8u%E7%9B%98">制作Ubuntu启动U盘</a></li><li><a href="#%E5%AE%89%E8%A3%85ubuntu">安装Ubuntu</a></li><li><a href="#%E8%A7%A3%E5%86%B3%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98">解决驱动问题</a><ul><li><a href="#%E5%AE%89%E8%A3%85killer%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8">安装killer网卡驱动</a></li><li><a href="#%E5%AE%89%E8%A3%85%E8%93%9D%E7%89%99%E9%A9%B1%E5%8A%A8">安装蓝牙驱动</a></li></ul></li><li><a href="#%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AEalienfx">进阶配置AlienFx</a></li></ul><!-- tocstop --><p>作为一个游戏发烧友，同时也是小白全栈开发程序员我买了Alienware却只用来打游戏是在是太可惜了。为了搞搞开发，昨天配置了一天WSL (Windows Subsystems for Linxu)，用了Hyper+zsh的终端组合。其中在zsh中输入atom能启动windows的Atom也着实把我惊艳了一把，但其实也就算仅限于打开而已。事实是Windows中的文本编辑器并不能直接编辑其子系统中的文件。所以这个子系统在某些方便我觉得还没有Vagrant方便，没有图形界面，意味着不能使用Atom，Visual Studio Code这样代表先进生产力的工具，于是配置WSL搞搞开发的想法就此作罢。</p><p>子系统搞不成，于是有了直接在Ubuntu上工作的想法。其实Alienware上安装Ubuntu不是很难，除了一些蓝牙和Wi-Fi方面的兼容问题，安装过程非常顺利。接下来step by step记录安装过程。</p><a id="more"></a><h2><span id="制作ubuntu启动u盘"> 制作Ubuntu启动U盘</span></h2><p>在Ubuntu官方网站下载16.04 LTS系统镜像，并将其制作成启动U盘。<br>制作启动U盘的工具有很多，<span class="exturl" data-url="aHR0cHM6Ly9ydWZ1cy5ha2VvLmllLw==">Rufus<i class="fa fa-external-link-alt"></i></span> 是我用的一款，界面简单清爽无广告不收费。</p><p>Rufus界面如下，制作启动U盘时，注意Partition schemem and target system type选择同时支持UEFI和BIOS的格式。</p><img data-src="/2017/09/15/install-ubuntu-on-alienware/rufus_en_2x.png" class title="用Rufus制作Ubuntu启动U盘 (图片来源rufus.akeo.ie)"><h2><span id="安装ubuntu"> 安装Ubuntu</span></h2><p>重新启动Windows，启动黑屏时按F11进入UEFI界面，有两个配置需要更改</p><ul><li>关闭secure boot</li><li>打开legecy boot mode</li></ul><p>插入Ubuntu启动U盘符，再次重新启动，按下F11，选择从U盘启动，接下来的步骤和在普通电脑上安装双系统无异。</p><p>安装完成后，再次启动，boot loader已经从windows boot manager变成了GRUB(<strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>ootloader)。以后在便可以在GRUB界面中选择进入的系统是Ubuntu还是Windows。</p><h2><span id="解决驱动问题"> 解决驱动问题</span></h2><p>进入安装完毕的Ubuntu，我遇到的第一个问题就是无法连接Wi-Fi。安装驱动程序有一个一般性的方法，先通过下面的命令查看自己使用的设备是什么型号，然后在网上搜索该型号设备的驱动程序。</p><ul><li><p><code>lsusb</code> 查看usb接口的设备</p></li><li><p><code>lspci</code> 查看pci接口的设备</p></li></ul><h3><span id="安装killer网卡驱动"> 安装killer网卡驱动</span></h3><p>如下图所示，<code>lspci | grep -i net</code>命令显示我使用的网卡型号是Qualcomm Atheros Killer E2400，通过搜索，发现Alienware使用的killer网卡的<span class="exturl" data-url="aHR0cHM6Ly93d3cua2lsbGVybmV0d29ya2luZy5jb20vZHJpdmVyLWRvd25sb2Fkcy9rbm93bGVkZ2UtYmFzZT92aWV3PXRvcGljJmFtcDtpZD0y">官方网站<i class="fa fa-external-link-alt"></i></span>提供了相关驱动的下载。</p><img data-src="/2017/09/15/install-ubuntu-on-alienware/alienware_wifi_driver.png" class title="安装killer网卡驱动"><p>如上图所示，可通过如下命令安装killer网卡驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;mirrors.kernel.org&#x2F;ubuntu&#x2F;pool&#x2F;main&#x2F;l&#x2F;linux-firmware&#x2F;linux-firmware_1.164_all.deb</span><br><span class="line">sudo dpkg -i linux-firmware*.deb</span><br><span class="line">sudo modprobe -r ath10k_pci &amp;&amp; sudo modprobe ath10k_pci</span><br></pre></td></tr></table></figure><h3><span id="安装蓝牙驱动"> 安装蓝牙驱动</span></h3><p>首先通过下面的命令卸载已安装的蓝牙驱动并且安装新的蓝牙驱动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge blueman bluez-utils bluez bluetooth</span><br><span class="line">sudo apt-get install blueman bluez-utils bluez bluetooth</span><br></pre></td></tr></table></figure><p>然后再启动蓝牙服务</p><p><code>sudo /etc/init.d/bluetooth start</code></p><p>如下图所示，接下来就可以通过Blueman管理系统蓝牙连接了</p><img data-src="/2017/09/15/install-ubuntu-on-alienware/ubuntu_blueman_interface.png" class title="Ubuntu上蓝牙连接管理软件Blueman界面"><h2><span id="进阶配置alienfx"> 进阶配置AlienFx</span></h2><p>Alienware的一大特色就是它有狂野炫酷的灯，更换Ubuntu平台后，一个大问题就是戴尔官方没有Ubuntu平台的AlienFx。</p><p>通过查询，发现有人写了开源版本的AlienFx，只可惜项目已经有好几年无人维护。下载最新版本试用后，不出以外的，该软件并不支持最新的Alienware，该软件支持的Alienware系列可以从<span class="exturl" data-url="aHR0cHM6Ly9kb2MudWJ1bnR1LWZyLm9yZy9hbGllbmZ4">该网站<i class="fa fa-external-link-alt"></i></span>中找到。</p><p>参考资料</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9ydWZ1cy5ha2VvLmllLw==">Rufus Offical Site<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2lsbGVybmV0d29ya2luZy5jb20vZHJpdmVyLWRvd25sb2Fkcy9rbm93bGVkZ2UtYmFzZT92aWV3PXRvcGljJmFtcDtpZD0y">Killer Networking<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy83NzY4MDYvYmx1ZXRvb3RoLW9uLXVidW50dS0xNi0wNA==">Bluetooth on Ubuntu 16.04<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kb2MudWJ1bnR1LWZyLm9yZy9hbGllbmZ4">AlienFx on Ubuntu<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;目录&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#目录&quot;&gt;&lt;/a&gt; 目录&lt;/h2&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%B6%E4%BD%9Cubuntu%E5%90%AF%E5%8A%A8u%E7%9B%98&quot;&gt;制作Ubuntu启动U盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85ubuntu&quot;&gt;安装Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%A7%A3%E5%86%B3%E9%A9%B1%E5%8A%A8%E9%97%AE%E9%A2%98&quot;&gt;解决驱动问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85killer%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8&quot;&gt;安装killer网卡驱动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85%E8%93%9D%E7%89%99%E9%A9%B1%E5%8A%A8&quot;&gt;安装蓝牙驱动&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BF%9B%E9%98%B6%E9%85%8D%E7%BD%AEalienfx&quot;&gt;进阶配置AlienFx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;p&gt;作为一个游戏发烧友，同时也是小白全栈开发程序员我买了Alienware却只用来打游戏是在是太可惜了。为了搞搞开发，昨天配置了一天WSL (Windows Subsystems for Linxu)，用了Hyper+zsh的终端组合。其中在zsh中输入atom能启动windows的Atom也着实把我惊艳了一把，但其实也就算仅限于打开而已。事实是Windows中的文本编辑器并不能直接编辑其子系统中的文件。所以这个子系统在某些方便我觉得还没有Vagrant方便，没有图形界面，意味着不能使用Atom，Visual Studio Code这样代表先进生产力的工具，于是配置WSL搞搞开发的想法就此作罢。&lt;/p&gt;
&lt;p&gt;子系统搞不成，于是有了直接在Ubuntu上工作的想法。其实Alienware上安装Ubuntu不是很难，除了一些蓝牙和Wi-Fi方面的兼容问题，安装过程非常顺利。接下来step by step记录安装过程。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://codingnote.com/categories/Linux/"/>
    
      <category term="折腾" scheme="http://codingnote.com/categories/Linux/%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Ubuntu" scheme="http://codingnote.com/tags/Ubuntu/"/>
    
      <category term="Alienware" scheme="http://codingnote.com/tags/Alienware/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu上安装拼音输入法</title>
    <link href="http://codingnote.com/2017/09/15/install-pinyin-in-Ubuntu/"/>
    <id>http://codingnote.com/2017/09/15/install-pinyin-in-Ubuntu/</id>
    <published>2017-09-15T10:24:56.000Z</published>
    <updated>2020-03-15T10:36:49.506Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>目录</p><!-- toc --><ul><li><a href="#%E5%AE%89%E8%A3%85ibus%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95">安装IBus中文输入法</a></li><li><a href="#%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95">安装搜狗中文输入法</a></li></ul><!-- tocstop --><h3><span id="安装ibus中文输入法"> 安装IBus中文输入法</span></h3>  <img data-src="/2017/09/15/install-pinyin-in-Ubuntu/successfully_installed_pinyin.png" class title="Ubuntu上的拼音输入法"><p>最近又重新安装了Ubuntu系统。因为要写中文博客，没有中文输入法实在是麻烦。在Ubuntu上安装中文输入法确实没有Windows上显而易见，所以写下步骤方便自己将来参考。</p><ol><li><p>首先进入系统设置选择language support，如果没有完整安装该功能，先根据系统提示完成安装</p></li><li><p>点击install/remove language 来安装中文支持</p></li><li><p>接下来在Terminal中手动安装下面任何一个输入法</p><p><code>sudo apt-get install ibus-pinyin</code></p><p><code>sudo apt-get install ibus-sunpinyin</code></p></li><li><p>重启IBus daemon</p><p><code>ibus restart</code></p></li><li><p>再进入系统设置选择Text Entry，点击左下角的小加号并在add input source界面中搜索Chinese，选择一款拼音输入法</p></li></ol>  <img data-src="/2017/09/15/install-pinyin-in-Ubuntu/ubuntu_add_input_method.png" class title="选择Pinyin输入法"><ol start="6"><li>使用吧</li></ol><h3><span id="安装搜狗中文输入法"> 安装搜狗中文输入法</span></h3><p>使用了几天IBus的中文输入发，使用体验简直弱爆了。首先4k屏适配有问题，待选框时刻游离在屏幕之外，然而最致命的是，IBus拼音输入法竟然有切换到双拼就无法再切换回来的bug。早年间我在ubuntu 14上使用过搜狗输入法，用户体验良好，于是试着在ubuntu 16.04上安装。虽然安装步骤比在ubuntu 14上稍稍复杂一些，但是搜狗输入法完美适配4k屏幕而且一如既往的好用。安装步骤如下：</p><a id="more"></a><ol><li><p>搜狗舒服法依赖Fcitx键盘输入法系统而不是IBus，所以安装搜狗输入法前需要确认Fcitx已经安装，若没有安装Fcitx，可以通过terminal</p><p><code>sudo apt-get install fcitx</code></p><p>如果安装过程中需要额外依赖，可以通过以下命令安装</p><p><code>apt-get install -f</code></p></li><li><p>点击<span class="exturl" data-url="aHR0cDovL3Bpbnlpbi5zb2dvdS5jb20vbGludXgv">这里<i class="fa fa-external-link-alt"></i></span>下载搜狗中文输入法，有32bit和64bit安装包可选，ubuntu用户可以选择deb格式安装包用Ubuntu Software Center来安装，当然可以到下载路径下通过以下命令安装</p><p><code>sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb</code></p></li><li><p>安装完毕后，在从当前系统设置/语言支持里选择Fcitx做为键盘输入法系统</p></li><li><p>退出登录，再重新登录</p></li><li><p>现在在系统右上角应该能看到键盘图标，选择设置，添加搜狗中文书法</p></li><li><p>开心的使用吧</p></li></ol><p>参考资料</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy81OTM1Ni9ob3ctZG8taS1nZXQtY2hpbmVzZS1pbnB1dC10by13b3Jr">How do I get Chinese input to work?<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy80NTU2ODIvMTQtMDQtY2hpbmVzZS1pYnVzLWlucHV0LW5vLW9wdGlvbnM=">14.04 Chinese Ibus Input - No Options<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy80NTAyNTUvaW5zdGFsbGluZy1zb2dvdS0lRTYlOTAlOUMlRTclOEIlOTclRTYlOEIlQkMlRTklOUYlQjM=">Installing SOGOU 搜狗拼音<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目录&lt;/p&gt;
&lt;!-- toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85ibus%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95&quot;&gt;安装IBus中文输入法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85%E6%90%9C%E7%8B%97%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95&quot;&gt;安装搜狗中文输入法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- tocstop --&gt;
&lt;h3 id=&quot;安装ibus中文输入法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装ibus中文输入法&quot;&gt;&lt;/a&gt; 安装IBus中文输入法&lt;/h3&gt;
  &lt;img data-src=&quot;/2017/09/15/install-pinyin-in-Ubuntu/successfully_installed_pinyin.png&quot; class=&quot;&quot; title=&quot;Ubuntu上的拼音输入法&quot;&gt;
&lt;p&gt;最近又重新安装了Ubuntu系统。因为要写中文博客，没有中文输入法实在是麻烦。在Ubuntu上安装中文输入法确实没有Windows上显而易见，所以写下步骤方便自己将来参考。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先进入系统设置选择language support，如果没有完整安装该功能，先根据系统提示完成安装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击install/remove language 来安装中文支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接下来在Terminal中手动安装下面任何一个输入法&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install ibus-pinyin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sudo apt-get install ibus-sunpinyin&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启IBus daemon&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ibus restart&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再进入系统设置选择Text Entry，点击左下角的小加号并在add input source界面中搜索Chinese，选择一款拼音输入法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
  &lt;img data-src=&quot;/2017/09/15/install-pinyin-in-Ubuntu/ubuntu_add_input_method.png&quot; class=&quot;&quot; title=&quot;选择Pinyin输入法&quot;&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;使用吧&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;安装搜狗中文输入法&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装搜狗中文输入法&quot;&gt;&lt;/a&gt; 安装搜狗中文输入法&lt;/h3&gt;
&lt;p&gt;使用了几天IBus的中文输入发，使用体验简直弱爆了。首先4k屏适配有问题，待选框时刻游离在屏幕之外，然而最致命的是，IBus拼音输入法竟然有切换到双拼就无法再切换回来的bug。早年间我在ubuntu 14上使用过搜狗输入法，用户体验良好，于是试着在ubuntu 16.04上安装。虽然安装步骤比在ubuntu 14上稍稍复杂一些，但是搜狗输入法完美适配4k屏幕而且一如既往的好用。安装步骤如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://codingnote.com/categories/Linux/"/>
    
      <category term="拼音输入法" scheme="http://codingnote.com/categories/Linux/%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
    
      <category term="pinyin" scheme="http://codingnote.com/tags/pinyin/"/>
    
      <category term="input method" scheme="http://codingnote.com/tags/input-method/"/>
    
  </entry>
  
  <entry>
    <title>Codility PermCheck in Python</title>
    <link href="http://codingnote.com/2017/06/02/codility-perm-check/"/>
    <id>http://codingnote.com/2017/06/02/codility-perm-check/</id>
    <published>2017-06-02T21:25:05.000Z</published>
    <updated>2020-01-04T16:25:40.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析"> 算法复杂度分析</span></h3><table><thead><tr><th>情况</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>O(N)</td><td>O(1)</td></tr><tr><td>平均</td><td>O(N)</td><td>O(1)</td></tr><tr><td>最差</td><td>O(N)</td><td>O(1)</td></tr></tbody></table><p>设输入数组长度为N，最优情况在输入数组的最大值不等于N时达成</p><h3><span id="算法分析"> 算法分析</span></h3><p><strong>permutation</strong> 被定义为长为N的数组，包含整数1到N，且每个整数包含有且仅有一次。根据定义，我们必须遍历完输入数组才能知道是否1到N的每个整数包含有且仅有一次，所以算法复杂度为O(N)且无法继续优化。如何检测输入数组中1到N的每个整数出现有且仅有一次呢？一个比较直观的方法是用一个长度为N的数组作标记，遍历输入数组并在标记数组的对应项作标记，一旦该标记数组所有项均被标记，则说明输入数组满足permutation定义。但是该方法有一个缺点，就是需要成比例于输入数组长度N的存储空间。有没有不需要额外存储空间的算法呢？答案当然是有的，技巧在于利用输入数组，在遍历输入数组的同时，利用输入数组做标记。由于输入数组各项均为正整数，我们可以将某一项置为负值来标记该项索引+1对应的正整数出现过一次。</p><h3><span id="源代码"> 源代码</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(A)):</span><br><span class="line">        index = A[i] <span class="keyword">if</span> A[i] &gt; <span class="number">0</span> <span class="keyword">else</span> -A[i]</span><br><span class="line">        <span class="keyword">if</span> index &gt; <span class="built_in">len</span>(A) <span class="keyword">or</span> A[index - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[index - <span class="number">1</span>] = -A[index - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3&gt;&lt;span id=&quot;算法复杂度分析&quot;&gt; 算法复杂度分析&lt;/span&gt;&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="http://codingnote.com/categories/Notes/"/>
    
      <category term="Codility" scheme="http://codingnote.com/categories/Notes/Codility/"/>
    
    
      <category term="Codility" scheme="http://codingnote.com/tags/Codility/"/>
    
      <category term="Python" scheme="http://codingnote.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Codility MissingInteger in Python</title>
    <link href="http://codingnote.com/2017/06/02/codility-missing-integer/"/>
    <id>http://codingnote.com/2017/06/02/codility-missing-integer/</id>
    <published>2017-06-02T21:24:55.000Z</published>
    <updated>2020-01-04T16:25:40.604Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析"> 算法复杂度分析</span></h3><table><thead><tr><th>情况</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>O(N)</td><td>O(1)</td></tr><tr><td>平均</td><td>O(N)</td><td>O(1)</td></tr><tr><td>最差</td><td>O(N)</td><td>O(1)</td></tr></tbody></table><h3><span id="算法分析"> 算法分析</span></h3><p>创建检查数组check，遍历数组A的项，若某项的值为整数x，则以整数x作为索引，将check数组对应的项置1。在遍历check数组，寻找值为0时索引的最小值。</p><h3><span id="源代码"> 源代码</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    n=<span class="built_in">len</span>(A)</span><br><span class="line">    max_A=<span class="number">100001</span></span><br><span class="line">    check=[<span class="number">0</span>]*(max_A+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> A[i]&lt;max_A <span class="keyword">and</span> check[A[i]-<span class="number">1</span>]==<span class="number">0</span>):</span><br><span class="line">            check[A[i]-<span class="number">1</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> xrange(max_A+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(check[ind]==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> ind+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3&gt;&lt;span id=&quot;算法复杂度分析&quot;&gt; 算法复杂度分析&lt;/span&gt;&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="http://codingnote.com/categories/Notes/"/>
    
      <category term="Codility" scheme="http://codingnote.com/categories/Notes/Codility/"/>
    
    
      <category term="Codility" scheme="http://codingnote.com/tags/Codility/"/>
    
      <category term="Python" scheme="http://codingnote.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Codility Maxcountersers in Python</title>
    <link href="http://codingnote.com/2017/06/02/codility-max-counters/"/>
    <id>http://codingnote.com/2017/06/02/codility-max-counters/</id>
    <published>2017-06-02T21:24:33.000Z</published>
    <updated>2020-01-04T16:25:40.603Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析"> 算法复杂度分析</span></h3><table><thead><tr><th>情况</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>O(N+M)</td><td>O(N)</td></tr><tr><td>平均</td><td>O(N+M)</td><td>O(N)</td></tr><tr><td>最差</td><td>O(N+M)</td><td>O(N)</td></tr></tbody></table><h3><span id="算法分析"> 算法分析</span></h3><p>若要达到最差情况下的时间复杂度为O(N+M)，那就意味着不能在<code>A[K] = N + 1</code>时依次将每个<code>counter</code>的值置为当前<code>counters</code>数组的最大值。因为max counter操作的复杂度为O(N)且需要嵌套在复杂度为O(M)的循环中，这样算法的复杂度至少为O(NM)。也就以为着当<code>A[K] = N + 1</code>时，我们不能立即执行max counter操作。借用下惰性求值的概念，只有在真的需要某个<code>counter</code>值的情况的下才执行计算。这就需要建立两个变量，<code>max_A</code>记录当前<code>counters</code>的最大值，<code>lastUpdate</code>记录上一次执行max counter操作时<code>max_A</code>的值。这样只有当<code>A[K] = N + 1</code>时，才把<code>max_A</code>的值赋值给<code>lastUpdate</code>。而当<code>A[i] &lt; N+1</code>时，则要根据<code>lastUpdate</code>的值来更新<code>counter</code>和<code>max_A</code>的值。</p><p>最后在返回所<code>counters</code>数组值之前，需要根据<code>lastUpdate</code>的值对每个counter的值进行计算</p><h3><span id="源代码"> 源代码</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">N, A</span>):</span></span><br><span class="line">    <span class="comment"># each element of array A is an integer within the range [1..N + 1]</span></span><br><span class="line">    <span class="comment"># N and M are integers within the range [1..100,000]</span></span><br><span class="line">    M = <span class="built_in">len</span>(A)</span><br><span class="line">    max_A = <span class="number">0</span></span><br><span class="line">    lastUpdate = <span class="number">0</span></span><br><span class="line">    counters=[<span class="number">0</span>]*N</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(M):</span><br><span class="line">        <span class="keyword">if</span> (A[i]==N+<span class="number">1</span>):</span><br><span class="line">            lastUpdate = max_A</span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (counters[A[i]-<span class="number">1</span>]&lt;lastUpdate):</span><br><span class="line">                counters[A[i]-<span class="number">1</span>]=lastUpdate+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (counters[A[i]-<span class="number">1</span>]&gt;max_A):</span><br><span class="line">                    max_A=counters[A[i]-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counters[A[i]-<span class="number">1</span>]=counters[A[i]-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (counters[A[i]-<span class="number">1</span>]&gt;max_A):</span><br><span class="line">                    max_A=counters[A[i]-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">if</span> (counters[j]&lt;lastUpdate):</span><br><span class="line">            counters[j]=lastUpdate</span><br><span class="line">    <span class="keyword">return</span> counters</span><br><span class="line"><span class="comment">#  time complexity: O(N + M)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3&gt;&lt;span id=&quot;算法复杂度分析&quot;&gt; 算法复杂度分析&lt;/span&gt;&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="http://codingnote.com/categories/Notes/"/>
    
      <category term="Codility" scheme="http://codingnote.com/categories/Notes/Codility/"/>
    
    
      <category term="Codility" scheme="http://codingnote.com/tags/Codility/"/>
    
      <category term="Python" scheme="http://codingnote.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Codility FrogRiverOne in Python</title>
    <link href="http://codingnote.com/2017/06/02/codility-frog-river-one/"/>
    <id>http://codingnote.com/2017/06/02/codility-frog-river-one/</id>
    <published>2017-06-02T21:24:19.000Z</published>
    <updated>2020-01-04T16:25:40.602Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析"> 算法复杂度分析</span></h3><table><thead><tr><th>情况</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>最优</td><td>O(1)</td><td>O(1)</td></tr><tr><td>平均</td><td>O(N)</td><td>O(X)</td></tr><tr><td>最差</td><td>O(N)</td><td>O(X)</td></tr></tbody></table><p>最优情况在输入数组长度小于河宽X下达成</p><h3><span id="算法分析"> 算法分析</span></h3><p>依次读取输入数组的项，当读取过的项的集合包含1到X在内的所有整数时，输出当前项的数组索引。对于记录读取过的项的集合，可以用一个长度为X+1的<code>check</code>数组来记录。若读取了整数z，就把整数z作为索引，将对应的项置1。对于判断读取过的项的集合是否包含1到X在内的所有整数，我们都可以遍历<code>check</code>数组，检查索引1到X对应的项是否全部为1，如果不是，则说明我们还没有包含1到X在内的所有整数。但是这样，该判断算法需要遍历<code>check</code>数组，复杂度为O(X)。不过有一个小技巧可以将该判断算法降为O(1)，那就是在<code>check</code>数组的基础上，再使用step_left变量来记录还需要读取多少个不同的整数后读取过的项的集合才能包含1到X在内的所有整数。若读取了整数z，除了把整数z作为索引，将对应的项置1外，还要根据条件来更新<code>step_left</code>的值。此时，检查算法只需要判断<code>step_left</code>是否为0即可得知读取过的项的集合是否包含1到X在内的所有整数了。</p><h3><span id="源代码"> 源代码</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">X, A</span>):</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    n = <span class="built_in">len</span>(A)</span><br><span class="line">    <span class="keyword">if</span> (n &lt; X):</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    step_left = X</span><br><span class="line">    check = [<span class="number">0</span>]*(X+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        <span class="keyword">if</span> (check[A[i]]==<span class="number">0</span>):</span><br><span class="line">            check[A[i]]=<span class="number">1</span></span><br><span class="line">            step_left -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (step_left==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h3&gt;&lt;span id=&quot;算法复杂度分析&quot;&gt; 算法复杂度分析&lt;/span&gt;&lt;/h
      
    
    </summary>
    
      <category term="Notes" scheme="http://codingnote.com/categories/Notes/"/>
    
      <category term="Codility" scheme="http://codingnote.com/categories/Notes/Codility/"/>
    
    
      <category term="Codility" scheme="http://codingnote.com/tags/Codility/"/>
    
      <category term="Python" scheme="http://codingnote.com/tags/Python/"/>
    
  </entry>
  
</feed>
