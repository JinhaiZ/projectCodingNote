<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2020年 再看开闭原则</title>
    <url>/2020/03/10/revisit-open-closed-principle/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#午餐时的争吵">午餐时的争吵</a></li>
<li><a href="#经验法则与惯例">经验法则与惯例</a></li>
<li><a href="#重温开闭原则">重温开闭原则</a></li>
<li><a href="#拓展阅读">拓展阅读</a></li>
</ul>
<!-- tocstop -->
<h1><span id="午餐时的争吵">午餐时的争吵</span></h1><p>今天中午我偶然路过二楼的厨房，听到同事们边吃午饭边争论着什么。我好奇的前去观摩，原来是在代码评审上有了分歧。</p>
<p>第一个同事说这个代码虽然能满足现在的需求，但是却不易于向某个他描述的方向拓展，他言之凿凿，认为我们的软件不久就会有他描述的需求。与其等到新需求到来时在对软件进行改动，不如开始实现时就考虑到可能的拓展，让这个模块变得灵活以适应将来的需求。</p>
<p>而另一位同事则不为所动，觉得YAGNI（You aren’t gonna need it）。就算我们真的要满足第一个同事所描述的需求，但是根据他的判断那也是很长时间（一年）之后的事了。如果现在就把模块变得易于拓展，那么无疑会增加代码的抽象层次，本来一个类就可以实现的功能，现在要多实现几个类。</p>
<p>第三位同事也加入了讨论。把软件设计的灵活以适应将来的变化是一件好事，但是这么做也是有代价的。灵活意味着这个模块需要更高的抽象层次，在新的需求到来前，这个模块都需要保持它本不需要的抽象层次。况且现在我们假设对于需求的预测是正确的，假如需求根本不是我们想象的那样变化，那么现在的努力不就白费了吗？</p>
<p>第一位同事似乎没有被说服，另外两位同事也各执已见。午饭结束，大家各自回到工位上继续搬砖了。</p>
<p>虽然这次争论还没有结果，也还不知道谁对谁错。那么我们在实现某个模块时，究竟是只实现现有需求还是要考虑到将来的需求而将模块实现的灵活一点呢？</p>
<a id="more"></a>
<h1><span id="经验法则与惯例">经验法则与惯例</span></h1><p>面向对象程序设计至今已至少经存在了50年了（如果我们从1970年的Smalltalk语言开始算起，如果从1960年的Simula 67语言开始算起，那么时间会更长），我们现在遇到的各种问题，前人也几乎都遇到过了。这也是为什么面向对象程序设计会有如此多的模式（Pattern），甚至是名言警句（Maxim）。</p>
<p>如果问一位极限编程（extreme programming，XP）的专家，他会说</p>
<blockquote>
<p>YAGNI（You aren’t gonna need it），一个程序员不应该为软件增加不必要的功能</p>
</blockquote>
<p>SOLID主义者会说</p>
<blockquote>
<p>我们应该遵守开闭原则（The Open-Closed Principle），软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的</p>
</blockquote>
<p>而不久前Java大师Bruce Eckel恰巧在他的<span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJ1Y2VlY2tlbC5jb20vYmxvZy8yMDE5LTEyLTI0LXVuc3Bva2VuLWFzc3VtcHRpb25zLXVuZGVybHlpbmctb28tZGVzaWduLW1heGltcy8jZGlzcXVzX3RocmVhZA==" title="https://www.bruceeckel.com/blog/2019-12-24-unspoken-assumptions-underlying-oo-design-maxims/#disqus_thread">博客<i class="fa fa-external-link"></i></span>中写道</p>
<blockquote>
<p>质疑抽象的合理性，在不使用教条的情况下如果不能解释抽象的合理性，就不要抽象</p>
</blockquote>
<p><em>原文是</em></p>
<blockquote>
<p><em>Question your abstractions. If you can’t justify it (without quoting a maxim), take it out.</em></p>
</blockquote>
<p>但是不论是YAGNI还是SOLID，这些经验法则都是有适用条件的。在不同情况下，急切地套用这些法则还不如不去了解他们。在1988年Bertrand Meyer提出开闭法则32年后的今天，我们真的了解什么是开闭法则吗（The Open-Closed Principal）？</p>
<h1><span id="重温开闭原则">重温开闭原则</span></h1><blockquote><p>软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
<footer><strong>Bertrand Meyer</strong><cite>Object-Oriented Software Construction. Prentice Hall. 1988</cite></footer></blockquote>
<p>开闭原则说了两件事</p>
<ul>
<li><p>软件中的对象应该对于扩展是开放的</p>
<p>对象的行为可以被拓展，也就是说新的需求来临时，我们可以改变对象的行为以满足新的需求</p>
</li>
<li><p>软件中的对象应该对于修改是封闭的</p>
<p>实现原有需求的的源代码不应该被修改</p>
</li>
</ul>
<p>难道这两句话不矛盾吗？如果我们不修改源代码怎么拓展对象原有的行为？难道有不写代码就满足需求的魔法吗？当然，不写代码时不肯能的。但是不修改原先的代码，而在软件的某一处增加代码来拓展对象的行为确实有可能的。</p>
<blockquote><p>抽象是解决问题的关键</p>
<footer><strong>Robert C. Martin</strong><cite>The Open-Close Principal</cite></footer></blockquote>
<p>Robert C. Martin 拿了C++写了一个关于在GUI打印形状的例子。比如我们现在有在GUI上打印方块和圆的需求，熟悉过程式编程人会实现类似于下面的程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosedPrincipal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        Point center;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> side;</span><br><span class="line">        Point topLeft;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawCircle</span><span class="params">(<span class="keyword">final</span> Circle circle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现略去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawSquare</span><span class="params">(<span class="keyword">final</span> Square square)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现略去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawAllShapes</span><span class="params">(<span class="keyword">final</span> List&lt;Object&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Object shape : shapes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Circle) &#123;</span><br><span class="line">                DrawCircle((Circle) shape);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shape <span class="keyword">instanceof</span> Square) &#123;</span><br><span class="line">                DrawSquare((Square) shape);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我拿了Java重写了Robert C. Martin 当年拿C++语言写的例子。所以上面有很多地方看起来都很奇怪，但是暴露的问题是一样的。假如不久之后我们有了新的需求，需要打印菱形，那么我们不可避免的需要修改<code>DrawAllShapes</code>方法。但是假如我们利用接口进行抽象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenClosedPrincipal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> radius;</span><br><span class="line">        Point center;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 实现略去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> side;</span><br><span class="line">        Point topLeft;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 实现略去</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">drawAllShapes</span><span class="params">(<span class="keyword">final</span> List&lt;Shape&gt; shapes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">final</span> Shape shape : shapes) &#123;</span><br><span class="line">            shape.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里抽象出<code>Shape</code>接口并定义<code>draw()</code>方法，让不同的具体类去实现<code>draw()</code>方法。这样当打印新的形状的需求出现时我们就不需要修改 <code>DrawAllShapes</code>方法了。这样就符合了开闭原则</p>
<ul>
<li>若需要打印新的形状只需要实现新的类，新的类的实现与原先的各种实现是解耦的，并不需要修改原先的实现</li>
<li><code>drawAllShapes()</code> 没有改变</li>
</ul>
<p>但是就好像老鼠团队开大会，谁去给猫挂铃铛的故事一样。开闭法则听起来诱人，可是又有谁知道一个软件里哪个模块，类应该关闭，哪个模块，类应该开放呢？假如新的需求不是打印新的形状而是先打印圆形再打印方形呢？那么上面的例子就不再试用了。可能会有人说，那么我在实现 <code>drawAllShapes()</code>就考虑到打印顺序的需求，再去要求每个形状实现 <code>Comparable&lt;Shape&gt;</code>接口就好了。哈哈，，今天有打印顺序的需求，明天又你想象不到的需求呢？只可惜软件开放工程师并不是预言家，要是软件开放工程师能准确语言客户的需求，那么现在软件开放领域也不会有那么多问题了。</p>
<p>这就是开闭原则的陷阱，它要求使用者有非比寻常的见解。但是没有个十年软件开放经验，又怎么能获得寻常的见解呢？</p>
<h1><span id="拓展阅读">拓展阅读</span></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW5mb3dsZXIuY29tL2JsaWtpL1lhZ25pLmh0bWw=" title="https://martinfowler.com/bliki/Yagni.html">Yagni, Martin Fowler<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTUwOTA1MDgxMTA1L2h0dHA6Ly93d3cub2JqZWN0bWVudG9yLmNvbS9yZXNvdXJjZXMvYXJ0aWNsZXMvb2NwLnBkZg==" title="https://web.archive.org/web/20150905081105/http://www.objectmentor.com/resources/articles/ocp.pdf">The Open-Closed Principle, Robert C. Martin<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYnJ1Y2VlY2tlbC5jb20vYmxvZy8yMDE5LTEyLTI0LXVuc3Bva2VuLWFzc3VtcHRpb25zLXVuZGVybHlpbmctb28tZGVzaWduLW1heGltcy8jZGlzcXVzX3RocmVhZA==" title="https://www.bruceeckel.com/blog/2019-12-24-unspoken-assumptions-underlying-oo-design-maxims/#disqus_thread">Unspoken Assumptions Underlying OO Design Maxims<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>开闭原则</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>经验法则</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的协变，逆变与不变</title>
    <url>/2020/03/08/java-covariant-contravariant-invariant/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#协变逆变与不变的定义">协变，逆变与不变的定义</a></li>
<li><a href="#java上限通配符实现协变">Java上限通配符实现协变</a></li>
<li><a href="#java下限通配符实现逆变">Java下限通配符实现逆变</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<p>在Java里，如果我们创建了<code>Integer</code>类和<code>Number</code>类，并且<code>Integer</code>是<code>Number</code>的子类。那么<code>List&lt;Integer&gt;</code>类也是<code>List&lt;Number&gt;</code>类的子类吗？</p>
<p>我们可以写一段代码来找到这个问题的答案。现在我们有一个求<code>List&lt;Number&gt;</code>类最大值的方法，它的输入是<code>List&lt;Number&gt;</code>类的实例。若<code>List&lt;Integer&gt;</code>类也是<code>List&lt;Number&gt;</code>类的子类，那么下面的代码应该是合法的。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvariantExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(List&lt;Number&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; integerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Number max = max(integerList); <span class="comment">// 编译错误 incompatible types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是编译器告诉我们<code>incompatible types</code>错误，这里<code>max</code>方法期待一个<code>List&lt;Number&gt;</code>类作为输入，但是实际上获得的是<code>List&lt;Integer&gt;</code>类。这就告诉我们，即便<code>Integer</code>是<code>Number</code>的子类，编译器也认为<code>List&lt;Integer&gt;</code>类和<code>List&lt;Number&gt;</code>类是没有关系的。</p>
<p><strong>结论</strong>：<em>对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>，不论它们之间具有什么关系，<code>List&lt;Type1&gt;</code> 和 <code>List&lt;Type2&gt;</code>都是没有关系的。</em></p>
<p>如果我们把上述结论推广，可以得到更一般性的结论</p>
<p><em>对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>，不论它们之间具有什么关系，给定泛型类 <code>G&lt;T&gt;</code>， <code>G&lt;Type1&gt;</code> 和 <code>G&lt;Type2&gt;</code>都是没有关系的。</em></p>
<p>上面的结论可以用一句话概括：</p>
<blockquote>
<p>Java的泛型是<strong>不可变的（Invariant）</strong></p>
</blockquote>
<h1><span id="协变逆变与不变的定义">协变，逆变与不变的定义</span></h1><p>在一门程序设计语言的类型系统中，给定</p>
<ul>
<li><code>&lt;=</code> 和<code>&gt;=</code>， 表示<strong>类型排序关系</strong><ul>
<li><code>Type1&lt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的子类型</li>
<li><code>Type1&gt;=Type2</code>表示<code>Type1</code>是 <code>Type2</code>的超类型</li>
</ul>
</li>
<li><code>f()</code> 表示一个<strong>类型的构造函数</strong><ul>
<li>注意它可以是一元函数（接受一个参数），如<code>NewType = f(Type)</code></li>
<li>也可以是多元函数（接受多个参数），如<code>NewType = f(Type1, Type2)</code></li>
</ul>
</li>
</ul>
<p>那么，对于任意两个不同的类型<code>Type1</code> 和 <code>Type2</code>, 这个类型的构造函数<code>f()</code>可以是</p>
<table>
<thead>
<tr>
<th style="text-align:left">变型（Variance）</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">协变的（covariant）</td>
<td style="text-align:left">当且仅当它保持了类型排序关系</td>
<td style="text-align:left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&lt;=f(Type2)</code></td>
</tr>
<tr>
<td style="text-align:left">逆变的（contravariant）</td>
<td style="text-align:left">当且仅当它逆转了类型排序关系</td>
<td style="text-align:left">如果<code>Type1&lt;=Type2</code>，那么<code>f(Type1)&gt;=f(Type2)</code></td>
</tr>
<tr>
<td style="text-align:left">不变的（invariant or nonvariant）</td>
<td style="text-align:left">既不保持也不逆转类型排序关系</td>
<td style="text-align:left">不论<code>Type1</code> 和 <code>Type2</code>的关系，<code>f(Type1)</code> 和<code>f(Type2)</code> 没有关系</td>
</tr>
</tbody>
</table>
<p><em>以上定义来自 <span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ292YXJpYW5jZV9hbmRfY29udHJhdmFyaWFuY2VfKGNvbXB1dGVyX3NjaWVuY2Up" title="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">Covariance and contravariance, Wikipedia<i class="fa fa-external-link"></i></span>，其中还有双变的（bivariant），但是不在本文的讨论范围，顾略去</em></p>
<p><em>在 C#中，子类型也称为派生类（Derived class），超类型也称为基类（Base class）</em></p>
<p>不同的程序设计语言，需要在类型推断的安全性和语法的易用性上做出权衡，对不同的类型构造函数进行规约，以使其符合某一种<strong>变型（Variance）</strong>。<br>不同的程序设计语言，在支持变型时，也有不同的处理方式。例如C#只允许在接口类型上标记变型,，而Java则在通过<a href="./2020/03/03/java-generics/#有限通配符">通配符</a>来支持变型。</p>
<h1><span id="java上限通配符实现协变">Java上限通配符实现协变</span></h1><p>继续最初的例子，<code>Integer</code>是<code>Number</code>的子类，怎么样才能让<code>Number max(List&lt;Number&gt; list)max</code>方法也接受<code>List&lt;Integer&gt;</code>呢？（这里<code>List&lt;T&gt;</code>是类型构造函数，<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code> 两个新的类型）虽然在Java中，泛型是不可变的（<code>List&lt;Integer&gt;</code> 和 <code>List&lt;Number&gt;</code>没有关系），但是Java可以通过使用<a href="./2020/03/03/java-generics/#上限通配符">上限通配符</a>来实现协变。</p>
<p>修改后的<code>max</code>方法签名如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(List&lt;? extends Number&gt; list)</span></span></span><br></pre></td></tr></table></figure>
<p><code>? extends Number</code> 表示接受<code>Number</code>类型和<code>Number</code>类型的子类型。这样<code>max</code>方法能够接受比原始指定的类型（这里是<code>Number</code>类型）更具体的类型。</p>
<h1><span id="java下限通配符实现逆变">Java下限通配符实现逆变</span></h1><p>思考下面的例子，<code>Integer</code>是<code>Number</code>的子类，方法<code>generateIntegers</code>生成<code>List&lt;Integer&gt;</code> 并放入到输入参数<code>output</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContravariantExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Integer</span> <span class="keyword">extends</span> <span class="title">Number</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; output)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// 省略实现细节</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;Number&gt; numberList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        generateIntegers(numberList); <span class="comment">// 编译错误 incompatible types</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于Java泛型的不可变性，<code>generateIntegers()</code> 生成的<code>List&lt;Integer&gt;</code>不能放到输入参数<code>output</code>指定的<code>List&lt;Number&gt;</code>中。那么有没有办法把 <code>List&lt;Integer&gt;</code> 放到<code>List&lt;Number&gt;</code>中呢？</p>
<p>这里使用<a href="./2020/03/03/java-generics/#下限通配符">下限通配符</a>来实现逆变。</p>
<p>修改后的<code>generateIntegers</code>函数签名如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateIntegers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; output)</span></span></span><br></pre></td></tr></table></figure>
<p><code>&lt;? super Integer</code> 表示接受<code>Integer</code>类型和<code>Integer</code>类型的超类型。这样<code>generateIntegers</code>方法就能接受比原始指定类型（这里是<code>Integer</code>类型）更泛化（更不具体）的类型。</p>
<h1><span id="总结">总结</span></h1><p>如果<code>Integer</code>类是<code>Number</code>类的子类型</p>
<table>
<thead>
<tr>
<th style="text-align:left">变型（Variance）</th>
<th style="text-align:left">通配符</th>
<th style="text-align:left">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">协变的（covariant）</td>
<td style="text-align:left">上限通配符 <code>? extends T</code></td>
<td style="text-align:left"><code>List&lt;? extends Number&gt;</code> 接受比原始指定类型<code>Number</code>更具体的类型</td>
</tr>
<tr>
<td style="text-align:left">逆变的（contravariant）</td>
<td style="text-align:left">下限通配符 <code>? super T</code></td>
<td style="text-align:left"><code>List&lt;? super Integer&gt;</code> 接受比原始指定类型<code>Integer</code>更泛化的类型</td>
</tr>
<tr>
<td style="text-align:left">不变的（invariant or nonvariant）</td>
<td style="text-align:left">泛型默认不可变</td>
<td style="text-align:left"><code>List&lt;Integer&gt;</code> 和<code>List&lt;Number&gt;</code> 没关系</td>
</tr>
</tbody>
</table>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ292YXJpYW5jZV9hbmRfY29udHJhdmFyaWFuY2VfKGNvbXB1dGVyX3NjaWVuY2U=" title="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science">Covariance and contravariance, Wikipedia<i class="fa fa-external-link"></i></span>)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vemgtY24vZG90bmV0L3N0YW5kYXJkL2dlbmVyaWNzL2NvdmFyaWFuY2UtYW5kLWNvbnRyYXZhcmlhbmNl" title="https://docs.microsoft.com/zh-cn/dotnet/standard/generics/covariance-and-contravariance">泛型中的协变和逆变, Microsoft .NET指南<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9FZmZlY3RpdmUtSmF2YS1Kb3NodWEtQmxvY2gvZHAvMDEzNDY4NTk5Nw==" title="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997">Effective Java 3rd Edition，Joshua Bloch<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Java 泛型</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 泛型</title>
    <url>/2020/03/03/java-generics/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#java-泛型">Java 泛型</a><ul>
<li><a href="#我们为什么需要泛型">我们为什么需要泛型</a></li>
</ul>
</li>
<li><a href="#有限通配符">有限通配符</a><ul>
<li><a href="#下限通配符">下限通配符</a></li>
<li><a href="#上限通配符">上限通配符</a></li>
</ul>
</li>
<li><a href="#无限通配符">无限通配符</a></li>
<li><a href="#总结">总结</a></li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- tocstop -->
<h1><span id="java-泛型">Java 泛型</span></h1><h2><span id="我们为什么需要泛型">我们为什么需要泛型</span></h2><p>自从Java SE 1.5引入<strong>泛型（Generics）</strong> 之前，Java程序员想要写出通用的代码有点难度。比如想要得到Java某个集合（<code>Collection</code>）的最大值，在没有泛型的情况下，我们需要针对每个特定类型去写特定的求最大值方法。</p>
<p>比如针对<code>Number</code>集合我们需要实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">max</span><span class="params">(NumberCollection coll, NumberComparator comp)</span></span></span><br></pre></td></tr></table></figure>
<p>针对<code>Integer</code>集合我们需要实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">max</span><span class="params">(IntegerCollection coll, IntegerComparator comp)</span></span></span><br></pre></td></tr></table></figure>
<p>显而易见，这样实现起来是非常没有效率的。我们需要为每个不同的类型实现重复的逻辑，重复在编程中是非常罪恶的。当然，为了减少重复，我们也可以有这样的实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">max</span><span class="params">(ObjectCollection coll, ObjectComparator comp)</span></span></span><br></pre></td></tr></table></figure>
<p>因为Java所有的类都是<code>Object</code>的子类。当然这样实现的坏处就是需要做<strong>对象转型(Casting)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer maxInterger = (Integer) max(coll, comp)</span><br></pre></td></tr></table></figure>
<p>然而对象转型也是非常罪恶的，因为一旦错误地使用了对象转型，代码只有到<strong>运行阶段（runtime）</strong> 才会报错。所以我们要尽可能的避免对象转型。</p>
<p>而有了泛型以后，我们只需要实现<br><a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;T&gt; comp)</span></span></span><br></pre></td></tr></table></figure>
<p>其中<code>T</code>叫做<strong>类型参数（Type paramter）</strong>，如果一个<strong>类（Class）</strong>，一个<strong>接口（Interface）</strong> 或者一个<strong>方法（Method）</strong> 在<strong>定义时（declaration）</strong>有一个或者多个类型参数，那么我们就叫他们<strong>泛型类（Generic class）</strong>，<strong>泛型接口（Generic interface）</strong> 和<strong>泛型方法（Generic method）</strong>。而泛型类，泛型接口和泛型方法就被统称为<strong>泛型（Generic types， Generics）</strong>。</p>
<p>定义时，泛型是由类，接口和方法名跟着一个由尖括号包围的<strong>参数化类型（Parameterized types）</strong> 组成的。例如</p>
<ul>
<li><code>ArrayList&lt;E&gt;</code> ArrayList类有一个类型参数，E，它表示元素类型。读作元素E的ArrayList。</li>
<li><code>Map&lt;K, V&gt;</code> Map接口有两个类型参数，K，V，分别表示键和值的类型，读作K到V的映射。</li>
<li><code>T max(Collection&lt;T&gt; coll)</code> max方法有一个类型参数，T，表示对象类型，这个不太好读。</li>
</ul>
<p>使用时，我们用<strong>实际类型参数（Actual type paramter）</strong> 替换类型参数，比如<code>ArrayList&lt;String&gt;</code> 就代表一个元素为<code>String</code>的<code>ArrayList</code>。其中类型参数<code>E</code>被实际类型参数<code>String</code>替代了。</p>
<p><em>在英语里Generic有通用的含义，这也揭示了Java泛型的本质：<strong>让类，接口和方法变得更加通用</strong></em></p>
<h1><span id="有限通配符">有限通配符</span></h1><p><strong>有限通配符（Bounded Wildcards）</strong> 是Java<strong>泛型（Java Generics）</strong> 里的概念，这里的有限不是和无限对应的，而是有上限和下限的意思。所以有限通配符又分为<code>下限通配符</code>和<code>上限通配符</code>。在一些翻译中，Bounded Wildcards也被翻译为有界通配符，相应的，有界通配符又分为<code>下界通配符</code>和<code>上界通配符</code>。</p>
<h2><span id="下限通配符">下限通配符</span></h2><p>上面说到有了泛型以后，我们只需要实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;T&gt; comp)</span></span></span><br></pre></td></tr></table></figure>
<p>便可以对任意类型的数据求最大值，但是上面的<strong>方法签名（method signature）</strong> 也有一些限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection&lt;Integer&gt; intergerColl = ...;</span><br><span class="line">Comparator&lt;Number&gt; numberComp = ...;</span><br><span class="line">Collections.max(intergerColl, numberComp); <span class="comment">// 编译出错</span></span><br></pre></td></tr></table></figure>
<p>我们知道<code>Number</code>是<code>Integer</code>是的<strong>超类（Super type）</strong>，每一个<code>Intger</code>类也是<code>Number</code>类，所以<code>Number</code>类的比较器应该可以用于比较<code>Integer</code>类。</p>
<p>然而上面的代码会在<strong>编译阶段（Compile time）出错</strong>，这是因为类型参数<code>T</code>限制了我们只能使用<code>Integer</code>类的比较器。在这里，限制比较器的类型和集合类型完全一样是没有必要的。其实我们可以放宽限制，只要比较器类型是集合类型T的超类型就可以了。这样，我们可以让求最大值方法变得更通用。修改后的函数签名如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">max</span><span class="params">(Collection&lt;T&gt; coll, Comparator&lt;? <span class="keyword">super</span> T&gt; comp)</span></span></span><br></pre></td></tr></table></figure>
<p>这里<code>?</code>就是通配符（Wildcard），<code>? super T</code>就是<strong>下限通配符（Lower Bounded Wildcards）</strong>。它表示某个类<code>?</code>是<code>T</code>的超类。</p>
<p>这样我们在这里使用Number类的比较器来比较Integer集合了。</p>
<p>下限通配符<code>? super T</code>中，<code>T</code>是表示下限类型，它既可以是一个类型参数，也可以是一个实际类型参数。</p>
<ul>
<li><code>Comparator&lt;? super T&gt;</code> 类型参数</li>
<li><code>Comparator&lt;? super Integer&gt;</code> 实际类型参数</li>
</ul>
<p>至于为什么叫做下限，我们可以这么类比。族谱里爸爸在上面，儿子在下面。下限通配符以某个类型的子类型为下限，它匹配包括这个子类型的所有超类型。</p>
<h2><span id="上限通配符">上限通配符</span></h2><p>通过上限通配符，我们把求最大值方法变得通用了。试想限制我们想要实现一个Number集合累加，可以有如下的函数签名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">sum</span><span class="params">(Collection&lt;Number&gt; inputs)</span></span></span><br></pre></td></tr></table></figure>
<p>但是它只能用于累加Number，如果我们也想累加Number的子类Double，Integer呢，可以使用具有实际类型的上限通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">sum</span><span class="params">(Collection&lt;? extends Number&gt; inputs)</span></span></span><br></pre></td></tr></table></figure>
<p>这样我们就可以累加Double，Intger类型的集合了。</p>
<p>这里<code>? extends T</code>就是<strong>上限通配符（Upper Bounded Wildcards）</strong>。它表示某个类<code>?</code>是<code>T</code>的子类。</p>
<h1><span id="无限通配符">无限通配符</span></h1><p>无限通配符（Unbounded Wildcards）里的无限不是和有限对应的无限，而没有上下限的意思。有时，无限通配符（Unbounded Wildcards）也会被翻译为无界通配符。他们指代的都是同一个概念。</p>
<p>无限通配符记作<code>?</code>, 表示<strong>未知类型（unknown type）</strong>。 比如<code>List&lt;?&gt;</code>, 表示类型未知的List。</p>
<p>试想我们实现了如下在List中交换元素的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;E&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于使用了泛型，上面的方法可以应用于不同类型的List。但是我们也可以看到，在实现这个方法的过程中，我们没有使用基于类型参数E的任何信息。在这种情况下，我们可以用无限通配符代替类型参数E</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以总结出这样的经验法则，如何类型参数只在方法声明中出现，我们就可以用通配符来代替。</p>
<h1><span id="总结">总结</span></h1><p>Java通过让类，接口和方法在定义时有一个类型参数的形式让代码变得更加通用（泛化），这个就叫做泛型。由于Java泛型也有一些限制，这里没有阐明技术原因（技术原因请参考<a href="./2020/03/08/java-covariant-contravariant-invariant/">Java的协变，逆变与不变</a>），仅从几个把代码变得更通用得需求出发，引入通配符<code>?</code>的概念。</p>
<p>通配符在Java里三种形式，分别是</p>
<ul>
<li>下限通配符，<code>&lt;? super LowerBoundedClass&gt;</code>，通配<code>LowerBoundedClass</code>和它的超类。也可以用类型参数代替实际类型，<code>&lt;? super T&gt;</code></li>
<li>上限通配符， <code>&lt;? extends UpperBoundedClass&gt;</code> 统配<code>UpperBoundedClass</code>和它的子类。也可以用类型参数代替实际类型，<code>&lt;? extends T&gt;</code></li>
<li>无限通配符， <code>?</code> 通配任意类型</li>
</ul>
<p>关于通配符上下限的说法，来自于<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvZ2VuZXJpY3MvaW5kZXguaHRtbA==" title="https://docs.oracle.com/javase/tutorial/java/generics/index.html">ORACLE关于泛型的官方文档<i class="fa fa-external-link"></i></span>，以及<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2V4dHJhL2dlbmVyaWNzL2luZGV4Lmh0bWw=" title="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">Gilad Bracha关于泛型的教程<i class="fa fa-external-link"></i></span>。如果觉得难以理解，可以参考在<span class="exturl" data-url="aHR0cDovL3d3dy5PbkphdmE4LmNvbQ==" title="http://www.OnJava8.com">《On Java 8》<i class="fa fa-external-link"></i></span>里，Bruce Eckel的<code>超类通配符</code>和<code>子类通配符</code>的说法。</p>
<ul>
<li>超类通配符，<code>&lt;? super LowerBoundedClass&gt;</code>，通配<code>LowerBoundedClass</code>和它的超类。也可以用类型参数代替实际类型，<code>&lt;? super T&gt;</code></li>
<li>子类通配符 <code>&lt;? extends UpperBoundedClass&gt;</code> 统配<code>UpperBoundedClass</code>和它的子类。也可以用类型参数代替实际类型，<code>&lt;? extends T&gt;</code></li>
</ul>
<h1><span id="参考">参考</span></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2phdmEvZ2VuZXJpY3MvaW5kZXguaHRtbA==" title="https://docs.oracle.com/javase/tutorial/java/generics/index.html">Java泛型官方文档， ORACLE<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3R1dG9yaWFsL2V4dHJhL2dlbmVyaWNzL2luZGV4Lmh0bWw=" title="https://docs.oracle.com/javase/tutorial/extra/generics/index.html">Java泛型教程， Gilad Bracha<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYW1hem9uLmNvbS9FZmZlY3RpdmUtSmF2YS1Kb3NodWEtQmxvY2gvZHAvMDEzNDY4NTk5Nw==" title="https://www.amazon.com/Effective-Java-Joshua-Bloch/dp/0134685997">Effective Java 3rd Edition，Joshua Bloch<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5PbkphdmE4LmNvbQ==" title="http://www.OnJava8.com">On Java 8，Bruce Eckel<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Java 通配符</category>
        <category>Java 泛型</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 通配符</tag>
        <tag>Java 泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Design review 设计评审</title>
    <url>/2020/02/23/design-review/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#背景">背景</a></li>
<li><a href="#设计文档">设计文档</a></li>
<li><a href="#评审">评审</a></li>
</ul>
<!-- tocstop -->
<h1><span id="背景">背景</span></h1><p>几年前在实习时，我完全没有接触过设计评审。当时的团队采用Scrum开发过程。开发团队采取一个架构师（Architect）和三到四个开发者（Developers）的配置。为了保证开发速度，冲刺订单（Spring backlog）里的大多数任务（Ticket）都有架构师写的详细开发步骤。架构师在团队里负责了大多数的软件设计任务，开发者则专注于将架构师的想法实现。</p>
<p>参加工作后，由于开发领域，开发过程，甚至是公司文化都与我实习过的公司有很多不同。再次几件，我也接触到了相当多的设计文档和设计评审。</p>
<p>2019年，我在开发团队里承担的设计任务也越来越多，写过的设计文档有二三十个。参加的设计评审则是更多。一年下来，我对设计评审，这个软件开发中的一个流程，有了自己的一些看法，下面则是我对设计评审的一个小总结。</p>
<a id="more"></a>
<h1><span id="设计文档">设计文档</span></h1><p>设计评审，需要首先有设计。这里说的设计就是设计文档（全称软件开发设计文档）。这是在软件开发之前，一种把软件设计思路结构化记录下来的资料。我第一次接触设计文档是在大学的软件工程课上。当时我也在课程项目中写过设计文档，但是却对为什么需要设计文档体会不深。毕竟当时的项目都很小，难度也不大。写设计文档无非是根据模板填充文字的游戏罢了。</p>
<p>但是当项目参与人员众多，开发难度大时，软件设计，作为软件开发的一个流程，被重视起来。我们在实践过程中，尤其是在一些重要的工作上 （比如时间跨度长，需要几个Sprint周期才能完成的工作，或者涉及多个团队，需要跨团队分工协作时），需要先把思路写下来，通过设计评审分享出来，得到相关人员的批准或者承诺后，再进行实现。</p>
<p>也许短期看，写设计文档，走完设计评审流程比直接蒙头实现软件要慢的多。但是一个好的设计可以在长期为产品的开发节省大量的时间。试想一下在有其他团队对你的软件库（Library）或者Web Service产生依赖时你才发现你的代码需要重新设计的情况，这时不仅是自己负责的项目会受到影响，使用你的代码的其他团队的项目也都会受到影响。</p>
<p>设计评审是软件开发的一个重要环节，写好设计文档则是让设计评审成功的第一步。在我看来，一个好的设计文档应至少包括如下几项：</p>
<ul>
<li>Problem statement。陈述待解决的问题，以及为什么要解决这个问题，或者说，不解决这个问题的后果是什么。</li>
<li>Recommended proposal。详细阐明推荐的解决方案，以及Pros/Cons的比较。</li>
<li>Alternatives。其他可行的解决方案，一般来说解决方案不止一种，也需要有Pros/Cons 对比。能让评审人知道trade-off是什么。</li>
</ul>
<p>更加详细的设计文档除了上面几项外还会有：</p>
<ul>
<li>Background。交代问题的背景，比如总项目的进程，该问题所属项目与总项目之间的关系。</li>
<li>Term。术语表。通常在抽象度高的讨论中，会用到很多术语以及缩略语。它们应该在术语表里进行定义，以避免歧义。</li>
<li>Plan。项目的计划。实现过程复杂时，需要分解实现过程，定义每个阶段的需要交付的模块。或者是每个阶段性成果Milestone是什么。</li>
</ul>
<h1><span id="评审">评审</span></h1><p>一个成功的设计评审需要以下要素。</p>
<ul>
<li>精简的评审团。只让必要的人参与进来。比如项目负责人，项目的主要贡献者或者受到最大影响的人。他们对设计思路的方向最有发言权，能提出有建设性的意见，而且能最后拍板。邀请不必要的人，会增加讨论中的噪音，以致评审流程变慢。</li>
<li>提前制定好的议案。有效率的讨论需要高质量的议案。设计评审的发起人需要准备好评审大会的议案流程，先讨论重要的点，比如一旦敲定就可以让部分项目先开展实现的点。这样接下来的点可以在不阻塞项目进展的情况下讨论。</li>
<li>Meeting Minutes。及时分享会议记录，其中包括参与的人，何时做出了什么决定或者得到了什么共识。当评审大会需要分几次召开时，会议记录作为之前会议的备忘能让我们避免重复讨论。</li>
</ul>
]]></content>
      <categories>
        <category>软件开发实践</category>
        <category>设计评审</category>
      </categories>
      <tags>
        <tag>软件设计</tag>
        <tag>文档</tag>
        <tag>设计评审</tag>
      </tags>
  </entry>
  <entry>
    <title>Git request-pull　和 Github pull request</title>
    <url>/2018/01/04/git-request-pull/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#简短的介绍">简短的介绍</a></li>
<li><a href="#git-request-pull">Git request-pull</a><ul>
<li><a href="#使用目的">使用目的</a></li>
<li><a href="#使用方法">使用方法</a></li>
<li><a href="#一个例子">一个例子</a></li>
</ul>
</li>
<li><a href="#github-pull-request">Github Pull Request</a><ul>
<li><a href="#使用目的-1">使用目的</a></li>
<li><a href="#使用方法-1">使用方法</a><ul>
<li><a href="#使用github-web界面">使用Github web界面</a></li>
<li><a href="#使用command-line">使用Command line</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考">参考</a></li>
</ul>
<!-- tocstop -->
<h2><span id="简短的介绍">简短的介绍</span></h2><p><code>request-pull</code> 和 <code>Pull Request</code>的名称如此相似，但是他们的功能是完全不同的。</p>
<p><code>request-pull</code>是git的命令，它用于生成发送到邮件列表的待处理的更改的摘要。默认情况下，GitHub没有集成这个功能。</p>
<p><code>Pull Request</code>是GitHub特有的一项功能(简称PR)。它用于向Github托管的某一项目中的某一分支提出合并请求。项目管理者则可以在github的web界面上合并来自不同分支的代码，解决合并冲突，做代码审查或对代码进行评论。</p>
<h2><span id="git-request-pull">Git request-pull</span></h2><h3><span id="使用目的">使用目的</span></h3><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXF1ZXN0LXB1bGw=" title="https://git-scm.com/docs/git-request-pull">Generates a summary of pending changes<i class="fa fa-external-link"></i></span></p>
</blockquote>
<p>生成待处理的更改的摘要<br><a id="more"></a></p>
<h3><span id="使用方法">使用方法</span></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git request-pull [-p] &lt;start&gt; &lt;url&gt; [&lt;end&gt;]</span><br></pre></td></tr></table></figure>
<h3><span id="一个例子">一个例子</span></h3><p>新增修改是基于从远端<code>pull</code>下来的<code>master</code>分支上的，为此建立了一个分支叫<code>add-android-cours</code>, 首先把自己的分支<code>push</code>到自己的仓库里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push https://github.com/JinhaiZ/TB-F2B-205.git</span><br></pre></td></tr></table></figure>
<p>运行<code>git request-pull</code>命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git request-pull master https://github.com/JinhaiZ/TB-F2B-205.git add-android-cours</span><br></pre></td></tr></table></figure>
<p>它会根据远端master分支和刚刚push到仓库里的<code>add-android-cours</code>分支的不同做一个摘要。你可以选择把这份摘要email给远端仓库的管理者，这样，管理者可以从这份摘要中快速看出你想对master分支做出什么更改</p>
<p>生成摘要如下所示</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The following changes since commit 5a992617e38665e73ca5ec5e5c10b78373c88938:</span><br><span class="line"></span><br><span class="line">  deleted TD andorid (2017-12-10 22:31:55 +0100)</span><br><span class="line"></span><br><span class="line">are available <span class="keyword">in</span> the git repository at:</span><br><span class="line"></span><br><span class="line">  https://github.com/JinhaiZ/TB-F2B-205.git add-android-cours</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> you to fetch changes up to 658e472da4b7f08378a5452b72c244039c621dac:</span><br><span class="line"></span><br><span class="line">  add andorid cours (2018-01-04 11:36:15 +0100)</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------</span><br><span class="line">JinhaiZ (1):</span><br><span class="line">      add andorid cours</span><br><span class="line"></span><br><span class="line"> android/cours.md | 13 +++++++++++++</span><br><span class="line"> 1 file changed, 13 insertions(+)</span><br><span class="line"> create mode 100644 android/cours.md</span><br></pre></td></tr></table></figure>
<h2><span id="github-pull-request">Github Pull Request</span></h2><h3><span id="使用目的">使用目的</span></h3><blockquote>
<p><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvcHVsbF9yZXF1ZXN0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/07/pull_request.html">“Pull Request 是一种通知机制。你修改了他人的代码，将你的修改通知原来的作者，希望他合并你的修改，这就是 Pull Request。”<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h3><span id="使用方法">使用方法</span></h3><h4><span id="使用github-web界面">使用Github web界面</span></h4><p>以下借用阮一峰老师的讲解</p>
<ol>
<li>第一步，你需要把别人在Github上的项目，fork到你自己的仓库</li>
<li>第二步，在你仓库的修改后的分支上，按下”New pull request”按钮。<br>这时，会进入一个新页面，有Base 和 Head 两个选项。Base 是你希望提交变更的目标，Head 是目前包含你的变更的那个分支或仓库。</li>
<li>第三步，填写说明，帮助别人理解你的提交，然后按下”create pull request”按钮即可。PR 创建后，管理者就要决定是否接受该 PR。</li>
</ol>
<h4><span id="使用command-line">使用Command line</span></h4><p>首先安装<span class="exturl" data-url="aHR0cHM6Ly9odWIuZ2l0aHViLmNvbS8=" title="https://hub.github.com/">Hub<i class="fa fa-external-link"></i></span>，以下步骤参考<span class="exturl" data-url="aHR0cHM6Ly9odWIuZ2l0aHViLmNvbS8=" title="https://hub.github.com/">Hub官方指南<i class="fa fa-external-link"></i></span></p>
<ol>
<li><p>第一步，把别人在Github上的项目克隆到本地</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">`hub <span class="built_in">clone</span> https://github.com/SOME_ONE/xxx.git`</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，创建分支，并在分支上进行修改</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b my-feature-branch</span><br><span class="line">git commit -m <span class="string">"add new feature X"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第三步，把本地项目fork到Github上</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hub fork</span><br><span class="line">→ (forking repo on GitHub...)</span><br><span class="line">→ git remote add YOUR_USER git://github.com/YOUR_USER/xxx.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步，把分支<code>push</code>到新远端(自己fork的远端)</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push YOUR_USER feature</span><br></pre></td></tr></table></figure>
</li>
<li><p>第五步，为自己的分支创建一个PR</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull-request</span><br><span class="line">→ (opens a text editor <span class="keyword">for</span> your pull request message)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2><span id="参考">参考</span></h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb2NzL2dpdC1yZXF1ZXN0LXB1bGw=" title="https://git-scm.com/docs/git-request-pull">git docs: git-request-pull<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTcvMDcvcHVsbF9yZXF1ZXN0Lmh0bWw=" title="http://www.ruanyifeng.com/blog/2017/07/pull_request.html">Pull Request 的命令行管理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ5NDU5NDcvZ2l0LXJlcXVlc3QtcHVsbC1ob3ctdG8tY3JlYXRlLWEtZ2l0aHViLXB1bGwtcmVxdWVzdC1vbi10aGUtY29tbWFuZC1saW5l" title="https://stackoverflow.com/questions/34945947/git-request-pull-how-to-create-a-github-pull-request-on-the-command-line">git request-pull: how to create a (github) pull request on the command line?
<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>每个程序员都应该知道的延迟时间表</title>
    <url>/2017/10/30/Latency-Numbers-Every-Programmer-Should-Know/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<!-- tocstop -->
<p>翻译自:<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamJvbmVyLzI4NDE4MzI=" title="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know<i class="fa fa-external-link"></i></span></p>
<hr>
<table>
<thead>
<tr>
<th>操作</th>
<th>延迟(纳秒)</th>
<th>延迟(微秒)</th>
<th>延迟(毫秒)</th>
<th>参考</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU L1 级缓存访问</td>
<td>0.5   ns</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>分支预测错误*</td>
<td>5   ns</td>
<td></td>
<td></td>
<td>　</td>
</tr>
<tr>
<td>CPU L2 级缓存访问</td>
<td>7   ns</td>
<td></td>
<td></td>
<td>14x L1 cache</td>
</tr>
<tr>
<td>互斥体Mutex 加锁/解锁</td>
<td>25   ns</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>内存访问</td>
<td>100   ns</td>
<td></td>
<td></td>
<td>20x L2 cache, 200x L1 cache</td>
</tr>
<tr>
<td>用Zippy压缩1K字节</td>
<td>3,000   ns</td>
<td>3 us</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在1 Gbps速率的网络上发送1K字节 over</td>
<td>10,000   ns</td>
<td>10 us</td>
<td></td>
<td></td>
</tr>
<tr>
<td>从SSD读取4K长度的随机数据</td>
<td>150,000   ns</td>
<td>150 us</td>
<td></td>
<td>~1GB/sec SSD</td>
</tr>
<tr>
<td>从内存读取连续的1 MB长度数据</td>
<td>250,000   ns</td>
<td>250 us</td>
<td></td>
<td></td>
</tr>
<tr>
<td>在同一数据中心内的来回通讯延迟*</td>
<td>500,000   ns</td>
<td>500 us</td>
<td></td>
<td></td>
</tr>
<tr>
<td>从SSD读取连续的1 MB长度数据</td>
<td>1,000,000   ns</td>
<td>1,000 us</td>
<td>1 ms</td>
<td>~1GB/sec SSD, 4X memory</td>
</tr>
<tr>
<td>磁盘寻址           　</td>
<td>10,000,000   ns</td>
<td>10,000 us</td>
<td>10 ms</td>
<td>20x datacenter roundtrip</td>
</tr>
<tr>
<td>从磁盘读取连续的1 MB长度数据</td>
<td>20,000,000   ns</td>
<td>20,000 us</td>
<td>20 ms</td>
<td>80x memory, 20X SSD</td>
</tr>
<tr>
<td>发送数据包 California-&gt;Netherlands-&gt;California</td>
<td>150,000,000   ns</td>
<td>150,000 us</td>
<td>150 ms</td>
<td></td>
</tr>
</tbody>
</table>
<a id="more"></a>
<blockquote>
<p>分支预测错误(Branch misprediction): 在包含了分支指令（if-then-else)的程序的执行过程中，其执行流程根据判定条件的真/假的不同，有可能会产生跳转，而这会打断流水线中指令的处理，因为CPU无法确定该指令的下一条指令，直到分支指令执行完毕。流水线越长，CPU等待的时间便越长，因为它必须等待分支指令处理完毕，才能确定下一条进入流水线的指令。为了解决这一问题，分支预测器（Branch predictor）在分支指令执行结束之前猜测哪一路分支将会被运行，以提高处理器的指令流水线的性能在分支执行完毕前先进行分支预测，分支预测器有很多种实现。其中最简单的是静态分支预测，方法是任选一条分支进入流水线，但是有50%的概率会预测错误，这时候就会出现分支预测错误</p>
</blockquote>
<blockquote>
<p>来回通讯延迟（Round-trip delay time），在通讯（Communication）、电脑网络（Computer network）领域中，意指：在双方通讯中，发讯方的讯号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传讯息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将讯号传播到收讯方的时间一样久）</p>
</blockquote>
<p>最后附上一张形象的图片<br><img data-src="http://i.imgur.com/k0t1e.png" alt="Latency Numbers Every Programmer Should Know "><br>Credit: <span class="exturl" data-url="aHR0cHM6Ly9pbWd1ci5jb20vazB0MWU=" title="https://imgur.com/k0t1e">https://imgur.com/k0t1e<i class="fa fa-external-link"></i></span></p>
<p>参考：</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamJvbmVyLzI4NDE4MzI=" title="https://gist.github.com/jboner/2841832">Latency Numbers Every Programmer Should Know<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuL0NQVSVFNyVCQyU5MyVFNSVBRCU5OA==" title="https://zh.wikipedia.org/zh-cn/CPU%E7%BC%93%E5%AD%98">CPU缓存<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNSU4OCU4NiVFNiU5NCVBRiVFOSVBMCU5MCVFNiVCOCVBQyVFNSU5OSVBOA==" title="https://zh.wikipedia.org/zh-cn/%E5%88%86%E6%94%AF%E9%A0%90%E6%B8%AC%E5%99%A8">分支预测器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJhbmNoX21pc3ByZWRpY3Rpb24=" title="https://en.wikipedia.org/wiki/Branch_misprediction">Branch misprediction<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3poLWNuLyVFNCVCRSU4NiVFNSU5QiU5RSVFOSU4MCU5QSVFOCVBOCU4QSVFNSVCQiVCNiVFOSU4MSVCMg==" title="https://zh.wikipedia.org/zh-cn/%E4%BE%86%E5%9B%9E%E9%80%9A%E8%A8%8A%E5%BB%B6%E9%81%B2">来回通讯延迟<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>初试树莓派RaspberryPi</title>
    <url>/2017/10/25/first-glance-at-RaspberryPi/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#第一印象">第一印象</a></li>
<li><a href="#远程连接">远程连接</a><ul>
<li><a href="#通过ssh">通过ssh</a></li>
<li><a href="#通过vnc-viewer">通过VNC Viewer</a></li>
</ul>
</li>
<li><a href="#树莓派的缺点">树莓派的缺点</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->
<h2><span id="第一印象">第一印象</span></h2><p>大约在20天前，我在亚马逊上冲动的购买了这个东西</p>
<img data-src="/2017/10/25/first-glance-at-RaspberryPi/Raspberry-Pi-3-Official-Desktop-Starter-Kit.png" title="Raspberry Pi 3 Official Desktop Starter Kit">
<p>树莓派3的官方Desktop Starter Kit，其实也就是树莓派3开发板+16GB miroSD装机卡+壳子+充电器套装。不过这样一套买下来，上手把玩树莓派要方便许多，机子到手第一天我就按照说明书安装了树莓派定制Debian的发型版Raspbian系统。第一感觉还挺好用，通过HDMI连接上显示器，再用4个USB接口中的两个连接键盘和鼠标就可以当做桌面电脑使用了。如果要通过个人电脑远程连接树莓派的话，ssh和VNC Viewer都很好用。</p>
<h2><span id="远程连接">远程连接</span></h2><h3><span id="通过ssh">通过ssh</span></h3><p><em>注意，以下步骤均在个人电脑上完成，不是在树莓派上</em><br><a id="more"></a><br>首先通过Vim 修改本地hosts文件<code>vim /etc/hosts</code> 加入raspberrypi的ip地址，以后就可以通过<code>ssh pi@raspberrypi</code>的方式ssh到树莓派中，如果嫌每次连接都要输入密码麻烦，可以把公钥导入到树莓派中，具体方法如下</p>
<ol>
<li><p>生成公钥私钥对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>将公钥传输到raspberrypi上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id pi@raspberrypi</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试一下，现在用<code>ssh pi@raspberrypi</code>远程登录树莓派就不需要输入密码了</p>
</li>
<li><p>(可选步骤)为了安全性考虑，关闭树莓派上远程ssh密码登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>找到<code>PermitRootLogin</code>这一行，并将它改成<code>PermitRootLogin without-password</code>，如果这一行是被注释的，记得取消注释以此覆盖默认配置。修改并保存，最后运行下面命令使修改生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3><span id="通过vnc-viewer">通过VNC Viewer</span></h3><ol>
<li><p>首先，在树莓派上通过下列命令开启VNC Viewer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install realvnc-vnc-server realvnc-vnc-viewer</span><br></pre></td></tr></table></figure>
</li>
<li><p>接着，在个人电脑上，或者手机上下载VNC Viewer客户端</p>
</li>
<li>最后，在远程连接设备端(个人电脑或者手机)输入树莓派的用户名，密码，ip地址即可远程连接树莓派了</li>
</ol>
<h2><span id="树莓派的缺点">树莓派的缺点</span></h2><p>在树莓派3上做全栈开发并不是很理想，因为部分软件对32bit ARM架构处理器的兼容性不是很好，查看树莓派3的CPU架构可以使用如下命令，结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ lscpu</span><br><span class="line">Architecture:          armv7l</span><br><span class="line">Byte Order:            Little Endian</span><br><span class="line">CPU(s):                4</span><br><span class="line">On-line CPU(s) list:   0-3</span><br><span class="line">Thread(s) per core:    1</span><br><span class="line">Core(s) per socket:    4</span><br><span class="line">Socket(s):             1</span><br><span class="line">Model:                 4</span><br><span class="line">Model name:            ARMv7 Processor rev 4 (v7l)</span><br><span class="line">CPU max MHz:           1200.0000</span><br><span class="line">CPU min MHz:           600.0000</span><br><span class="line">BogoMIPS:              38.40</span><br><span class="line">Flags:                 half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm crc32</span><br></pre></td></tr></table></figure>
<p>可以看到树莓派3采用一块ARMv7架构的CPU，通过查阅维基百科，得知ARMv1到ARMv7架构都是32 bits寻址，直到ARMv8架构才出现64 bits寻址。</p>
<p>故事起源于我想在树莓派上安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dla2FuL3dla2Fu" title="https://github.com/wekan/wekan">wekan<i class="fa fa-external-link"></i></span>，wekan是类似于<span class="exturl" data-url="aHR0cHM6Ly90cmVsbG8uY29tLw==" title="https://trello.com/">Trello<i class="fa fa-external-link"></i></span>的Kanban类项目管理软件，奈何wekan是基于Meteor建立的，而Meteor对安装环境有x86_64的假设，即使修改源代码去掉该假设也不能顺利安装，参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ldGVvci9tZXRlb3IvaXNzdWVzLzQ0Mg==" title="https://github.com/meteor/meteor/issues/442">meteor/issues/442<i class="fa fa-external-link"></i></span>。好消息是2017年6月份，Meteor团队开始着手与增加Meteor对ARM架构CPU的支持，参见<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21ldGVvci9tZXRlb3ItZmVhdHVyZS1yZXF1ZXN0cy9pc3N1ZXMvMTMw" title="https://github.com/meteor/meteor-feature-requests/issues/130">meteor-feature-requests/issues/130<i class="fa fa-external-link"></i></span>。</p>
<p>不能在树莓派上安装wekan，让我有点小小的伤心，但是接下来发生的事情就让我对在树莓派上搞全栈开发暂时失去了兴趣。故事是这样的，为了学习网爬虫，我做了一个每天计算出Stackoverflow最火热问题的项目来练手，该项目的的爬虫部分基于Scapy框架，数据库我选用了最新版本的MongoDB (v3.4.9)　来存储爬取的网页内容。开发完成后我利用crontab在自己的电脑上让它每天晚上10点5分定时在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0ppbmhhaVovc3RhY2tvdmVyZmxvdy10cmVuZGluZw==" title="https://github.com/JinhaiZ/stackoverflow-trending">这里<i class="fa fa-external-link"></i></span>update最火热问题排行。</p>
<p>问题是我的电脑并不是每天晚上10点5分都处于运行状态，有好几次因为我没有开机导致当天我写的程序没有update。于是乎我有了把MongoDB和网页爬取程序部署在树莓派上的想法。说干就干，在树莓派上陆续安装了相应的开发环境，主要是python的开发环境，比如安装Scapy框架可以通过下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># install Scrapy</span><br><span class="line">sudo apt-get install libffi-dev</span><br><span class="line">sudo apt-get install libxml2-dev</span><br><span class="line">sudo apt-get install libxslt1-dev</span><br><span class="line">sudo apt-get install python-dev</span><br><span class="line">sudo pip install scrapy</span><br></pre></td></tr></table></figure>
<p>然而在安装最新版的MongoDB时我遇到了无法解决的问题，实际上，通过下面命令可以安装MongoDB<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># install MongoDB</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mongodb-server</span><br></pre></td></tr></table></figure></p>
<p>但是版本号停留在了v2.4.14，经过查询得知v2.4.14版本后MongoDB就放弃了对32 bit ARM架构CPU的支持，导致树莓派3无法安装最新的MongoDB。奈何我的程序用了大量新版本的特性，比如<code>$slice</code>选择符等，最后在树莓派上部署爬虫的想法只好作罢。</p>
<h2><span id="总结">总结</span></h2><p>第一次接触”单板电脑”(SBC, Single Board Computer)还是很有新鲜感的，低廉的售价，和正常PC几乎一样的功能以及丰富的DIY选项让人很难拒绝。不过作为一个全栈开发人员，想要在树莓派上部署应用，不能安装最新的MongoDB意味着几年前比较流行的MEAN框架在树莓派上可能会行不通，部分框架，例如于ARM处理器有兼容问题的Meteor，会导致部分软件例如wekan在树莓派上无法应用，这些问题在购买前还是要考虑的。</p>
<p>参考</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGlnaXRhbG9jZWFuLmNvbS9jb21tdW5pdHkvdHV0b3JpYWxzL2hvdy10by1zZXQtdXAtc3NoLWtleXMtLTI=" title="https://www.digitalocean.com/community/tutorials/how-to-set-up-ssh-keys--2">How To Set Up SSH Keys<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmFzcGJlcnJ5cGkub3JnL2RvY3VtZW50YXRpb24vcmVtb3RlLWFjY2Vzcy92bmMv" title="https://www.raspberrypi.org/documentation/remote-access/vnc/">VNC (VIRTUAL NETWORK COMPUTING)<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>RaspberryPi</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine Learning 学习笔记 1</title>
    <url>/2017/10/19/machine-learning-review1/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#机器学习第一周笔记">机器学习第一周笔记</a><ul>
<li><a href="#概述">概述</a><ul>
<li><a href="#什么是机器学习">什么是机器学习？</a></li>
<li><a href="#机器学习的分类">机器学习的分类</a></li>
</ul>
</li>
<li><a href="#线性回归">线性回归</a><ul>
<li><a href="#回归模型">回归模型</a></li>
<li><a href="#梯度下降gradient-descent">梯度下降(Gradient descent)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- tocstop -->
<h1><span id="机器学习第一周笔记">机器学习第一周笔记</span></h1><h2><span id="概述">概述</span></h2><h3><span id="什么是机器学习">什么是机器学习？</span></h3><p>从字面上来说，机器学习就是让机器通过模仿人学习的过程学习。也就是说让机器有能力学习，而不是通过准确的程序而实现。我们生活中无处不在存在着机器学习的应用，例如垃圾邮件分类系统，通过图片识别物体等。</p>
<h3><span id="机器学习的分类">机器学习的分类</span></h3><p>机器学习分为两大类：<br><a id="more"></a></p>
<ul>
<li><p><strong>有监督学习(supervised learning)</strong>：给定输入数据和正确的输出结果，通过一系列“训练模型”使得输出结果和正确输出结果无限接近的过程。其中又可以分为两大类 <strong>回归(regression)</strong> 和 <strong>分类(classification)</strong> 问题。例如：给定某地区房屋的情况（房间个数，地理位置，周围环境…）及价格，来预测这个地区某个房子的价格。这就是一个回归问题。再比如通过一个人的照片来预测这个人的年龄。 而分类问题则是输出结果只有两种情况的问题。比如：预测一个病人的肿瘤是良性还是恶性；预测一封邮件是否是垃圾邮件等等。这种问题的结果只有两种情况。</p>
</li>
<li><p><strong>无监督学习(unsupervised learning)</strong>：没有给出正确的输出结果，让机器自己发现输入数据的结构。无监督学习最常见的应用就是分类。比如：给定用户数据，自动划分用户类比从而划分市场；给定一些文章报道，分类文章的类别，政治新闻，经济新闻，或文化新闻等等。</p>
<h2><span id="线性回归">线性回归</span></h2><h3><span id="回归模型">回归模型</span></h3><p>通过训练数据集(training set)学习得到一个函数h(x)，使得输入数据X通过h函数映射的预测结果Y最接近正确值。线性回归的目标就是寻找到h函数使得其完美拟合输入X和输出Y的关系。</p>
</li>
</ul>
<img data-src="/2017/10/19/machine-learning-review1/linear-regression-model.png" title="learning regression model">
<p>(Figure 1 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY291cnNlcmEub3JnL2xlYXJuL21hY2hpbmUtbGVhcm5pbmcvc3VwcGxlbWVudC9jUmEybS9tb2RlbC1yZXByZXNlbnRhdGlvbg==" title="https://www.coursera.org/learn/machine-learning/supplement/cRa2m/model-representation">https://www.coursera.org/learn/machine-learning/supplement/cRa2m/model-representation<i class="fa fa-external-link"></i></span>)</p>
<p>既然已经有了这个模型我们下一个问题就是如何才能找到这样的一个h函数？<br>在线性回归里用来判断拟合函数h好坏的一个标准就是代价函数(Cost funtion)。这个函数的数学表示如下，其中用均方误差来表示预测结果与真实结果的误差。</p>
<img data-src="/2017/10/19/machine-learning-review1/cost-function.png" title="Cost function">
<p>这时，机器学习过程的目标就是要找到一个h函数使得误差J最小。</p>
<h3><span id="梯度下降gradient-descent">梯度下降(Gradient descent)</span></h3><p>求解最小代价函数的方法之一就是用梯度下降(Gradient descent)的方法。<br>数学上，<strong>梯度方向</strong>是<strong>函数值下降最为剧烈</strong>的方向。那么，沿着梯度方向走，我们就能接近其最小值，或者极小值，从而接近更高的预测精度。其数学表达如下：</p>
<img data-src="/2017/10/19/machine-learning-review1/gradient-descent.png" title="Gradient descent">
<p>其中<strong>学习率ɑ</strong>表示的是下降的速率，当这个值过大时会导致错过最小值（步子跨的太大）；当这个值过小时会导致下降的速度很慢（步子跨的太小）。<br>用梯度下降的方法就是不断的沿着梯度方向更新值，直到找到<strong>最小值</strong>。</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的反引号reverse quotes</title>
    <url>/2017/09/25/backtick-in-python/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#反引号">反引号`</a></li>
<li><a href="#repr函数">repr函数</a></li>
<li><a href="#关于单例的思考">关于单例的思考</a></li>
</ul>
<!-- tocstop -->
<h3><span id="反引号">反引号`</span></h3><p>今天在看一本基于python2.2的Design Pattern书，其中有一段关于单例的代码我很不解，因为用到了反引号`，也就是reverse quotes。书中代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OnlyOne</span>:</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">__OnlyOne</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">      self.val = arg</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="keyword">return</span> `self` + self.val</span><br><span class="line">  instance = <span class="literal">None</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> OnlyOne.instance:</span><br><span class="line">      OnlyOne.instance = OnlyOne.__OnlyOne(arg)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      OnlyOne.instance.val = arg</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> getattr(self.instance, name)</span><br><span class="line"></span><br><span class="line">x = OnlyOne(<span class="string">'sausage'</span>)</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line">y = OnlyOne(<span class="string">'eggs'</span>)</span><br><span class="line"><span class="keyword">print</span> y</span><br><span class="line">z = OnlyOne(<span class="string">'spam'</span>)</span><br><span class="line"><span class="keyword">print</span> z</span><br><span class="line"><span class="keyword">print</span> x</span><br><span class="line"><span class="keyword">print</span> y</span><br><span class="line"><span class="keyword">print</span> `x`</span><br><span class="line"><span class="keyword">print</span> `y`</span><br><span class="line"><span class="keyword">print</span> `z`</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>console输出结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;sausage</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;eggs</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.__OnlyOne instance at 0x7ff4670b0200&gt;spam</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b01b8&gt;</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b0290&gt;</span><br><span class="line">&lt;__builtin__.OnlyOne instance at 0x7ff4670b02d8&gt;</span><br></pre></td></tr></table></figure>
<p>反引号`到底有什么用呢？经过查询,反引号在python2中是repr()函数的别名(alias)，但是反引号别名表示已经在pyhton3.0中取消了。至于为何取消，Guido van Rossum他本人的解释是反引号`和正常引号‘的相似性实在是太令人误解了，此外反引号在印刷字体以及输入方面都有不少问题。</p>
<h3><span id="repr函数">repr函数</span></h3><p>知道了python中反引号`其实是repr()函数的别名，那么python中repr函数本身又是干什么的呢？</p>
<blockquote>
<p><strong>repr(object)</strong><br>Return a string containing a printable representation of an object. This is the same value yielded by conversions (reverse quotes). It is sometimes useful to be able to access this operation as an ordinary function. For many types, this function makes an attempt to return a string that would yield an object with the same value when passed to eval(), otherwise the representation is a string enclosed in angle brackets that contains the name of the type of the object together with additional information often including the name and address of the object. A class can control what this function returns for its instances by defining a <strong>repr</strong>() method.</p>
</blockquote>
<p>根据上述节选自python官方文档的解释，可以知道repr函数主要功能是返回object的一种可打印字符串表示。一般来说，repr函数被设计成其输出可以被eval函数生成值相同的object，或者，被设计成返一个包含在尖头括号中的字符串，其中包含对象类型名称和一些附加信息。而附加信息通常包括这个对象的名字和物理地址。</p>
<p>在Desgin Patter作者给出的单例代码中，repr函数便输出了对象的名字和物理地址。</p>
<h3><span id="关于单例的思考">关于单例的思考</span></h3><p>一般讲Desgin Pattern的书几乎一开始都会讲单例，毕竟单例是最容易理解的Desgin Pattern。作者在实现单例时用了nested class方法，内部class是一个私有class，这样外部无法直接访问。那么print函数又是如何访问到私有class的<code>__str__</code>函数的呢？这就要靠wrapper class的<code>__getattr__</code>函数了，在这里作者巧妙实现了一个delegation。这也是为什么print OnlyOne class的instance时，console输出都是私有class的<code>__str__</code>函数定义的结果。</p>
<p>参考</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY3MzA3MS93aGF0LWRvLWJhY2t0aWNrcy1tZWFuLXRvLXRoZS1weXRob24taW50ZXJwcmV0ZXItbnVt" title="https://stackoverflow.com/questions/1673071/what-do-backticks-mean-to-the-python-interpreter-num">What do backticks mean to the python interpreter: num
<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYWlsLnB5dGhvbi5vcmcvcGlwZXJtYWlsL3B5dGhvbi1pZGVhcy8yMDA3LUphbnVhcnkvMDAwMDU0Lmh0bWw=" title="https://mail.python.org/pipermail/python-ideas/2007-January/000054.html">[Python-ideas] new operators via backquoting<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvMi9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JlcHI=" title="https://docs.python.org/2/library/functions.html#repr">docs.python repr(object)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5taW5kdmlldy5uZXQvQm9va3MvUHl0aG9uL1RoaW5raW5nSW5QeXRob24uaHRtbA==" title="http://www.mindview.net/Books/Python/ThinkingInPython.html">Bruce Eckel Thinking in Python<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>reverse quotes</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的生成器</title>
    <url>/2017/09/25/generator-in-python/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#可迭代对象">可迭代对象</a></li>
<li><a href="#迭代器">迭代器</a></li>
<li><a href="#生成器">生成器</a></li>
<li><a href="#关键词yield">关键词Yield</a></li>
<li><a href="#什么时候使用生成器">什么时候使用生成器</a></li>
<li><a href="#从design-pattern角度看生成器">从Design Pattern角度看生成器</a></li>
</ul>
<!-- tocstop -->
<h3><span id="可迭代对象">可迭代对象</span></h3><p>要想理解python中的生成器，得先从可迭代对象Iterable说起。什么是可迭代对象呢？</p>
<blockquote>
<p>定义了可以返回一个迭代器的<strong>iter</strong>方法的对象，或者定义了可以支持下标索引的<strong>getitem</strong>方法的对象，就是一个可迭代对象</p>
</blockquote>
<p>所以我们可以用如下方法来判断一个实例是否为可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hasattr((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="string">'__iter__'</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">hasattr([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">'__iter__'</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">hasattr(&#123;&#125;, <span class="string">'__iter__'</span>) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">hasattr(<span class="string">'abc'</span>, <span class="string">'__getitem__'</span>) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>知道了可迭代对象的定义，那么可迭代对象又有什么用呢，如下列所示，我们经常在python中使用for…in循环，那么for…in循环能在所有对象上使用吗？<br><a id="more"></a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">  print(i) </span><br><span class="line"><span class="comment"># 1 </span></span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>其实不然，只有在可迭代对象上，for…in循环才能使用，比如列表，元组，字典以及字符串。这就是可迭代对象的最大用途。然而问题有来了，这些可迭代对象虽然好用，但是它们却又一大弊端。可迭代对象在使用时，比如<code>my_list</code>，它会把列表<code>[1, 2, 3]</code>中所有元素都存贮在内存中，当列表长度非常可观时，python会遇到性能方面的问题(python2.7中range函数返回可迭代对象，xrange函数返回生成器，所以可以通过比较这两个函数的执行相同任务时间来直观的了解性能方面的问题，stackoverflow上便有回答来比较这两个函数的执行时间，问题链接<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ5MzUvd2hhdC1pcy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLXJhbmdlLWFuZC14cmFuZ2UtZnVuY3Rpb25zLWluLXB5dGhvbi0yLXg=" title="https://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x">点此<i class="fa fa-external-link"></i></span>)。</p>
<h3><span id="迭代器">迭代器</span></h3><p>对于上述列表对象遇到的性能问题，我们自然会问到有没有方法来解决这样的问题。比如，有没有一种类似列表的对象，但是它不会一下子把它所有的元素都放到内存里的对象？<br>有，它就是迭代器，还是先说迭代器Iterator的定义</p>
<blockquote>
<p>定义了返回迭代器对象本身<strong>iter()</strong>(Python2)方法的对象，或者定义了方法返回容器的下一个元素<strong>next</strong>方法的对象，就是一个迭代器。</p>
</blockquote>
<p>同时我们也说，实现了上述两个方法的对象是遵守了迭代器协议（iterator protocol）的对象。</p>
<p>判断一个对象我们除了可以检查它有没有<code>__iter()__</code>和<code>__next__</code>方法外，我们也可以用isinstance()方法。如下所示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">isinstance((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">isinstance([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">isinstance(&#123;&#125;, Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">isinstance(<span class="string">'abc'</span>, Iterator) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>这下我们发现，元组，列表，字典，字符串都是可迭代对象，但同时它们也都不是迭代器。谁是迭代器呢？从上面例子可看到<code>(x for x in [1,2,3])</code>是迭代器对象的实例。</p>
<p>首先，为什么元组，列表，字典，字符串都不是迭代器Iterator呢？</p>
<blockquote>
<p>这是因为Python的Iterator对象表示的是一个数据流，Iterator对象可以被next()函数调用并不断返回下一个数据，直到没有数据时抛出StopIteration错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过next()函数实现按需计算下一个数据，所以Iterator的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
</blockquote>
<p>从以上摘自<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDMxNjA4OTU1NzI2NGE2YjM0ODk1OGY0NDk5NDlkZjQyYTZkM2EyZTU0MmMwMDAvMDAxNDMxNzgyNTQxOTM1ODlkZjljNjEyZDI0NDk2MThlYTQ2MGU3YTY3MmEzNjYwMDA=" title="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000">廖雪峰<i class="fa fa-external-link"></i></span>官网上的解答中我们可以看出，迭代器表示一个数据流，它不会把这个数据流中每一个元素都存贮在内存中，而列表则不同，它会把列表中所有元素都存贮在内存中。</p>
<p>对于第二个问题，为什么<code>(x for x in [1,2,3])</code>是迭代器对象的实例呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">isinstance(iter((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">isinstance(iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">isinstance(iter(&#123;&#125;), Iterator) <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">isinstance(iter(<span class="string">'abc'</span>), Iterator) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>
<p>从以上例子可以看出，虽然元组，列表，字典，字符串都不是迭代器，但是通过iter()函数，可以获得一个Iterator对象。</p>
<p>所以Python的for循环本质上可以看做先通过iter()函数，获得一个迭代器Iterator对象，再在这个迭代器对象上通过不断调用next()函数实现的。</p>
<h3><span id="生成器">生成器</span></h3><p>在了解了可迭代对象Iterable和迭代器Iterator的概念后，我们终于可以开始探讨生成器的概念了。</p>
<p>先放概念</p>
<blockquote>
<p>生成器是一种迭代器，但是只能对其迭代一次。因为它们并没有把所有的值存在内存中，而是在运行时生成值。生成器可通过遍历来使用它们，要么用一个“for”循环，要么将它传递给任意可以进行迭代的函数和结构。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_generator = (x <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># nothing happens</span></span><br></pre></td></tr></table></figure>
<p>上面是生成器的一个简单的例子，这个例子有点像for…in循环输出<code>my_list</code>的例子，除了这里用了一个迭代器<code>(x for x in [1,2,3])</code>替换了可迭代对象<code>[1,2,3]</code>。它们有什么不同吗？仔细观察上例，当我们再次使用for…in循环输出my_generator时，什么都没有发生，这也就是定义中说的</p>
<blockquote>
<p>生成器是一种迭代器，但是只能对其迭代一次。</p>
</blockquote>
<p>因为生成器首先生成1，接着从内存中清空1，接下来生成2，接着从内存中清空2，最后生成3，接着从内存中清空3。</p>
<h3><span id="关键词yield">关键词Yield</span></h3><p>我们知道了一种由迭代器来获得生成器的方式，那么还有其他的方式来获得生成器吗？用Python关键词yield就可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createGenerator</span><span class="params">()</span>:</span></span><br><span class="line">  my_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> my_list:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">my_generator = createGenerator()</span><br><span class="line">print(my_generator) <span class="comment"># &lt;generator object createGenerator at 0x7ff6a5c785c8&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_generator:</span><br><span class="line">  print(i)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>虽然上面的例子没有人在实际中会使用，但是用它来了解yield的用法还是很通俗易懂的。关于yield的难点，首先我们可以看到，通过<code>createGenerator()</code>函数来获得生成器<code>my_generator</code>时，函数<code>createGenerator()</code>并没有被执行，它只是返回了一个位于内存中处于某个位置上的该生成器对象。直到我们用for…in循环作用于这个对象上时，函数<code>createGenerator()</code>才被真正的执行，我们可以把它当做是一种惰性求值。</p>
<p>那么生成器<code>my_generator</code>是如何求值的呢？当for…in循环第一次调用生成器时，<code>createGenerator()</code>被执行，直到被执行到yield关键词这里，返回循环的第一个值。余下的循环在调用生成器时，会继续上次的循环，再次遇到yield关键词时返回这一次循环的值，直到循环结束，再也遇不到yield关键词为止。</p>
<h3><span id="什么时候使用生成器">什么时候使用生成器</span></h3><p>生成器的一个典型应用场景是：你不想把同一时间将所有计算出来的大量结果贮存到内存中，因为这样做会消耗大量资源，所以使用生成器来进行惰性求值，只有在需要某个结果时，再计算该结果。</p>
<p>举一个生成斐波那契数列的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  fib_list = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    fib_list.append(a)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line">  <span class="keyword">return</span> fib_list</span><br></pre></td></tr></table></figure>
<p>当输入参数很大时，内存资源会被严重消耗。</p>
<p>下面是该函数的生成器版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a, b = b, a + b</span><br></pre></td></tr></table></figure>
<p>由于惰性求值的缘故，即便参数很大时，我们也不用担心内存资源的消耗。</p>
<p>我们刚刚谈到了内存消耗情况，有什么工具能帮助我们直观的感受到内存的消耗呢？ python有个叫<code>memory_profiler</code>的工具可以来帮我们进行内存消耗情况的测试。为了对比上述两个方法的内存消耗，我们让这两个方法同时生100000个斐波那契数列，并观察内存消耗情况。</p>
<p>测试<code>listFibonacci()</code>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">listFibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  fib_list = []</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    fib_list.append(a)</span><br><span class="line">    a, b = b, a + b</span><br><span class="line">  <span class="keyword">return</span> fib_list</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testListFib</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> listFibonacci(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    testListFib()</span><br></pre></td></tr></table></figure>
<p>测试<code>genFibonacci()</code>代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">genFibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">  a = b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    <span class="keyword">yield</span> a</span><br><span class="line">    a, b = b, a + b</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testGenFib</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> genFibonacci(<span class="number">100000</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  testGenFib()</span><br></pre></td></tr></table></figure>
<p>使用<code>listFibonacci()</code>测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filename: listFib.py</span><br><span class="line"></span><br><span class="line">Line #    Mem usage    Increment   Line Contents</span><br><span class="line">================================================</span><br><span class="line">    11     14.2 MiB      0.0 MiB   @profile</span><br><span class="line">    12                             def testListFib():</span><br><span class="line">    13    460.5 MiB    446.2 MiB     for i in listFibonacci(100000):</span><br><span class="line">    14    460.5 MiB      0.0 MiB       pass</span><br></pre></td></tr></table></figure>
<p>使用<code>genFibonacci()</code>测试结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Filename: genFib.py</span><br><span class="line"></span><br><span class="line">Line #    Mem usage    Increment   Line Contents</span><br><span class="line">================================================</span><br><span class="line">     9     14.4 MiB      0.0 MiB   @profile</span><br><span class="line">    10                             def testGenFib():</span><br><span class="line">    11     14.4 MiB      0.0 MiB     for i in genFibonacci(100000):</span><br><span class="line">    12     14.4 MiB      0.0 MiB       pass</span><br></pre></td></tr></table></figure>
<p>从上面的测试结果可以看出，在生成大于100000个斐波那契数列的任务中，<code>listFibonacci()</code>消耗了460.5 MiB内存，而<code>genFibonacci()</code>只消耗了14.4 MiB内存。其实，如果我们绘制一个内存消耗随生成斐波那契数列长度变化的折线图，我们可以发现，随着生成斐波那契数列长度的增加，<code>listFibonacci()</code>的内存消耗情况是指数递增的，而<code>genFibonacci()</code>的内存消耗情况则是不变的，总是维持在消耗14.4 MiB 左右。通过这个测试，我们可以直观的感受到，在计算大量不需要被保存结果且只需计算一次的任务下，我们为什么不用担心生成器对内存资源的消耗。</p>
<h3><span id="从design-pattern角度看生成器">从Design Pattern角度看生成器</span></h3><p>如果从Design Pattern的角度来看生成器，生成器就是一个无参数版本的工厂模式。通常工厂模式需要通过参数来确定生成什么对象以及如何生成该对象，但是生成器则不需要参数，它通过内部算法来确定生成什么对象以及如何生成该对象。</p>
<p>参考</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjMxNzY3L3doYXQtZG9lcy10aGUteWllbGQta2V5d29yZC1kby8yMzE4NTUjMjMxODU1" title="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do/231855#231855">Stackoverflow, What does the “yield” keyword do?
<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMDAxNDMxNjA4OTU1NzI2NGE2YjM0ODk1OGY0NDk5NDlkZjQyYTZkM2EyZTU0MmMwMDAvMDAxNDMxNzgyNTQxOTM1ODlkZjljNjEyZDI0NDk2MThlYTQ2MGU3YTY3MmEzNjYwMDA=" title="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000">廖雪峰的官方网站, 迭代器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3dpa2kuamlrZXh1ZXl1YW4uY29tL3Byb2plY3QvZXhwbG9yZS1weXRob24vQWR2YW5jZWQtRmVhdHVyZXMvaXRlcmF0b3IuaHRtbA==" title="http://wiki.jikexueyuan.com/project/explore-python/Advanced-Features/iterator.html">极客学院, 迭代器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5taW5kdmlldy5uZXQvQm9va3MvUHl0aG9uL1RoaW5raW5nSW5QeXRob24uaHRtbA==" title="http://www.mindview.net/Books/Python/ThinkingInPython.html">Bruce Eckel, Thinking in Python<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>用python来探讨多态</title>
    <url>/2017/09/25/polymorphism-in-python/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!-- toc -->
<!-- tocstop -->
<p>最近在看一本基于pyhton的Design Pattern方面的书，其中涉及到了python的多态，也就是polymorphism。用python来解释，到底什么是多态(polymorphism)呢？StackOverflow上有一个很好的答案，下面便是答案中举的例子<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span>    <span class="comment"># Constructor of the class</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span>              <span class="comment"># Abstract method, defined by convention only</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"Subclass must implement abstract method"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Meow!'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Woof! Woof!'</span></span><br><span class="line"></span><br><span class="line">animals = [Cat(<span class="string">'Missy'</span>),</span><br><span class="line">           Cat(<span class="string">'Mr. Mistoffelees'</span>),</span><br><span class="line">           Dog(<span class="string">'Lassie'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> animal <span class="keyword">in</span> animals:</span><br><span class="line">    <span class="keyword">print</span> animal.name + <span class="string">': '</span> + animal.talk()</span><br></pre></td></tr></table></figure></p>
<p>从这个例子我们可以看出，不同的动物都可以“talk”，但它们“talk”的实现方式不同。 因此，“talk”行为是多态的，它根据动物的不同而有所不同。 我们可以看到，抽象的Animal类实际上并不能“talk”，而具体的动物类（如Dog和Cat）则分别实现了“talk”的动作。</p>
<p>类似地，加法操作符<code>+</code>在许多数学运算中有定义，在特定情况下，多态性允许我们根据具体规则定义加法操作符，比如在实数集下：<code>1 + 1 = 2</code>，但包含复数的情况下<code>(1 + 2i)+(2-9i)=(3-7i)</code>。</p>
<p>总结来说，多态允许我们在抽象类中指定常用方法，并在特定子类中实现它们。</p>
<p>参考</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUG9seW1vcnBoaXNtXyhjb21wdXRlcl9zY2llbmNl" title="https://en.wikipedia.org/wiki/Polymorphism_(computer_science">Wikipedia Polymorphism<i class="fa fa-external-link"></i></span>)</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzcyNDExMC9wcmFjdGljYWwtZXhhbXBsZS1vZi1wb2x5bW9ycGhpc20=" title="https://stackoverflow.com/questions/3724110/practical-example-of-polymorphism">StackOverflow Polymorphism<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Design Pattern</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>polymorphism</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>在Alienware上安装Ubuntu</title>
    <url>/2017/09/15/install-ubuntu-on-alienware/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#制作ubuntu启动u盘">制作Ubuntu启动U盘</a></li>
<li><a href="#安装ubuntu">安装Ubuntu</a></li>
<li><a href="#解决驱动问题">解决驱动问题</a><ul>
<li><a href="#安装killer网卡驱动">安装killer网卡驱动</a></li>
<li><a href="#安装蓝牙驱动">安装蓝牙驱动</a></li>
</ul>
</li>
<li><a href="#进阶配置alienfx">进阶配置AlienFx</a></li>
</ul>
<!-- tocstop -->
<p>作为一个游戏发烧友，同时也是小白全栈开发程序员我买了Alienware却只用来打游戏是在是太可惜了。为了搞搞开发，昨天配置了一天WSL (Windows Subsystems for Linxu)，用了Hyper+zsh的终端组合。其中在zsh中输入atom能启动windows的Atom也着实把我惊艳了一把，但其实也就算仅限于打开而已。事实是Windows中的文本编辑器并不能直接编辑其子系统中的文件。所以这个子系统在某些方便我觉得还没有Vagrant方便，没有图形界面，意味着不能使用Atom，Visual Studio Code这样代表先进生产力的工具，于是配置WSL搞搞开发的想法就此作罢。</p>
<p>子系统搞不成，于是有了直接在Ubuntu上工作的想法。其实Alienware上安装Ubuntu不是很难，除了一些蓝牙和Wi-Fi方面的兼容问题，安装过程非常顺利。接下来step by step记录安装过程。<br><a id="more"></a></p>
<h2><span id="制作ubuntu启动u盘">制作Ubuntu启动U盘</span></h2><p>在Ubuntu官方网站下载16.04 LTS系统镜像，并将其制作成启动U盘。<br>制作启动U盘的工具有很多，<span class="exturl" data-url="aHR0cHM6Ly9ydWZ1cy5ha2VvLmllLw==" title="https://rufus.akeo.ie/">Rufus<i class="fa fa-external-link"></i></span> 是我用的一款，界面简单清爽无广告不收费。</p>
<p>Rufus界面如下，制作启动U盘时，注意Partition schemem and target system type选择同时支持UEFI和BIOS的格式。</p>
<img data-src="/2017/09/15/install-ubuntu-on-alienware/rufus_en_2x.png" title="用Rufus制作Ubuntu启动U盘 (图片来源rufus.akeo.ie)">
<h2><span id="安装ubuntu">安装Ubuntu</span></h2><p>重新启动Windows，启动黑屏时按F11进入UEFI界面，有两个配置需要更改</p>
<ul>
<li>关闭secure boot</li>
<li>打开legecy boot mode</li>
</ul>
<p>插入Ubuntu启动U盘符，再次重新启动，按下F11，选择从U盘启动，接下来的步骤和在普通电脑上安装双系统无异。</p>
<p>安装完成后，再次启动，boot loader已经从windows boot manager变成了GRUB(<strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>ootloader)。以后在便可以在GRUB界面中选择进入的系统是Ubuntu还是Windows。</p>
<h2><span id="解决驱动问题">解决驱动问题</span></h2><p>进入安装完毕的Ubuntu，我遇到的第一个问题就是无法连接Wi-Fi。安装驱动程序有一个一般性的方法，先通过下面的命令查看自己使用的设备是什么型号，然后在网上搜索该型号设备的驱动程序。</p>
<ul>
<li><p><code>lsusb</code> 查看usb接口的设备</p>
</li>
<li><p><code>lspci</code> 查看pci接口的设备</p>
</li>
</ul>
<h3><span id="安装killer网卡驱动">安装killer网卡驱动</span></h3><p>如下图所示，<code>lspci | grep -i net</code>命令显示我使用的网卡型号是Qualcomm Atheros Killer E2400，通过搜索，发现Alienware使用的killer网卡的<span class="exturl" data-url="aHR0cHM6Ly93d3cua2lsbGVybmV0d29ya2luZy5jb20vZHJpdmVyLWRvd25sb2Fkcy9rbm93bGVkZ2UtYmFzZT92aWV3PXRvcGljJmFtcDtpZD0y" title="https://www.killernetworking.com/driver-downloads/knowledge-base?view=topic&amp;id=2">官方网站<i class="fa fa-external-link"></i></span>提供了相关驱动的下载。</p>
<img data-src="/2017/09/15/install-ubuntu-on-alienware/alienware_wifi_driver.png" title="安装killer网卡驱动">
<p>如上图所示，可通过如下命令安装killer网卡驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.kernel.org/ubuntu/pool/main/l/linux-firmware/linux-firmware_1.164_all.deb</span><br><span class="line">sudo dpkg -i linux-firmware*.deb</span><br><span class="line">sudo modprobe -r ath10k_pci &amp;&amp; sudo modprobe ath10k_pci</span><br></pre></td></tr></table></figure>
<h3><span id="安装蓝牙驱动">安装蓝牙驱动</span></h3><p>首先通过下面的命令卸载已安装的蓝牙驱动并且安装新的蓝牙驱动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get purge blueman bluez-utils bluez bluetooth</span><br><span class="line">sudo apt-get install blueman bluez-utils bluez bluetooth</span><br></pre></td></tr></table></figure>
<p>然后再启动蓝牙服务</p>
<p><code>sudo /etc/init.d/bluetooth start</code></p>
<p>如下图所示，接下来就可以通过Blueman管理系统蓝牙连接了<br><img data-src="/2017/09/15/install-ubuntu-on-alienware/ubuntu_blueman_interface.png" title="Ubuntu上蓝牙连接管理软件Blueman界面"></p>
<h2><span id="进阶配置alienfx">进阶配置AlienFx</span></h2><p>Alienware的一大特色就是它有狂野炫酷的灯，更换Ubuntu平台后，一个大问题就是戴尔官方没有Ubuntu平台的AlienFx。</p>
<p>通过查询，发现有人写了开源版本的AlienFx，只可惜项目已经有好几年无人维护。下载最新版本试用后，不出以外的，该软件并不支持最新的Alienware，该软件支持的Alienware系列可以从<span class="exturl" data-url="aHR0cHM6Ly9kb2MudWJ1bnR1LWZyLm9yZy9hbGllbmZ4" title="https://doc.ubuntu-fr.org/alienfx">该网站<i class="fa fa-external-link"></i></span>中找到。</p>
<p>参考资料</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ydWZ1cy5ha2VvLmllLw==" title="https://rufus.akeo.ie/">Rufus Offical Site<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cua2lsbGVybmV0d29ya2luZy5jb20vZHJpdmVyLWRvd25sb2Fkcy9rbm93bGVkZ2UtYmFzZT92aWV3PXRvcGljJmFtcDtpZD0y" title="https://www.killernetworking.com/driver-downloads/knowledge-base?view=topic&amp;id=2">Killer Networking<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy83NzY4MDYvYmx1ZXRvb3RoLW9uLXVidW50dS0xNi0wNA==" title="https://askubuntu.com/questions/776806/bluetooth-on-ubuntu-16-04">Bluetooth on Ubuntu 16.04<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2MudWJ1bnR1LWZyLm9yZy9hbGllbmZ4" title="https://doc.ubuntu-fr.org/alienfx">AlienFx on Ubuntu<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>折腾</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Alienware</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上安装拼音输入法</title>
    <url>/2017/09/15/install-pinyin-in-Ubuntu/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>目录</p>
<!-- toc -->
<ul>
<li><a href="#安装ibus中文输入法">安装IBus中文输入法</a></li>
<li><a href="#安装搜狗中文输入法">安装搜狗中文输入法</a></li>
</ul>
<!-- tocstop -->
<h3><span id="安装ibus中文输入法">安装IBus中文输入法</span></h3>  <img data-src="/2017/09/15/install-pinyin-in-Ubuntu/successfully_installed_pinyin.png" title="Ubuntu上的拼音输入法">
<p>最近又重新安装了Ubuntu系统。因为要写中文博客，没有中文输入法实在是麻烦。在Ubuntu上安装中文输入法确实没有Windows上显而易见，所以写下步骤方便自己将来参考。</p>
<ol>
<li><p>首先进入系统设置选择language support，如果没有完整安装该功能，先根据系统提示完成安装</p>
</li>
<li><p>点击install/remove language 来安装中文支持</p>
</li>
<li><p>接下来在Terminal中手动安装下面任何一个输入法</p>
<p> <code>sudo apt-get install ibus-pinyin</code></p>
<p> <code>sudo apt-get install ibus-sunpinyin</code></p>
</li>
<li><p>重启IBus daemon</p>
<p> <code>ibus restart</code></p>
</li>
<li><p>再进入系统设置选择Text Entry，点击左下角的小加号并在add input source界面中搜索Chinese，选择一款拼音输入法</p>
<img data-src="/2017/09/15/install-pinyin-in-Ubuntu/ubuntu_add_input_method.png" title="选择Pinyin输入法">
</li>
<li><p>使用吧</p>
</li>
</ol>
<h3><span id="安装搜狗中文输入法">安装搜狗中文输入法</span></h3><p>使用了几天IBus的中文输入发，使用体验简直弱爆了。首先4k屏适配有问题，待选框时刻游离在屏幕之外，然而最致命的是，IBus拼音输入法竟然有切换到双拼就无法再切换回来的bug。早年间我在ubuntu 14上使用过搜狗输入法，用户体验良好，于是试着在ubuntu 16.04上安装。虽然安装步骤比在ubuntu 14上稍稍复杂一些，但是搜狗输入法完美适配4k屏幕而且一如既往的好用。安装步骤如下：<br><a id="more"></a></p>
<ol>
<li><p>搜狗舒服法依赖Fcitx键盘输入法系统而不是IBus，所以安装搜狗输入法前需要确认Fcitx已经安装，若没有安装Fcitx，可以通过terminal</p>
<p> <code>sudo apt-get install fcitx</code></p>
<p> 如果安装过程中需要额外依赖，可以通过以下命令安装</p>
<p> <code>apt-get install -f</code></p>
</li>
<li><p>点击<span class="exturl" data-url="aHR0cDovL3Bpbnlpbi5zb2dvdS5jb20vbGludXgv" title="http://pinyin.sogou.com/linux/">这里<i class="fa fa-external-link"></i></span>下载搜狗中文输入法，有32bit和64bit安装包可选，ubuntu用户可以选择deb格式安装包用Ubuntu Software Center来安装，当然可以到下载路径下通过以下命令安装</p>
<p> <code>sudo dpkg -i sogoupinyin_2.1.0.0086_amd64.deb</code></p>
</li>
<li><p>安装完毕后，在从当前系统设置/语言支持里选择Fcitx做为键盘输入法系统</p>
</li>
<li>退出登录，再重新登录</li>
<li>现在在系统右上角应该能看到键盘图标，选择设置，添加搜狗中文书法</li>
<li>开心的使用吧</li>
</ol>
<p>参考资料</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy81OTM1Ni9ob3ctZG8taS1nZXQtY2hpbmVzZS1pbnB1dC10by13b3Jr" title="https://askubuntu.com/questions/59356/how-do-i-get-chinese-input-to-work">How do I get Chinese input to work?<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy80NTU2ODIvMTQtMDQtY2hpbmVzZS1pYnVzLWlucHV0LW5vLW9wdGlvbnM=" title="https://askubuntu.com/questions/455682/14-04-chinese-ibus-input-no-options">14.04 Chinese Ibus Input - No Options<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy80NTAyNTUvaW5zdGFsbGluZy1zb2dvdS0lRTYlOTAlOUMlRTclOEIlOTclRTYlOEIlQkMlRTklOUYlQjM=" title="https://askubuntu.com/questions/450255/installing-sogou-%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3">Installing SOGOU 搜狗拼音<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>拼音输入法</category>
      </categories>
      <tags>
        <tag>pinyin</tag>
        <tag>input method</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility PermCheck in Python</title>
    <url>/2017/06/02/codility-perm-check/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>设输入数组长度为N，最优情况在输入数组的最大值不等于N时达成</p>
<h3><span id="算法分析">算法分析</span></h3><p><strong>permutation</strong> 被定义为长为N的数组，包含整数1到N，且每个整数包含有且仅有一次。根据定义，我们必须遍历完输入数组才能知道是否1到N的每个整数包含有且仅有一次，所以算法复杂度为O(N)且无法继续优化。如何检测输入数组中1到N的每个整数出现有且仅有一次呢？一个比较直观的方法是用一个长度为N的数组作标记，遍历输入数组并在标记数组的对应项作标记，一旦该标记数组所有项均被标记，则说明输入数组满足permutation定义。但是该方法有一个缺点，就是需要成比例于输入数组长度N的存储空间。有没有不需要额外存储空间的算法呢？答案当然是有的，技巧在于利用输入数组，在遍历输入数组的同时，利用输入数组做标记。由于输入数组各项均为正整数，我们可以将某一项置为负值来标记该项索引+1对应的正整数出现过一次。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">        index = A[i] <span class="keyword">if</span> A[i] &gt; <span class="number">0</span> <span class="keyword">else</span> -A[i]</span><br><span class="line">        <span class="keyword">if</span> index &gt; len(A) <span class="keyword">or</span> A[index - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            A[index - <span class="number">1</span>] = -A[index - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility MissingInteger in Python</title>
    <url>/2017/06/02/codility-missing-integer/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>创建检查数组check，遍历数组A的项，若某项的值为整数x，则以整数x作为索引，将check数组对应的项置1。在遍历check数组，寻找值为0时索引的最小值。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    n=len(A)</span><br><span class="line">    max_A=<span class="number">100001</span></span><br><span class="line">    check=[<span class="number">0</span>]*(max_A+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;=<span class="number">0</span> <span class="keyword">and</span> A[i]&lt;max_A <span class="keyword">and</span> check[A[i]<span class="number">-1</span>]==<span class="number">0</span>):</span><br><span class="line">            check[A[i]<span class="number">-1</span>]=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> xrange(max_A+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(check[ind]==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> ind+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility Maxcountersers in Python</title>
    <url>/2017/06/02/codility-max-counters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N+M)</td>
<td>O(N)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N+M)</td>
<td>O(N)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N+M)</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>若要达到最差情况下的时间复杂度为O(N+M)，那就意味着不能在<code>A[K] = N + 1</code>时依次将每个<code>counter</code>的值置为当前<code>counters</code>数组的最大值。因为max counter操作的复杂度为O(N)且需要嵌套在复杂度为O(M)的循环中，这样算法的复杂度至少为O(NM)。也就以为着当<code>A[K] = N + 1</code>时，我们不能立即执行max counter操作。借用下惰性求值的概念，只有在真的需要某个<code>counter</code>值的情况的下才执行计算。这就需要建立两个变量，<code>max_A</code>记录当前<code>counters</code>的最大值，<code>lastUpdate</code>记录上一次执行max counter操作时<code>max_A</code>的值。这样只有当<code>A[K] = N + 1</code>时，才把<code>max_A</code>的值赋值给<code>lastUpdate</code>。而当<code>A[i] &lt; N+1</code>时，则要根据<code>lastUpdate</code>的值来更新<code>counter</code>和<code>max_A</code>的值。</p>
<p>最后在返回所<code>counters</code>数组值之前，需要根据<code>lastUpdate</code>的值对每个counter的值进行计算</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(N, A)</span>:</span></span><br><span class="line">    <span class="comment"># each element of array A is an integer within the range [1..N + 1]</span></span><br><span class="line">    <span class="comment"># N and M are integers within the range [1..100,000]</span></span><br><span class="line">    M = len(A)</span><br><span class="line">    max_A = <span class="number">0</span></span><br><span class="line">    lastUpdate = <span class="number">0</span></span><br><span class="line">    counters=[<span class="number">0</span>]*N</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(M):</span><br><span class="line">        <span class="keyword">if</span> (A[i]==N+<span class="number">1</span>):</span><br><span class="line">            lastUpdate = max_A</span><br><span class="line">        <span class="keyword">if</span> (A[i]&lt;N+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (counters[A[i]<span class="number">-1</span>]&lt;lastUpdate):</span><br><span class="line">                counters[A[i]<span class="number">-1</span>]=lastUpdate+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (counters[A[i]<span class="number">-1</span>]&gt;max_A):</span><br><span class="line">                    max_A=counters[A[i]<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                counters[A[i]<span class="number">-1</span>]=counters[A[i]<span class="number">-1</span>]+<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (counters[A[i]<span class="number">-1</span>]&gt;max_A):</span><br><span class="line">                    max_A=counters[A[i]<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(N):</span><br><span class="line">        <span class="keyword">if</span> (counters[j]&lt;lastUpdate):</span><br><span class="line">            counters[j]=lastUpdate</span><br><span class="line">    <span class="keyword">return</span> counters</span><br><span class="line"><span class="comment">#  time complexity: O(N + M)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility FrogRiverOne in Python</title>
    <url>/2017/06/02/codility-frog-river-one/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(X)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(X)</td>
</tr>
</tbody>
</table>
<p>最优情况在输入数组长度小于河宽X下达成</p>
<h3><span id="算法分析">算法分析</span></h3><p>依次读取输入数组的项，当读取过的项的集合包含1到X在内的所有整数时，输出当前项的数组索引。对于记录读取过的项的集合，可以用一个长度为X+1的<code>check</code>数组来记录。若读取了整数z，就把整数z作为索引，将对应的项置1。对于判断读取过的项的集合是否包含1到X在内的所有整数，我们都可以遍历<code>check</code>数组，检查索引1到X对应的项是否全部为1，如果不是，则说明我们还没有包含1到X在内的所有整数。但是这样，该判断算法需要遍历<code>check</code>数组，复杂度为O(X)。不过有一个小技巧可以将该判断算法降为O(1)，那就是在<code>check</code>数组的基础上，再使用step_left变量来记录还需要读取多少个不同的整数后读取过的项的集合才能包含1到X在内的所有整数。若读取了整数z，除了把整数z作为索引，将对应的项置1外，还要根据条件来更新<code>step_left</code>的值。此时，检查算法只需要判断<code>step_left</code>是否为0即可得知读取过的项的集合是否包含1到X在内的所有整数了。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(X, A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    n = len(A)</span><br><span class="line">    <span class="keyword">if</span> (n &lt; X):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    step_left = X</span><br><span class="line">    check = [<span class="number">0</span>]*(X+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">        <span class="keyword">if</span> (check[A[i]]==<span class="number">0</span>):</span><br><span class="line">            check[A[i]]=<span class="number">1</span></span><br><span class="line">            step_left -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (step_left==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility Tape Equilibrium in Python</title>
    <url>/2017/05/31/codility-tape-equilibrium/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>构造数组前段总和<code>first = A[0]</code>以及数组后端总和<code>last = sum(A) - A[0]</code>，第一个差值便是<code>abs(first - last)</code>。遍历数组时，不必每次都重新构造数组前段总和以及数组后端总和，只需向first增加当前遍历元素，想las减去当前遍历元素，另外，也只要一个变量min_diff来记录最小差值即可。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    first = A[<span class="number">0</span>]</span><br><span class="line">    last = sum(A) - A[<span class="number">0</span>]</span><br><span class="line">    N = len(A)</span><br><span class="line">    min_diff = abs(first - last)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, N - <span class="number">1</span>):</span><br><span class="line">        num = A[i]</span><br><span class="line">        first += num</span><br><span class="line">        last -= num</span><br><span class="line">        min_diff = min(abs(first - last), min_diff)</span><br><span class="line">    <span class="keyword">return</span> min_diff</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility PermMissingElem in Python</title>
    <url>/2017/05/31/codility-perm-missing-elem/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>可以想象有一个数组长度为N+1，数组元素为1,2,…N,N+1，这样便可以用等差求和公式算出该数组的总和。用总和减去输入数组A的和便可以知道数组A缺失了哪个元素。注意python <code>sum()</code>的算法复杂度为O(N)，故该算法的算法复杂度是O(N)。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    N = len(A)</span><br><span class="line">    start = <span class="number">1</span></span><br><span class="line">    end = len(A)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> (N+<span class="number">1</span>)*(start+end)/<span class="number">2</span> - sum(A)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility FrogJmp in Python</title>
    <url>/2017/05/31/codility-frog-jmp/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>算法复杂度不依赖于输入数据的多少，该算法总是在固定时间内完成。</p>
<h3><span id="算法分析">算法分析</span></h3><p>已知长度Y-X，步长D，求步数。难点在于长度能否整除步长，若能整除，返回步长，若不能整除，对步长向上取整。向上取整可以同python math库里的ceil函数。如果不想加载math库，只用python内建函数可以吗？其实也是可以的。难度在对于求得的步长是否+1上。由于python除法<code>/</code>会截断小数部分，我们可以用取余<code>%</code>操作判断长度能否整除步长，若能整除，返回步长，若不能整除，对步长+1即可。</p>
<h3><span id="python-数值转换">Python 数值转换</span></h3><p>python 数值转换函数<code>int()</code>把bool型转换为int型整数值，<code>int(True) =&gt; 1</code> <code>int(False) =&gt; 0</code></p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(X, Y, D)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    <span class="keyword">return</span> (Y-X)/D + int((Y-X)%D &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility OddOccurrencesInArray in Python</title>
    <url>/2017/05/29/odd-occurrences-in-array/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(K)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(K)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(K)</td>
</tr>
</tbody>
</table>
<p>其中，K是数组中互不相同数的个数</p>
<h3><span id="算法分析">算法分析</span></h3><p>遍历数组，算出每个数出现的次数。如果出现的次数为奇数，则返回该数。要点是选择用于记录不同数出现次数的计数器的数据结构和计数方法。对于计数器的数据结构，python built-in的字典可以满足O(1)的读取和记录。对于计数方法，则不必详细记录出现次数，标记奇偶即可。在特定条件下，应该也可以使用位操作，利用二进制0，1比特来标记奇偶，以便使用更小的内存空间。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    count = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> A:</span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> count:</span><br><span class="line">            count[num] = (count[num] + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count[num] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> count:</span><br><span class="line">        <span class="keyword">if</span> count[k] == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> int(k)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility CyclicRotation in Python</title>
    <url>/2017/05/29/codility-cyclic-rotation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(1)</td>
<td>O(N)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>并不是要真的右移K次数组，K对N取模，可求出实际要右移的次数K = K%N。利用python数组切片操作，以N-k为切点，将数组分成前后两部分，颠倒前后顺序拼接后便可得到右移K次的数组。</p>
<h3><span id="pyhton数据切片">Pyhton数据切片</span></h3><p><code>a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></p>
<ul>
<li>给切片起始、终止值和步长，<ul>
<li><code>a[0:5:2] # [0, 2, 4]</code></li>
</ul>
</li>
<li>给切片起始和终止值，步长值缺省时其默认值为1<ul>
<li><code>a[0:5] # [0, 1, 2, 3, 4]</code></li>
<li><code>a[0:]    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></li>
<li><code>a[:5]      # [0, 1, 2, 3, 4]</code></li>
<li><code>a[:]         # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></li>
</ul>
</li>
<li>给负值<ul>
<li><code>a[-1]    # 9</code></li>
<li><code>a[-2:]   # [8, 9]</code></li>
<li><code>a[:-2]   # [0, 1, 2, 3, 4, 5, 6, 7]</code></li>
</ul>
</li>
</ul>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(A, K)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    <span class="comment"># N number of array A</span></span><br><span class="line">    N = len(A)</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> A</span><br><span class="line">    K = K%N</span><br><span class="line">    first = A[N-K:]</span><br><span class="line">    last = A[:N-K]</span><br><span class="line">    <span class="keyword">return</span> first+last</span><br></pre></td></tr></table></figure>
<h3><span id="参考">参考</span></h3><ul>
<li><a href="https://wiki.python.org/moin/TimeComplexity" rel="external nofollow noopener noreferrer" target="_blank">Python数组切片算法复杂度分析</a></li>
<li><a href="https://stackoverflow.com/questions/509211/explain-pythons-slice-notation" rel="external nofollow noopener noreferrer" target="_blank">Python数组切片操作解释</a></li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Codility BinaryGap in Python</title>
    <url>/2017/05/22/codility-binary-gap/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3><span id="算法复杂度分析">算法复杂度分析</span></h3><table>
<thead>
<tr>
<th>情况</th>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最优</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>平均</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最差</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3><span id="算法分析">算法分析</span></h3><p>利用python built-in函数<code>bin()</code>将十进制输入转换为二进制字符串，遇到字符‘0’，计数器<code>count += 1</code>，遇到字符‘1’，计数器清空。变量<code>max</code>记录<code>count</code>最大值，函数最后返回<code>max</code>。但是有一个问题，转换为二进制表示的N没有前导0，但需要注意处理后缀0，以免错误计数。否则，若二进制表示为1001000时，函数返回3而不是2。</p>
<h3><span id="源代码">源代码</span></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span><span class="params">(N)</span>:</span></span><br><span class="line">    <span class="comment"># write your code in Python 2.7</span></span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">2147483647</span> <span class="keyword">or</span> N &lt; <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    s = bin(N)[<span class="number">2</span>:]</span><br><span class="line">    last = s.__len__()<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> (s[last] == <span class="string">'0'</span>):</span><br><span class="line">        last -= <span class="number">1</span></span><br><span class="line">    s = s[<span class="number">0</span>:last+<span class="number">1</span>]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    max = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>):</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt; max):</span><br><span class="line">                max = count</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> max</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>超强文本编辑器Vi/Vim的配置与使用</title>
    <url>/2017/05/21/use-vim/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#为什么要学习vim">为什么要学习Vim</a></li>
<li><a href="#学习vim的正确姿势">学习Vim的正确姿势</a></li>
<li><a href="#配置vim的省时办法">配置Vim的省时办法</a></li>
<li><a href="#vim插件使用">Vim插件使用</a></li>
</ul>
<!-- tocstop -->
<h2><span id="为什么要学习vim">为什么要学习Vim</span></h2><p>Vi或者Vim（Vi加强版）是众多Linux发行版中终端环境自带的文本编辑器，但似乎熟练掌握Vi/Vi不是在Linux上进行软件开发活动的必要条件。因为在Linux上开发软件的过程中，我们总是能找到更便于上手的，学习曲线更平缓的替代工具，比如gedit，sublime或者atom。然而在某些情况下，掌握Vi/Vim却显得十分的必要，比如需要远程链接到一台上个世纪的古董服务器上修改几行配置代码时，使用Vi/Vim进行编辑几乎是你的唯一选择，毕竟Vi诞生于1976年，比Linux的第一个版本发行时还要早17年，此外Vi/Vim可以直接运行在终端环境中，而gedit，sublime或者atom却需要在桌面环境的支持下才能运行。<br><a id="more"></a><br>在刚进入公司实习时，培训材料中就有如何使用Vim以及如何用Vundle配置Vim的教程。但是其实我发现公司里用的最多的文本编辑器不是Vim，而是Atom。这样的现象，我个人觉得还是由于Vim的学习曲线些陡峭造成的。毕竟Vim不如gedit，sublime或者atom般开箱即用（out of the box），新手并不能指望在半个小时内掌握它，用它进行简单的编辑操作。此外，插件管理也不如sumblim或者atom般显而易见。我记得在实习第一周培训时，我自己就用了一天时间来配置Vim，给Vim安装Airline，NERDTree，Fugitive等等插件，来让Vim看起来更像一个桌面环境下的文本编辑器。实际上，公司里还是有人在使用Vim的，通常他们的编程水平都很高，完全不用鼠标，也很少从终端中切换出来，除非他们在搞全栈开发，需要时不时的在浏览器中测试下代码。</p>
<p>有人说Vi/Vim是人类历史上最好用的文本编辑器，虽然我不知道此话的出处是哪里，暂且认同此话，如果能熟练掌握人类历史上最好用的文本编辑器，那自己作为程序员的逼格也会是相当的高，在众多的文本编辑器中，Vi/Vim应该是最符合Geek的。</p>
<h2><span id="学习vim的正确姿势">学习Vim的正确姿势</span></h2><p>如果你有心，在Google里搜索Vim学习指南，我相信会有不少的学习笔记，或者类似于《X分钟/小时内掌握人类历史上最好用的文本编辑器》的文章。相信我，后面那种类型的文章还是不要看了，除非是vimtutor的翻译，后面我会提到。其实我很同意陈皓在<span class="exturl" data-url="aHR0cDovL2Nvb2xzaGVsbC5jbi9hcnRpY2xlcy81NDI2Lmh0bWw=" title="http://coolshell.cn/articles/5426.html">《简明 VIM 练级攻略》<i class="fa fa-external-link"></i></span>中把学习Vim喻为学习钢琴，学习Vim不是30分钟的事情，而是需要几个星期去不断练习的。实际上，大多数Linux发行版除了自带Vi/Vim编辑器外，也内置了Vi/Vim的教程，在终端中输入<code>vimtutor</code>你就可以进入一个交互式的Vim学习教程中，该教程一共有7节，从hjkl光标移动，到编辑vimrc脚本均有涉及。默认的vimtutor是英文版的，网上也有很好的翻译版本，比如<span class="exturl" data-url="aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dqcDIwMTMvdGhlX3Jvb21fb2ZfZXhlcmNpc2VzL21hc3Rlci8lRTglQUYlQkIlRTQlQjklQTYlRTclQUMlOTQlRTglQUUlQjAvdmltdHV0b3IvMzAlRTUlODglODYlRTklOTIlOUYlRTUlQUQlQTYlRTQlQkMlOUF2aW0lRTQlQjklOEJ2aW10dXRvciglRTUlOEYlOEMlRTglQUYlQUQlRTclODklODgpLnR4dA==" title="https://raw.githubusercontent.com/wjp2013/the_room_of_exercises/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/vimtutor/30%E5%88%86%E9%92%9F%E5%AD%A6%E4%BC%9Avim%E4%B9%8Bvimtutor(%E5%8F%8C%E8%AF%AD%E7%89%88).txt">《30分钟学会vim之vimtutor(双语版)》<i class="fa fa-external-link"></i></span></p>
 <img data-src="/2017/05/21/use-vim/vimtutor.png" title="Vi/Vim编辑器的内置了的Vi/Vim教程">
<h2><span id="配置vim的省时办法">配置Vim的省时办法</span></h2><p>之前我有提到在实习第一周培训时，我自己就用了一天时间来配置Vim，给Vim安装Airline，NERDTree，Fugitive等等插件。Vim有一个非常好的插件管理工具<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1Z1bmRsZVZpbS9WdW5kbGUudmlt" title="https://github.com/VundleVim/Vundle.vim">Vundle<i class="fa fa-external-link"></i></span>，安装完Vundle后，我们可以根据自己的喜好来管理，安装Vim插件来对Vim进行配置。其实直到今天我才发现了配置Vim更简单的方法，那就是用Vim发行版<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NwZjEzL3NwZjEzLXZpbQ==" title="https://github.com/spf13/spf13-vim">spf13<i class="fa fa-external-link"></i></span>。spf13是一个跨平台的Vim发行版，可以在Windows，Linux和Mac平台上运行。简单来说，spf13就是帮你写好了vimrc文件，在Vim中执行PluginInstall命令后，所有在vimrc里设置好的插件就会依次安装。</p>
 <img data-src="/2017/05/21/use-vim/vimrc.png" title="安装完spf13-vim发行版后的vimrc配置文件">
<h2><span id="vim插件使用">Vim插件使用</span></h2><p>spf13集成了超多的Vim插件，比如用于显示文件目录结构的NERDTree，方便文件查找的ctrlp，集成语法检查Syntastic，Git集成的Fugitive等等。先在这里占个坑，接下来会写每个插件的使用方法</p>
<ul>
<li><a href>Vim最好用的插件管理器Vundle</a></li>
<li><a href>文件导航利器NERDTree</a></li>
<li><a href>超快速文件查询ctrlp</a></li>
<li><a href>括号引号编辑器Surround</a></li>
<li><a href>代码注释编辑NERDCommenter</a></li>
<li><a href>集成语法检查Syntastic</a></li>
<li><a href>相对/绝对代码行号切换numbers.vim</a></li>
<li><a href>智能自动补全插件neocomplcache</a></li>
<li><a href>深度Git集成Fugitive</a></li>
<li><a href>PHP编辑利器PIV</a></li>
<li><a href>超级文本对齐Tabularize</a></li>
<li><a href>指哪打哪EasyMotion</a></li>
</ul>
]]></content>
      <categories>
        <category>Text Editor</category>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Git分支与部署架构</title>
    <url>/2017/05/08/git-branch-and-deployment-architectures/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#开发分支-dev">开发分支 DEV</a></li>
<li><a href="#测试分支-test">测试分支 TEST</a></li>
<li><a href="#缓冲分支-staging">缓冲分支 STAGING</a></li>
<li><a href="#生产分支-prod">生产分支 PROD</a></li>
</ul>
<!-- tocstop -->
<p>一般来说，利用git进行多人协作的网站开发项目都有不止一个分支，其中每一个分支对应于网站部署的一个架构。虽然网站部署架构千差万别，但几乎都是从开发环境（DEV）开始并以生产环境（PROD）结束，所以对应到git分支上就是 开发分支，测试分支，缓存分支和生产分支。</p>
<h3><span id="开发分支-dev">开发分支 DEV</span></h3><p>开发分支是本地开发环境上用于开发新功能的分支，开发人员可以方便的在本地进行单元测试<br><a id="more"></a></p>
<h3><span id="测试分支-test">测试分支 TEST</span></h3><p>测试分支对应于测试环境，新功能开发完毕并在本地环境通过单元测试后，开发分支才可以合并到测试分支中，之后将测试分支部署到测试环境中进行集成测试</p>
<h3><span id="缓冲分支-staging">缓冲分支 STAGING</span></h3><p>缓冲分支对应于缓冲环境，它是是生产环境的镜像，拥有和生产环境一样的硬件，软件环境，所以在这里可以进行和生产环境一样的测试（性能测试，负载测试等）。当新功能在测试环境通过集成测试后，开发分支才可以合并到缓冲分支中，之后将缓存分支部署到缓冲环境里进行和生产环境一样的测试</p>
<h3><span id="生产分支-prod">生产分支 PROD</span></h3><p>生产分支对应于生产环境，生产环境也就是用户可以直接交互的环境。我们访问的网站，其实都是部署在生产环境里的。新功能在缓存分支通过测试后，含有新功能的开发分支最后并入生产分支中，生产分支被部署到生产环境里，新功能此时也最终被交付到了用户手中。</p>
<p>一般来说，含有新功能的分支按顺序合并到测试分支，缓存分支和生产分支中，包含新功能的测试分支，缓存分支和生产分支也按顺序被部署到测试环境，缓存环境和生产环境中。一个网站的新功能就是这样经历重重测试，最终交付到用户手中哒。</p>
<p>想要知道更多有关部署架构知识，请参考<span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVwbG95bWVudF9lbnZpcm9ubWVudA==" title="https://en.wikipedia.org/wiki/Deployment_environment">Wiki部署环境<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Git Basics</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>部署架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Git cherry-pick</title>
    <url>/2017/05/07/git-cherry-pick/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#什么时候使用cherry-pick">什么时候使用Cherry-pick</a></li>
<li><a href="#一个例子">一个例子</a></li>
</ul>
<!-- tocstop -->
<p>一般来说，掌握了git的commit，branch，merge几个命令就足以应付90%的工作场景了，但是有时候我们也需要处理稍微复杂一点的工作场景，比如整理提交记录。</p>
<h2><span id="什么时候使用cherry-pick">什么时候使用Cherry-pick</span></h2><p>Cherry pick 直译成中文就是采樱桃，樱桃有好有坏，挑选樱桃的过程就形象的类比了我们应用该命令挑选提交（Commit）的过程。<br>一般来说，利用git进行多人协作的网站开发项目都有不止一个分支，其中每一个分支对应于网站部署的一个架构。在多分支环境下，如果我们想要将一个或者一些在其他分支下提交（Commit）复制到当前分支所在的位置（HEAD）的话，<code>cherry-pick</code> 是最直接，最方便的办法了。<br><a id="more"></a></p>
<h2><span id="一个例子">一个例子</span></h2><p><img data-src="https://cloud.githubusercontent.com/assets/15102793/25820068/4d99fcec-3430-11e7-8c66-3138cad6182f.png" alt="git cherry-pick命令图示，图片来源：http://learngitbranching.js.org"></p>
<p>如上图所示，如果我们想要将side分支上C2与C4分支复制到当前分支master所在位置的话，<code>git cherry-pick C2 C4</code> 能帮助我们吧side分支上的C2与C4提交以此应用到当前分支中，产生C2’与C4’提交，其中，这两个提交的内容分别和C2与C4对应，不过hash值会重新计算，不再与原hash值一样。</p>
<p>在这里我也要推荐一个学习git操作的好网站 <span class="exturl" data-url="aHR0cDovL2xlYXJuZ2l0YnJhbmNoaW5nLmpzLm9yZy8=" title="http://learngitbranching.js.org/">learngitbranching.js.org<i class="fa fa-external-link"></i></span>，也就是上面截图的来源。虽然网站名字叫做learn git branching，但是教学内容几乎涵盖git的方方面面。最重要的是，与看教程不同的是，该网站有交互式的git log graph，是git入门的不二之选。</p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Git Advances</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>设置Git别名</title>
    <url>/2017/05/07/git-alias/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#通过conig命令设置git别名">通过conig命令设置Git别名</a></li>
<li><a href="#通过config文件设置git别名">通过config文件设置Git别名</a></li>
</ul>
<!-- tocstop -->
<p>刚刚进公司时，发现同事在使用Git时都是输入一些我从来没见过的命令，比如<code>git st</code>, <code>git ci</code>什么的，但是这些命令在自己的电脑上却不存在。更有甚者，有同事优雅的在终端上输入<code>git fuck</code>命令，git竟把远端的branch fetch回本地了，我的天，难道自己用的是假git吗？<br>我弱弱问身边的同事，这才知道git别名的存在，借助于git别名我们就可以为git已有的命令取个上口好记的别名了。</p>
<h2><span id="通过conig命令设置git别名">通过conig命令设置Git别名</span></h2><p>通常情况下，git最常用的几个命令是 <code>git branch</code>, <code>git checkout</code>, <code>git commit</code> 和<code>git status</code>。如果只是为这几个命令设置git别名，最简单的方法是在终端中输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>
<h2><span id="通过config文件设置git别名">通过config文件设置Git别名</span></h2><p>不过，如果我们一次想设置的别名比较多，那么我们可以通过修改<code>~/.gitconfig</code>文件来实现。<br>这时我们可以通过添加以下字段来完成和上述一样的设置.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        br = branch</span><br><span class="line">        co = checkout</span><br><span class="line">        ci = commit</span><br><span class="line">        st = status</span><br></pre></td></tr></table></figure></p>
<p>同时，如果我们想修改或者取消自己设置的git别名，那么我们也可以通过修改或者删除<code>~/.gitconfig</code>文件中相应的设置来达到目的。</p>
<p>熟练的程序员和小白程序员的一个重大区别是前者会不断的优化自己的工作流程，能少花一秒钟解决的事情绝对不会用上两秒钟去做。也许这么说有些夸张，但是时间积少成多，git别名就是优化Git工作流程的利器。</p>
<p>有关更多git别名的使用方法，请参考Git官方文档 <span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9ib29rL3poL3YyL0dpdC0lRTUlOUYlQkElRTclQTElODAtR2l0LSVFNSU4OCVBQiVFNSU5MCU4RA==" title="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-Git-%E5%88%AB%E5%90%8D">Git 基础 - Git 别名<i class="fa fa-external-link"></i></span></p>
]]></content>
      <categories>
        <category>Git</category>
        <category>Git Basics</category>
      </categories>
      <tags>
        <tag>git-alias</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈开发小白的环境配置</title>
    <url>/2017/04/16/dev-env-for-full-stack-dev/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2><span id="目录">目录</span></h2><!-- toc -->
<ul>
<li><a href="#放弃bash使用zsh">放弃Bash，使用Zsh</a><ul>
<li><a href="#zsh的使用">Zsh的使用</a><ul>
<li><a href="#安装zsh">安装Zsh</a></li>
<li><a href="#安装zsh的配置插件oh-my-zsh">安装Zsh的配置插件，oh-my-zsh</a></li>
<li><a href="#更换oh-my-zsh默认主题">更换oh-my-zsh默认主题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#放弃terminal使用terminator">放弃Terminal，使用Terminator</a><ul>
<li><a href="#安装terminator">安装Terminator</a></li>
<li><a href="#使用terminator">使用Terminator</a></li>
</ul>
</li>
<li><a href="#进阶配置">进阶配置</a></li>
</ul>
<!-- tocstop -->
<p>作为一个小白全栈开发程序员，有一个顺手的开发环境能很好的节约自己的时间。这篇文章就简单的介绍一下，最近自己在Ubuntu系统上使用的全站开发环境以及相应的配置流程。</p>
<h2><span id="放弃bash使用zsh">放弃Bash，使用Zsh</span></h2>
<p>就笔者所使用的Ubuntu 16.04而言，Termianl默认的Shell是大名鼎鼎的Bash，虽然Bash几乎是所有Linux发行版的默认Shell，但对于我这个小白程序员而言却不一定是最优的选择。比如说我想知道Linux下常用的压缩解压缩命令tar后面可以用什么参数，怎么使用， 或者想要使用的某个命令我只记得其中的一部分，需要自动补全。这时候Zsh就能满足我这个小白的需求了。</p>
<a id="more"></a>
<h3><span id="zsh的使用">Zsh的使用</span></h3><h4><span id="安装zsh">安装Zsh</span></h4><ol>
<li><p>用Ubuntu系统自带的软件包管理工具 <code>apt-get</code></p>
<p><code>sudo apt-get update &amp;&amp; sudo apt-get install zsh</code></p>
</li>
<li><p>接着将Zsh设置为系统默认Shell</p>
<p><code>chsh -s /bin/zsh</code></p>
</li>
<li><p>重启系统</p>
<p><code>sudo reboot</code></p>
</li>
<li><p>重启系统，再次启动Terminal后，在Shell提示中选择 0 (生成一个空的Zsh配置文件.zshrc)， 接下来我们再详细说明如何配置Zsh</p>
<img data-src="/2017/04/16/dev-env-for-full-stack-dev/14_28_14.png" title="重启系统在Shell提示中选择 0 (生成一个空的Zsh配置文件.zshrc)">
</li>
<li><p>验证安装，输入下面的命令，Terminal将会输出zsh</p>
<p><code>echo $0</code></p>
</li>
</ol>
<p>虽然按照以上步骤，我们在Ubuntu上安装好了Zsh，但是现在Zsh却并不好用。比如没有高亮显示，在git目录下也没有分支提示等。配置Zsh我们可以对用户根目录下的Zsh配置文件.zshrc<br>进行改动，也可以克隆Github上oh-my-zsh这个项目，使用预定义好的主题，来加快我们对Zsh的配置。</p>
<h4><span id="安装zsh的配置插件oh-my-zsh">安装Zsh的配置插件，oh-my-zsh</span></h4><ul>
<li><p>使用curl命令下载并执行oh-my-zsh的安装脚本</p>
<p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p>
<img data-src="/2017/04/16/dev-env-for-full-stack-dev/14_52_22.png" title="安装脚本执行完毕后，Zsh自动配置完毕">
</li>
</ul>
<p>接下来我们就可以享受Zsh带给我们的便利了</p>
<h4><span id="更换oh-my-zsh默认主题">更换oh-my-zsh默认主题</span></h4><p>oh-my-zsh 的主题是robbyrussell，效果图如上所示。同时，可以通过用户根目录下的Zsh配置文件.zshrc来更换oh-my-zsh 的主题，比如我很喜欢的agnoster。修改过程如下</p>
<ul>
<li><p>将默认字段 <code>ZSH_THEME=&quot;robbyrussell&quot;</code> 改为<code>ZSH_THEME=&quot;agnoster&quot;</code></p>
</li>
<li><p>由于agnoster主题使用了powerline中的字体，很有可能在没有相应字体的环境下，terminal会有如下字体显示问题</p>
<img data-src="/2017/04/16/dev-env-for-full-stack-dev/agnoster_font_problem.png" title="agnoster 主题的zsh遇到了字体显示问题">
</li>
</ul>
<ul>
<li><p>如果遇到字体显示问题，可以安装该<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Bvd2VybGluZS9mb250cw==" title="https://github.com/powerline/fonts">repo<i class="fa fa-external-link"></i></span>中的字体或使用以下脚本安装缺失的字体</p>
<p><code>sudo apt-get install fonts-powerline</code></p>
<img data-src="/2017/04/16/dev-env-for-full-stack-dev/agnoster_font_correct.png" title="agnoster 主题的zsh">
</li>
</ul>
<h2><span id="放弃terminal使用terminator">放弃Terminal，使用Terminator</span></h2><p>Ubuntu系统自带的Terminal固然好用，但是也有局限性。比如我想要同时查看两个Web App运行状态在Terminal上的输出，就得打开两个Terminal的窗口来监视，有没有可能在一个窗口下打开多个Terminal，并来回切换呢？Terminator便是为解决这个需求而存在的。</p>
<h3><span id="安装terminator">安装Terminator</span></h3><ol>
<li><p>用Ubuntu系统自带的软件包管理工具 <code>apt-get</code></p>
<p><code>sudo apt-get update &amp;&amp; sudo apt-get install terminator</code></p>
</li>
<li><p>后台运行Terminator</p>
<p><code>terminator &amp;</code></p>
</li>
</ol>
<p>打开Terminator，系统自带的Terminal就可以关掉了。右键Terminator图标，选择固定到启动栏，这样以后可以直接点击图标启动Terminator，不用再通过系统自带的Terminal来启动了。</p>
<h3><span id="使用terminator">使用Terminator</span></h3><img data-src="/2017/04/16/dev-env-for-full-stack-dev/16_02_44.png" title="同时打开了四个Terminal窗口的Terminator">
<p>借助快捷键，Terminator有着强大的多窗口Terminal管理功能，下面我选取最常用的几个功能进行介绍。</p>
<ul>
<li><kbd>shift</kbd> + <kbd>ctrl</kbd> + <kbd>o</kbd> 向下分裂与当前窗口等宽的新窗口</li>
<li><kbd>shift</kbd> + <kbd>ctrl</kbd> + <kbd>e</kbd> 向右分裂与当前窗口等宽的新窗口</li>
<li><kbd>shift</kbd> + <kbd>ctrl</kbd> + <kbd>w</kbd> 关闭当前窗口</li>
<li><kbd>shift</kbd> + <kbd>+</kbd> 增加当前窗口字体大小</li>
<li><kbd>shift</kbd> + <kbd>-</kbd> 减小当前窗口字体大小</li>
</ul>
<h2><span id="进阶配置">进阶配置</span></h2><ul>
<li><a href="http://codingnote.com/2017/05/21/use-vim/">超强文本编辑器Vi/Vim的配置与使用</a></li>
<li><a href="http://codingnote.com/2017/04/16/dev-env-for-full-stack-dev/">终端下的多窗口与分屏神器Tmux…占坑用</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Zsh</tag>
        <tag>Terminator</tag>
        <tag>oh-my-zsh</tag>
      </tags>
  </entry>
</search>
